{
  "games": [ {
    "name": "Trivia",
    "projectID": 1308,
    "gameID": 1308,
    "script": "local bckGround;\nlocal hud;\nlocal dude;\nlocal optA;\nlocal optB;\nlocal optC;\n\nlocal width = 720;\nlocal height = 1280;\n\nlocal min = 1;\nlocal max = 20;\nlocal score = 0;\nlocal scorePos = 0;\nlocal tries = 5;\nlocal time = 20;\nlocal timeFraction = 9;\nlocal timeText = \"12:00\";\nlocal continueCount = true;\nlocal clockCountStarted = false;\nlocal canAnswer = false;\nlocal textSize = 2;\nlocal opText;\nlocal optAText = \"\";\nlocal optBText = \"\";\nlocal optCText = \"\";\nlocal correctOpt = \"\";\n\nlocal questionImg;\nlocal bannerImg;\nlocal wonPopUpImg;\n\nlocal level = 1;\nlocal img_level = [];\nlocal img_answer = [];\nlocal flganswer = false;\n\nlocal showLevelText = false;\nlocal showLoseText = false;\nlocal showWinText = false;\nlocal legendColor = make_rgba(196,47,47,255);\nlocal questionColor = make_rgba(255,255,255,255);\nlocal answerColor = make_rgba(0, 0, 0, 255);\n\nlocal isAnimating = false;\n\nlocal deltaTime = 0;\nlocal previousTime = 0;\n\nlocal loseImg;\n\nlocal dataManager;\n\nclass GameObject\n{\n   constructor()\n    {\n       position = vector_2();\n   }\n\n  asset = null;\n    shape = null;\n    position = null;\n\n   function initGameObject(id,withShape)\n    {\n       asset = load_asset(id,false);\n\n     if(withShape)\n       {\n          shape = phy_create_shape_for_asset(asset,true);\n     }\n    }\n\n  function moveObject(posX,posY)\n   {\n       if(asset != null)\n       {\n          move_asset(asset,posX,posY);\n    }\n       if(shape != null)\n       {\n          phy_move_shape(shape,posX,posY);\n    }\n       position.x = posX;\n      position.y = posY;\n   }\n\n  function readjustToPosition()\n    {\n       moveObject(position.x,position.y);\n   }\n\n  function Draw()\n  {\n       if(asset != null)\n       {\n          draw_asset(asset);\n      }\n    }\n}\n\nenum animType\n{\n  X_MOVEMENT,\n  Y_MOVEMENT,\n  X_Y_MOVEMENT\n};\nclass FrameRateFreeAnimator extends GameObject\n{\n  constructor()\n    {\n       base.constructor();\n     progress = 2;\n       isRuning = false;\n    }\n\n    duration = null;\n    factor = null;\n    initPoint = null;\n    progress = null;\n    aType = null;\n    onCompleteCalled = null;\n    callBack = null;\n    isRuning = null;\n\n  function advanceAnimation()\n  {\n    progress += deltaTime * duration;\n\n    if(progress < 1)\n    {\n      runAnim();\n    }\n    else if(!onCompleteCalled)\n    {\n      onCompleteCalled = true;\n      onComplete();\n    }\n  }\n\n  function runAnim()\n   {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         position.x += factor * (deltaTime * duration);\n      break;\n      case(animType.Y_MOVEMENT):\n         position.y += factor * (deltaTime * duration);\n      break;\n      case(animType.X_Y_MOVEMENT):\n       position.x += factor.x * (deltaTime * duration);\n       position.y += factor.y * (deltaTime * duration);\n    break;\n      }\n       moveObject(position.x,position.y);\n   }\n\n  function setUp(anmType,nFactor,cllBack)\n  {\n       callBack = cllBack;\n     aType = anmType;\n    if(anmType == animType.X_Y_MOVEMENT)\n    {\n          factor = vector_2();\n       factor.x = nFactor.x;\n          factor.y = nFactor.y;\n       }\n       else\n    {\n          factor = nFactor;\n       }\n    }\n\n  function startAnim(nDuration)\n    {\n       if(!isRuning)\n       {\n          isRuning = true;\n       setInit();\n         if(nDuration > 0)\n          {\n             duration = 1.0/nDuration;\n          }\n          progress = 0;\n          onCompleteCalled = false;\n       }\n    }\n\n  function setInit()\n   {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         initPoint = position.x;\n     break;\n      case(animType.Y_MOVEMENT):\n         initPoint = position.y;\n     break;\n      case(animType.X_Y_MOVEMENT):\n       initPoint = position;\n       break;\n      }\n    }\n\n  function onComplete()\n    {\n       adjustToAbsolute();\n     callBack();\n     isRuning = false;\n    }\n\n  function adjustToAbsolute()\n  {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         position.x = initPoint + factor;\n    break;\n      case(animType.Y_MOVEMENT):\n         position.y = initPoint + factor;\n    break;\n      case(animType.X_Y_MOVEMENT):\n       position.x = initPoint.x + factor.x;\n       position.y = initPoint.y + factor.y;\n    break;\n      }\n       moveObject(position.x,position.y);\n   }\n}\n\nlocal DATA = \"¿Cuál es el país menos turístico%% de Europa?@@Liechtenstein@@Moldavia@@Armenia$$¿A qué país pertenece la%% isla de Tasmania?@@Australia@@Portugal@@Estados Unidos$$¿En cuál de los siguientes%% países NO hay ningún%% desierto?@@Alemania@@Chile@@España$$¿Cuál es el código internacional%% para Cuba?@@CU@@CB@@CA$$¿Cuál es la capital del%% estado de Arkansas?@@Little Rock@@Hot Springs@@Kansas$$¿En qué país situarías la%% ciudad de Cali?@@Colombia@@Venezuela@@Costa Rica$$¿Cuál de estas características%% no pertenece al clima%% Mediterráneo?@@Lluvias muy abundantes@@Es un tipo de clima templado@@Veranos secos y calurosos$$¿Qué es el Cabo de Creus?@@El punto más oriental de%% la Península@@El punto más oriental de%% Cataluña@@El punto más oriental de%% España$$¿Cuál es principal celebración%% holandesa?@@El día de la Reina@@La llegada del verano@@Navidad$$¿Cuál de las siguientes%% especialidades NO es%% típica de la cocina %%estadounidense?@@Todas son típicas@@El pastel de cangrejo@@La hamburguesa$$¿Con cuántos países limita%% Argentina?@@Cinco@@Cuatro@@Tres$$¿Qué es la UA?@@Unión Africana@@Unión Americana@@Unión Austrohúngara$$¿Cuál es la capital de Suiza?@@Berna@@Zurich@@Basilea$$¿Qué separa las franjas%% de Gaza y Cisjordania?@@Israel@@Nada@@Un muro$$¿En qué país está Ushuaia,la%% ciudad más al sur del%% mundo?@@Argentina@@Chile@@Nueva Zelanda$$¿Cuál de estos países africanos%% no tiene costa?@@Todas tienen costa@@Senegal@@Mauritania&&$$¿En qué se dividen las rupias%% indias y pakistanís?@@En paisas@@En céntimos@@En centavos$$¿Cuál de las siguientes%% islas está más al sur?@@Malta@@Córcega@@Sicilia$$¿Cuál de las siguientes%% ciudades no es una ciudad%% santa?@@Burgos@@Hebrón@@Santiago de Compostela$$¿Cuál es la capital de Baréin?@@Manama@@Riad@@Baréin$$¿En qué país está la Laguna%% Verde?@@Bolivia@@Argentina@@Chile$$¿En qué cordillera están%% la mayoría de las grandes%% montañas?@@En el Himalaya@@En las Montañas Rocosas@@En el Karakórum$$¿Qué ciudad europea es famosa%% por la belleza de su%% parlamento?@@Budapest@@Madrid@@París$$¿Cuál es la capital de Libia?@@Trípoli@@Beirut@@El Cairo$$¿Entre qué dos países está%% el lago Titicaca?@@Bolivia y Perú@@Bolivia y Paraguay@@Bolivia y Argentina$$¿Cuál es la capital de la%% república de Macedonia?@@Skopje@@Chisinau@@La Valeta$$¿Qué accidente geográfico%% se define como un conjunto%% de islas,islotes y diminutas%% masas de tierra cercanas%% entre sí?@@Archipiélago@@Islotes@@Meandro$$¿A qué país pertenece la%% isla Mujeres?@@México@@Argentina@@Colombia$$¿Qué país es bañado por%% la Bahía de Hudson?@@Canadá@@Reino Unido@@Estados Unidos$$¿Qué país africano fue antigua%% colonia española?@@Guinea Ecuatorial@@Sudáfrica@@R.D. Congo$$¿En qué continente/s se%% encuentra Turquía?@@Asia y Europa@@África y Europa@@América$$¿Cuál es la religión mayoritaria%% en China?@@Budismo@@Taoísmo@@Confucianismo&&$$¿En qué mar desemboca el%% río Segura?@@Mar Mediterráneo@@Mar Cantábrico@@Ninguna es correcta$$¿Que accidente geográfico%% se define como una pendiente%% vertical abrupta?@@Un acantilado@@Un barranco@@Una montaña$$¿Cuál es el edificio más%% famoso en Dubai?@@Burjal Arab@@Torre Eiffel@@Crystal Island$$¿Con cuántos países limita%% la República Argentina?@@Cinco@@Tres@@Seis$$¿Dónde está el desierto%% del Gobi?@@Al sur de Mongolia@@Al sur de China@@Al sur de Japón$$¿Dónde se encuentra Baiona?@@Pontevedra@@País Vasco@@Francia$$¿A qué país pertenece la%% Isla de Pascua?@@Chile@@Es un país@@Indonesia$$¿En qué país de África es%% el español el idioma%% oficial?@@Ghana@@Gabón@@Camerún$$¿Cuál es la capital de Argelia?@@Argel@@Arabia@@Argela$$¿Dónde está la isla más%% joven del mundo,nacida%% en 2011 producto de una%% erupción volcánica?@@En Yemen@@En Omán@@En la Polinesia Francesa$$¿En qué continente está%% la India?@@Asia@@América@@Oceanía$$¿Cuál es la capital del%% estado de California?@@Sacramento@@Los Ángeles@@San Francisco$$¿Cuál es el mayor golfo%% de África?@@El de Guinea@@El de Gabés@@El de Sirte$$¿Cúales son las ciudades%% autónomas de España?@@Ceuta y Melilla@@Melilla y Nador@@Melilla y Alhucemas$$¿Cúal es la capital de Alemania?@@Berlín@@Múnich@@Frankfurt$$¿Dónde está la ciudad de%% Mostar?@@Bosnia y Herzegovina@@Montenegro@@Serbia&&$$¿De dónde es capital Thimbu?@@De Bután@@De Nepal@@De Thimbu$$¿Cuál es la capital de Ecuador?@@Quito@@Guayaquil@@Lima$$¿Cuál de estos países no%% está en una isla?@@Ghana@@Jamaica@@Japón$$¿Cuál de las siguientes%% ciudades sudafricanas%% es la más poblada?@@Johannesburgo@@Ciudad del Cabo@@East London$$¿Cuál de las grandes montañas%% ha sido escalada más%% veces?@@El Everest@@El Annapurna I@@El K2$$¿Dónde queda el monumento%% a la mitad del mundo?@@Quito@@Bogota@@Manaos$$¿Dónde se encuentra la cordillera%% de Los Andes?@@América@@Asia@@Europa$$¿A qué localidad manchega%% irías a por 'berenjenas'?@@a Almagro@@a Orejilla del Sordete@@Al Toboso$$¿En qué ciudad española%% encontrarás los barrios%% de la Trinidad,la Palmilla%% y Carranque?@@Málaga@@Barcelona@@Sevilla$$¿Dónde vivía Pablo Escobar?@@Colombia@@Ecuador@@Argentina$$¿A qué archipiélago pertenece%% la isla de Gran Canaria?@@Canario@@Chinijo@@Isleño$$¿Cuál es la capital de Corea%% Del Sur?@@Seúl@@Pyongyang@@Busan$$¿Dónde se encuentra la ciudad%% de Bahía Blanca?@@Argentina@@Chile@@Uruguay$$Una península es una parte%% del territorio...@@Rodeada de agua menos por%% una parte@@Rodeada totalmente de agua@@Muy montañosa$$¿A qué ciudad costera europea%% se la conoce como la%% Perla del Adriático?@@Dubrovnik@@Nápoles@@Barcelona$$¿En qué continente se encuentra%% el país México?@@América@@Asia@@Europa&&$$¿Cuál es la capital de Angola?@@Luanda@@Zuberoa@@Kinasasa$$¿Dónde están las torres%% Petronas?@@En Malasia@@En Indonesia@@En Singapur$$¿Dónde se celebra el Oktoberfest?@@Alemania@@Rusia@@Ucrania$$¿Cuál es el plato típico%% de Mallorca?@@Tumbet@@Paella@@Marisco$$¿Dónde nació el Hip-Hop?@@Nueva York@@San Francisco@@Chicago$$¿Cuál es el idioma oficial%% de Uruguay?@@El español@@El uruguayo y el español@@El uruguayo$$¿Conocida por su barrio%% rojo y sus cafeterías,en%% las que se vende cannabis?@@Ámsterdam@@Berlín@@Praga$$¿Cuál es la capital de Kosovo?@@Prístina@@Tenerife@@Kosovo$$¿Cuándo es verano en el%% hemisferio sur?@@De diciembre a marzo@@De marzo a junio@@De junio a septiembre$$¿Qué país NO se encuentra%% en Asia?@@Comores@@Sri Lanka@@Indonesia$$¿Cuál es la capital de Japón?@@Tokio@@Kyoto@@Pekin$$¿Cuál de estos países africanos%% NO tiene costa ?@@Chad@@Túnez@@Sudáfrica$$¿Cuál es la capital de Belice%% ?@@Belmopan@@Managua@@Kingston\";\n\nclass QuestionsManager\n{\n    constructor()\n    {\n    }\n\n  questions = [];\n  startIndex = 0;\n  endIndex = 0;\n    nData = [];\n  correctAnswers = 0;\n  numberOfQuestion = 0;\n    maxNumber = 5;\n   currentQuestion = 0;\n\n   function processData()\n   {\n       local i = 0;\n    local difficulty = 1;\n\n     for(;i < DATA.len();i++)\n    {\n          if(searchOnDataFor2ConsecutiveCharacters(i,\"@\"))\n         {\n             addTextToData(i);\n             i++;\n       }\n          if(searchOnDataFor2ConsecutiveCharacters(i,\"$\"))\n         {\n             if(searchOnDataFor2ConsecutiveCharacters(i-2,\"&\"))\n          {\n                createNewQuestion(i-2,difficulty);\n               difficulty ++;\n               startIndex += 2;\n          }\n             else\n          {\n                createNewQuestion(i,difficulty);\n          }\n             i++;\n       }\n       }\n       createNewQuestion(i,difficulty);\n }\n\n  function searchOnDataFor2ConsecutiveCharacters(index,character)\n  {\n       if(DATA.slice(index,index+1) == character)\n      {\n          if((index+2) <= DATA.len())\n        {\n             if(DATA.slice(index+1,index+2) == character)\n          {\n                return true;\n          }     \n       }\n       }\n       return false;\n    }\n\n  function addTextToData(fromDataIndex)\n    {\n       endIndex = fromDataIndex;\n       nData.push(DATA.slice(startIndex,endIndex));\n    startIndex = endIndex;\n   }\n\n  function createNewQuestion(fromDataIndex,dif)\n    {\n       addTextToData(fromDataIndex);\n       questions.push(Question(nData,dif));      \n    startIndex += 2;\n    nData = [];\n  } \n\n function getQuestionOfDifficulty(dif)\n  {\n    local options = [];\n    local i = 0;\n\n    for(local i = 0;i < questions.len();i++)\n    {\n      if((questions[i].difficulty == dif) && !(questions[i].used))\n      {\n        options.push(questions[i]);\n      }\n    }\n    currentQuestion = options[random_int(0,options.len()-1)];\n  }\n\n  function getCurrentQuestion() \n  {\n    return currentQuestion;    \n  }\n\n  function questionAnswered(questAnswer)\n  {\n    numberOfQuestion++;\n\n    if(getCurrentQuestion().answerSelected(questAnswer))\n    {\n      score += 20;\n      correctAnswers++;\n    }\n    else\n    {\n      showLoseText = true;\n      dude.startAnim(-1);\n      call_function_after_time(turnOffText,1000);\n      return false;\n    }\n\n    if(numberOfQuestion == maxNumber)\n    {\n      numberOfQuestion = 0;\n      if(correctAnswers == maxNumber)\n      {\n        correctAnswers = 0;\n        level++;\n        play_effect(4);\n        call_function_after_time(nextLevelText,500);\n        return true;\n      }\n    }\n    return true;\n  }\n\n  function nextLevelText()\n {\n       showLevelText = true;\n       call_function_after_time(turnOffText,1000);\n  }\n\n  function resetManager()\n  {\n       correctAnswers = 0;\n      level = 1;\n\n    for(local i = 0;i < questions.len();i++)\n    {\n          questions[i].used = false;\n      }\n    }\n}\n\nclass Question\n{\n    constructor(stringDataArray,dif) \n    {\n       answers = [];\n       questionTxt = stringDataArray[0];\n       difficulty = dif;\n       used = false;\n\n     local answerFlag = true;\n    for(local i = 1;i < stringDataArray.len();i++)\n      {\n          answers.push(Answer(stringDataArray[i],answerFlag));\n       answerFlag = false;\n     }\n    }\n\n  questionTxt = null;\n  answers = null;\n  difficulty = null;\n   used = null;\n\n   function getQuestionForScene()\n   {\n       local result = [];\n      local temp = [];\n    local rdmIndex = 0;\n\n       result.push(questionTxt);\n       used = true;\n\n      for(local i = 0;i < answers.len();i++)\n      {\n          temp.push(answers[i]);\n      }\n\n     while(temp.len() != 0)\n      {\n          rdmIndex = random_int(0,(temp.len()-1));\n       result.push(temp[rdmIndex].answerTxt);\n         temp.remove(rdmIndex);\n      }\n\n     return result;\n   }\n\n  function answerSelected(answerText)\n  {\n       for(local i = 0;i < answers.len();i++)\n      {\n          if(answers[i].answerTxt == answerText)\n         {\n             return answers[i].isCorrect;\n       }\n       }\n\n     return false;\n    }\n}\n\nclass Answer\n{\n  constructor(stringTxt,dataAnswer)\n    {\n       answerTxt = stringTxt.slice(2,stringTxt.len());\n     isCorrect = dataAnswer;\n  }\n\n  answerTxt = null;\n    isCorrect = null;\n}\n\nfunction animCallBack()\n{\n   dude.factor *= -1;\n}\n\nfunction init()\n{\n  bckGround = load_asset(1,false);\n move_asset(bckGround,width*0.5,height*0.5);\n\n    dude = FrameRateFreeAnimator();\n  dude.initGameObject(2,false);\n\n  hud = load_asset(9,false);\n   move_asset(hud,width*0.5,asset_get_height(hud)*0.5);\n\n   optA = load_asset(3,false);\n  move_asset(optA,width*0.5,height*0.5);\n\n optB = load_asset(4,false);\n  move_asset(optB,width*0.5,height*0.65);\n\n    optC = load_asset(5,false);\n  move_asset(optC,width*0.5,height*0.8);\n\n questionImg = load_asset(6,false);\n   move_asset(questionImg,width*0.5,height*0.3);\n\n  wonPopUpImg = load_asset(8,false);\n   move_asset(wonPopUpImg,width*0.5,height*0.5);\n\n  bannerImg = load_asset(7,false);\n move_asset(bannerImg,width*0.5,height - (asset_get_height(bannerImg)*0.5));\n\n    loseImg = load_asset(10,false);\n  move_asset(loseImg,width*0.5,height*0.5);\n add_click_area(\"A\",width*0.5,height*0.5,width,asset_get_height(optA)*0.8,buttonPressed);\n   add_click_area(\"B\",width*0.5,height*0.65,width,asset_get_height(optB)*0.8,buttonPressed);\n  add_click_area(\"C\",width*0.5,height*0.8,width,asset_get_height(optC)*0.8,buttonPressed);\n\n dataManager = QuestionsManager();\n\n  dataManager.processData();\n\n  for(local i=0; i<5; i++) \n  {\n    img_level.push(load_asset(15+i, true));\n    move_asset(img_level[i], 360, 640);\n  }\n  for (local i = 0; i < 2; i++) \n  {\n    img_answer.push(load_asset(20+i, true));\n  }\n}\n\nfunction start_level(level_num)\n{\n   score = 0;\n   dataManager.numberOfQuestion = 0;\n   tries = 5;\n   continueCount = true;\n    clockCountStarted = false;\n   scorePos = width*0.15;\n   dude.moveObject(width*0.85,height+(asset_get_height(dude.asset)*0.5));\n   dude.setUp(animType.Y_MOVEMENT,-(asset_get_height(dude.asset)*0.65),animCallBack);\n\n generateQuestion();\n  previousTime = get_time();\n}\n\nfunction update()\n{\n    deltaTime = (get_time() - previousTime) * 0.002;\n dude.advanceAnimation();\n previousTime = get_time();\n}\n\nfunction draw()\n{\n  draw_asset(bckGround);\n  draw_asset(hud);\n  draw_asset(questionImg);\n  draw_asset(bannerImg);\n  draw_asset(optA);\n  draw_asset(optB);\n  draw_asset(optC);\n  dude.Draw();\n  draw_text(width*0.46,height*0.124,2.7,timeText);\n  draw_text(scorePos,height*0.025,2.8,score);\n  draw_text(width*0.105,height*0.065,1.6,\"Puntos\");\n  draw_text(width*0.77,height*0.025,2.8,dataManager.numberOfQuestion+\"/\"+dataManager.maxNumber);\n  draw_text(width*0.75,height*0.067,1.3,\"Preguntas\");\n\nswitch(jumpLinesOnText(opText))\n{\n    case(0):\n       draw_text_center2(width*0.5,height*0.272,textSize,opText,questionColor);\n    break;\n   case(1):\n       draw_text_center2(width*0.5,height*0.255,textSize,opText,questionColor);\n    break;\n   case(2):\n       draw_text_center2(width*0.5,height*0.242,textSize,opText,questionColor);\n    break;\n   case(3):\n       draw_text_center2(width*0.5,height*0.224,textSize,opText,questionColor);\n    break;\n   case(4):\n       draw_text_center2(width*0.5,height*0.21,textSize,opText,questionColor);\n break;\n   case(5):\n       draw_text_center2(width*0.5,height*0.195,textSize,opText,questionColor);\n    break;\n}\n    \n if(optAText.find(\"%%\") >= 0)\n   {\n       draw_text_center2(width*0.5,height*0.46,2,optAText,answerColor);\n }\n    else\n {\n       draw_text_center2(width*0.5,height*0.48,2,optAText,answerColor);\n }\n    if(optBText.find(\"%%\") >= 0)\n   {\n       draw_text_center2(width*0.5,height*0.61,2,optBText,answerColor);\n }\n    else\n {\n       draw_text_center2(width*0.5,height*0.63,2,optBText,answerColor);\n }\n    if(optCText.find(\"%%\") >= 0)\n   {\n       draw_text_center2(width*0.5,height*0.76,2,optCText,answerColor);\n }\n    else\n {\n       draw_text_center2(width*0.5,height*0.78,2,optCText,answerColor);\n }\n    foreach(val in img_answer) \n  {\n       if(flganswer) \n      {\n           draw_asset(val);\n    }\n    }\n\n  if(showLevelText)\n    {\n       levels();\n    }\n    if(showLoseText)\n {\n       draw_asset(loseImg);\n }\n    if(showWinText)\n  {\n       draw_asset(wonPopUpImg);\n    draw_text_center2(width*0.5,height*0.55,2,\"Ganaste!\",legendColor);\n }\n}\n\nfunction levels() \n{\n  switch(level) \n  {\n     case 1: \n       draw_asset(img_level[0]);\n          break;\n      case 2: \n       draw_asset(img_level[1]);\n          break;\n      case 3: \n       draw_asset(img_level[2]);\n          break;\n      case 4: \n       draw_asset(img_level[3]);\n          break;\n      default: \n          draw_asset(img_level[4]);\n          break;\n   }\n}\n\nfunction jumpLinesOnText(nText)\n{\n local result = 0;\n  for(local i = 0;i < nText.len()-1;i++)\n   {\n       if(nText[i] == 37 && nText[i+1] == 37)\n      {\n          result++;\n       }\n    }\n  return result;\n}\n\nfunction turnOffText()\n{\n   showLevelText = false;\n   showLoseText = false;\n    showWinText = false;\n}\n\nfunction generateQuestion()\n{\n  if(level == 6)\n  {\n    showWinText = true;\n    call_function_after_time(turnOffText,1000);\n    call_function_after_time(gameOver,1000);\n    return;\n  }\n  dataManager.getQuestionOfDifficulty(level);\n  local info = dataManager.getCurrentQuestion().getQuestionForScene();\n  opText = info[0];\n  optAText = info[1];\n  optBText = info[2];\n  optCText = info[3];\n  canAnswer = true;\n  flganswer = false;\n  time = 20;\n  timeText = \"20\";\n  dataManager.getCurrentQuestion();\n  dude.startAnim(0.4);\n  flganswer = false;\n  for(local i = 0; i < 2; i++) \n  {\n    move_asset(img_answer[i], -width, -height);\n  }\n  startClock();\n}\n\nfunction startClock()\n{\n timeText = floor(time);\n  timeFraction = 9;\n    continueCount = true;\n\n  if(!clockCountStarted)\n   {\n       clockCountStarted = true;\n       call_function_after_time(refreshClock,1000);\n }\n}\n\nfunction refreshClock()\n{\n  if(continueCount)\n  {\n    time--;\n    if(time < 10)\n    {\n      timeText = \"0\" + floor(time);\n    }\n    else\n    {\n      timeText = floor(time);\n    }\n    timeText = timeText;\n    if(time <= 0)\n    {\n      timeText = \"00\";\n      tries--;\n      if(dataManager.questionAnswered(\"\"))\n      {\n        generateQuestion();\n      }\n      else\n      {\n        continueCount = false;\n        play_effect(3);\n        call_function_after_time(gameOver,1000);\n      }\n    }\n  }\n  call_function_after_time(refreshClock,1000);\n}\n\nfunction buttonPressed(pos_x, pos_y, name)\n{\n  if(canAnswer)\n  {\n    continueCount = false;\n    canAnswer = false;\n    flganswer = true;\n    switch(name)\n    {\n      case(\"A\"):\n      {\n        answerQuestion(optAText,height*0.5);\n      }\n      break;\n      case(\"B\"):\n      {\n        answerQuestion(optBText,height*0.65);\n      }\n      break;\n      case(\"C\"):\n      {\n        answerQuestion(optCText,height*0.8);\n      }\n      break;\n      }\n    }\n  if(score < 100)\n  {\n     scorePos = width*0.13;\n  }\n  else\n  {\n     scorePos = width*0.1;\n  }\n  dude.startAnim(-1);\n}\n\nfunction answerQuestion(optionText,optionPos)\n{\n  if(dataManager.questionAnswered(optionText))\n  {\n    call_function_after_time(generateQuestion, 600);\n    move_asset(img_answer[0],width*0.8,optionPos);\n    play_effect(1);\n  }\n  else\n  {\n    call_function_after_time(gameOver,1000);\n    move_asset(img_answer[1],width*0.8,optionPos);\n    play_effect(2);\n  }\n}\n\nfunction gameOver() \n{\n    save_highscore_gameover(score);\n\n    dataManager.resetManager();\n\n    dude.moveObject(width*0.85,height+(asset_get_height(dude.asset)*0.5));\n   dude.setUp(animType.Y_MOVEMENT,-(asset_get_height(dude.asset)*0.65),animCallBack);\n\n goto_menu_after_ms(\"gameOver\",2000);\n}"
  }, {
    "name": "Patos",
    "projectID": 1312,
    "gameID": 1312,
    "script": "local fondo;\nlocal header;\nlocal header2;\nlocal header3;\nlocal explosion;\nlocal explosionShape;\nlocal levelImg;\n\nlocal width = 720;\nlocal height = 1280;\nlocal fMensaje = false;\n\nlocal bandada = [];\nlocal textScore = [];\nlocal textpos = [];\nlocal kiwi = [];\nlocal kiwibear = [];\nlocal patoMuerto;\nlocal kiwiExplosion;\nlocal osoExplosion;\nlocal score;\nlocal shots;\nlocal time;\nlocal plusPatos;\nlocal level;\nlocal sight = true;\n\nlocal gameStarted = false;\nlocal callErraser = true;\n\nlocal spawnManager;\nlocal losePopUp;\nlocal showLose = false;\n\nlocal deltaTime = 0;\nlocal previousTime = 0;\nlocal lives = 3;\n\nclass GameObject\n{\n    constructor(id)\n  {\n       ID = id;\n    position = vector_2();\n      position.x = -width;\n    position.y = -height;\n       scale = 0;\n      isFlying = false;\n       goingToTheRight = true;\n     onScene = false;\n }\n\n  ID = null;\n   position = null;\n isFlying = null;\n goingToTheRight = null;\n  asset = null;\n    collider = null;\n scale = null;\n    onScene = null;\n  spawner = null;\n\n    function destroy() \n   {\n        isFlying = false;\n        onScene = false;\n     position.x = -width;\n     position.y = -height;\n        spawnManager.releaseSpawner(spawner);\n        move_asset(asset,position.x,position.y);\n     if(collider != null)\n     {\n          phy_move_shape(collider, position.x, position.y);\n\n         }\n    }\n\n  function objectUpdate()\n  {\n       if(isFlying && !onScene)\n    {\n          if(position.x > (-(asset_get_width(asset))) && position.x < (width+(asset_get_width(asset))))\n          {\n             onScene = true;\n        }\n       }\n    }\n\n  function moveObject(posX,posY)\n   {\n       if(asset != null)\n       {\n          move_asset(asset,posX,posY);\n    }\n       if(collider != null)\n    {\n          phy_move_shape(collider,posX,posY);\n     }\n       position.x = posX;\n      position.y = posY;\n   }\n}\n\nenum animType\n{\n X_MOVEMENT,\n  Y_MOVEMENT,\n  X_Y_MOVEMENT\n};\nclass FrameRateFreeAnimator extends GameObject\n{\n  constructor(id)\n  {\n       base.constructor(id);\n       progress = 2;\n       isRuning = false;\n    }\n\n  duration = null;\n factor = null;\n   initPoint = null;\n    progress = null;\n aType = null;\n    onCompleteCalled = null;\n callBack = null;\n isRuning = null;\n\n   function advanceAnimation()\n  {\n       if(isRuning)\n    {\n          progress += deltaTime * duration;\n          if(progress < 1)\n       {\n             runAnim();\n         }\n          else if(!onCompleteCalled)\n         {\n             onCompleteCalled = true;\n          onComplete();\n          }\n       }\n    }\n\n  function runAnim()\n   {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         position.x += factor * (deltaTime * duration);\n      break;\n      case(animType.Y_MOVEMENT):\n         position.y += factor * (deltaTime * duration);\n      break;\n      case(animType.X_Y_MOVEMENT):\n       position.x += factor.x * (deltaTime * duration);\n       position.y += factor.y * (deltaTime * duration);\n    break;\n      }\n       moveObject(position.x,position.y);\n   }\n\n  function setUp(anmType,nFactor,cllBack)\n  {\n       callBack = cllBack;\n     aType = anmType;\n    if(anmType == animType.X_Y_MOVEMENT)\n    {\n          factor = vector_2();\n       factor.x = nFactor.x;\n          factor.y = nFactor.y;\n       }\n       else\n    {\n          factor = nFactor;\n       }\n    }\n\n  function startAnim(nDuration)\n    {\n       if(!isRuning)\n       {\n          isRuning = true;\n       setInit();\n         if(nDuration > 0)\n          {\n             duration = 1.0/nDuration;\n          }\n          progress = 0;\n          onCompleteCalled = false;\n       }\n    }\n\n  function stopAnimation(terminateAnim)\n    {\n       isRuning = false;\n       onCompleteCalled = false;\n       progress = 0;\n       if(terminateAnim)\n       {\n          adjustToAbsolute();\n     }\n    }\n\n  function setInit()\n   {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         initPoint = position.x;\n     break;\n      case(animType.Y_MOVEMENT):\n         initPoint = position.y;\n     break;\n      case(animType.X_Y_MOVEMENT):\n       initPoint = position;\n       break;\n      }\n    }\n\n  function onComplete()\n    {\n       adjustToAbsolute();\n     if(callBack != null)\n    {\n          callBack();\n     }\n       isRuning = false;\n    }\n\n  function adjustToAbsolute()\n  {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         position.x = initPoint + factor;\n    break;\n      case(animType.Y_MOVEMENT):\n         position.y = initPoint + factor;\n    break;\n      case(animType.X_Y_MOVEMENT):\n       position.x = initPoint.x + factor.x;\n       position.y = initPoint.y + factor.y;\n    break;\n      }\n       moveObject(position.x,position.y);\n   }\n}\n\nclass MasterK extends FrameRateFreeAnimator \n{\n  constructor(id) \n {\n       base.constructor(id);\n\n     asset = load_asset(7+ID, false);\n\n      scale = random_int(5,7)*0.1;\n }\n\n  function showKiwi() \n {\n       local rdn = 0;\n      local scaleX = 0;\n       local rnd = 0;\n\n    if(!isFlying) \n      {\n          isFlying = true;\n       rdn = random_int(0, 1);\n        goingToTheRight = (rdn == 0 ? false : true);\n       scale = random_int(5,7)*0.1;\n       spawner = spawnManager.getSpawner(goingToTheRight);\n        moveObject(spawner.position.x,spawner.position.y);\n         scaleX = (goingToTheRight ? -scale : scale);\n       asset_set_scale(asset, scaleX, scale);\n       if(collider != null)\n       {\n          phy_remove_shape(collider);\n       }\n         collider =  phy_create_rect_shape(-width*2,-height*2,167*scale,80*scale, false);\n       if(level == 3)\n         {\n             phy_shape_set_collision_type(collider, 4);\n         } \n         else \n          {\n             phy_shape_set_collision_type(collider, 6);\n         }\n          if(goingToTheRight)\n        {\n             setUp(animType.X_MOVEMENT,(width*1.2)-position.x,destroy);\n         }\n          else\n       {\n             setUp(animType.X_MOVEMENT,(-width*0.2)-position.x,destroy);\n        }\n          startAnim(1.5);\n     }\n    }\n\n  function destroy()\n   {\n       base.destroy();\n     stopAnimation(false);\n    }\n}\n\nclass Ducks extends FrameRateFreeAnimator\n{\n constructor(id) \n {\n       base.constructor(id);\n\n     vel = 0;\n\n      asset = load_asset(10+ID, false);\n    }\n\n  vel = null;\n\n    function duckToFly() \n    {\n       local scaleX = 0;\n\n     if(!isFlying) \n      {\n          isFlying = true;\n       levels();\n          spawner = spawnManager.getSpawner(goingToTheRight);\n        moveObject(spawner.position.x,spawner.position.y);\n         scale = random_int(5,10)*0.1;\n          scaleX = (goingToTheRight ? -scale : scale);\n       asset_set_scale(asset, scaleX, scale);\n       if(collider != null)\n       {\n          phy_remove_shape(collider);\n       }\n         collider =  phy_create_rect_shape(-width*2,-height*2,167*scale,80*scale, false);\n       phy_shape_set_collision_type(collider, 1);\n         if(goingToTheRight)\n        {\n             setUp(animType.X_MOVEMENT,(width*1.2)-position.x,destroy);\n         }\n          else\n       {\n             setUp(animType.X_MOVEMENT,(-width*0.2)-position.x,destroy);\n        }\n          startAnim(1.5 - vel);\n       }\n    }\n\n  function levels() \n   {\n       local rnd = 0;\n\n    switch(level) \n      {\n         case 1:\n           goingToTheRight = false;\n          vel = random_int(1,10)*0.05;\n          break;\n          case 2:\n           goingToTheRight  = true;\n          vel = random_int(1,10)*0.05;\n          break;\n         case 3:\n           rnd = random_int(0,1);\n            goingToTheRight = (rnd == 0 ? false : true);\n          vel = random_int(3,10)*0.05;\n          break;\n         case 4:\n           rnd = random_int(0,1);    \n          goingToTheRight = (rnd == 0 ? false : true);\n          vel = random_int(4,10)*0.05;\n          break;\n         default:\n          rnd = random_int(0,1);    \n          goingToTheRight = (rnd == 0 ? false : true);\n          vel = random_int(6,10)*0.05;\n       break; \n     }\n    }\n\n  function destroy()\n   {\n       base.destroy();\n     stopAnimation(false);\n    }\n}  \n\nclass SpawnPosition\n{\n constructor(posX,posY,goingToTheRight)\n   {\n       position = vector_2();\n      position.x = posX;\n      position.y = posY;\n\n    isFree = true;\n      isgoingToTheRightSize = goingToTheRight;\n }\n\n  position =  null;\n    isFree = null;\n   isgoingToTheRightSize = null;\n    spawnMirror = null;\n\n    function setMirror(spawner)\n  {\n       spawnMirror = spawner;\n   }\n}\n\nclass SpawnManager\n{\n    constructor(asset)\n   {\n       spawners = [];\n      spawnHeight = asset_get_height(asset);\n      spawnWidth = asset_get_width(asset);\n    probability = 10;\n\n     startSpawners();\n }\n\n  spawners = null;\n spawnHeight = null;\n  spawnWidth = null;\n   probability = null;\n  index = 0;\n\n function startSpawners()\n {\n       local posX = 0;\n     local posY = (height*0.2)+(spawnHeight*0.5);\n    local nextToScreen = true;\n\n    while(posY < (height*0.8))\n      {\n          if(nextToScreen)\n       {\n             posX = -spawnWidth;\n           nextToScreen = false;\n          }\n          else\n       {\n             posX = (-spawnWidth)*2;\n           nextToScreen = true;\n       }\n\n        createSpawnersAt(posX,posY);\n       createSpawnersAt((posX*4),(posY+spawnHeight*0.25));\n\n          posY += (spawnHeight*0.75);\n     }\n    }\n\n  function createSpawnersAt(posX,posY)\n {\n       local spawn1 = null;\n    local spawn2 = null;\n\n      spawners.push(SpawnPosition(posX,posY,true));\n       spawners.push(SpawnPosition(((-1*posX)+width),posY,false));\n     spawn1 = spawners[index];\n       index++;\n    spawn2 = spawners[index];\n       index++;\n    spawn1.setMirror(spawn2);\n       spawn2.setMirror(spawn1);\n    }\n\n  function getSpawner(goingToTheRightPos)\n  {\n       local index = 0;\n\n      for(local i = 0;i < spawners.len();i++)\n     {\n          if(goingToTheRightPos)\n         {\n             if(spawners[i].isFree && spawners[i].isgoingToTheRightSize)\n           {\n                if(runRandom())\n              {  \n                index = i;\n                  break;\n               }\n             }\n          }\n          else\n       {\n             if(spawners[i].isFree && !spawners[i].isgoingToTheRightSize)\n          {\n                if(runRandom())\n              {  \n                index = i;\n                  break;\n               }\n\n           }\n          }\n       }\n\n     spawners[index].isFree = false;\n     spawners[index].spawnMirror.isFree = false;\n     probability = 10;\n\n     return spawners[index];\n  }\n\n  function releaseSpawner(spawner)\n {\n       if(spawner != null)\n     {\n          spawner.isFree = true;\n         spawner.spawnMirror.isFree = true;\n      }\n    }\n\n  function runRandom()\n {\n       local rdm = random_int(0,100);\n\n    if((rdm+probability) > 70)\n      {\n          return true;\n    }\n       probability += 15;\n\n    return false;\n    }\n}\n\n\nfunction init() \n{\n    fondo = load_asset(1, false);\n    move_asset(fondo, width*0.5, height*0.5);\n    \n header = load_asset(2, false); \n  move_asset(header, width*0.5, height*0.88);\n  header2 = load_asset(3, false);\n  move_asset(header2, width*0.5, height*0.12);\n\n   levelImg = load_asset(4, false);\n\n   explosion = load_asset(6, false);\n    move_asset(explosion, -width*3, -height*3);\n  local _rnd = 0;\n\n    explosionShape = phy_create_shape_for_asset(explosion, true);\n    phy_move_shape(explosionShape, -width*3, -height*3);\n phy_shape_set_collision_type(explosionShape, 2);\n\n   kiwiExplosion = phy_create_shape_for_asset(explosion, true);\n phy_move_shape(kiwiExplosion, -width*3, -height*3);\n  phy_shape_set_collision_type(kiwiExplosion, 3);\n\n    osoExplosion = phy_create_shape_for_asset(explosion, true);\n  phy_move_shape(osoExplosion, -width*3, -height*3);\n   phy_shape_set_collision_type(osoExplosion, 5);\n\n losePopUp = load_asset(5,false);\n move_asset(losePopUp,width*0.5,height*0.5);\n\n    for(local i=0; i<12; i++) \n   {\n       _rnd = random_int(0, 2);\n    bandada.push(Ducks(_rnd));\n   }\n\n  for(local i=0; i<2; i++) \n    {\n       kiwibear.push(MasterK(1));    \n }\n\n  for(local i=0; i<2; i++) \n    {\n       kiwi.push(MasterK(0));\n   }\n\n  spawnManager = SpawnManager(bandada[0].asset);\n\n phy_create_collision_handler_begin(1, 2, bangPatito);\n    phy_create_collision_handler_begin(3, 4, ShootKiwi); \n    phy_create_collision_handler_begin(5, 6, shootBear);\n}\n\nfunction start_level(num_level) \n{\n   patoMuerto = 10;\n score = 0;\n   shots = 0;\n   time = 50;\nlives = 3;\n   plusPatos = 0;\n   level = 1;\n   fMensaje = true;\n gameStarted = false;\n showLose = false;\n    previousTime = get_time();\n\n call_function_after_time(positionatedDucks, 2000);\n   call_function_after_time(borrarMensaje, 800);\n    call_function_after_time(clockTime, 2000);\n}\n\nfunction update() \n{\n   deltaTime = (get_time() - previousTime) * 0.001;   \n if(!fMensaje)\n    {\n       if(level == 3)\n      {\n          foreach(val in kiwi) \n          {\n             val.advanceAnimation();\n           val.objectUpdate();\n        } \n      } \n      else if(level == 4)\n     {\n          foreach(val in kiwibear)   \n       {\n             val.advanceAnimation();\n           val.objectUpdate();\n        }\n          foreach(val in kiwi) \n          {\n             val.advanceAnimation();\n           val.objectUpdate();\n        }\n       }\n       foreach(val in bandada)    \n    {\n          val.advanceAnimation();\n        val.objectUpdate();\n     }\n    }\n    if(patoMuerto <= 0 && gameStarted)\n   {\n       checkLevels();\n      gameStarted = false;\n }\n    previousTime = get_time();\n}\n\nfunction draw() \n{\n draw_asset(fondo);\n   draw_asset(header);\n  draw_asset(header2);\n draw_asset(explosion);\n   \n foreach(val in bandada) \n {\n       if(val.isFlying)   \n    {\n          draw_asset(val.asset)\n       }\n    }\n\n  foreach(val in kiwi) \n    {\n       if(val.isFlying) \n       {\n          draw_asset(val.asset);\n      }\n\n  }\n\n  foreach(val in kiwibear) \n    {\n       if(val.isFlying) \n       {\n          draw_asset(val.asset);\n      }\n    }\n\n  for(local i=0; i < textScore.len(); i++) \n    {\n       draw_text(textpos[i].x, textpos[i].y, 2, textScore[i]);\n  }\n\n  if(showLose)\n {\n       draw_asset(losePopUp);\n   }\n\n  mostrarMensaje();\n    local position;\n  position = (score >= 100)? width*0.75: width*0.78;\n   draw_text(position, height*0.91, 2, score);\n  \n draw_text(width*0.78, height*0.05, 2, patoMuerto);\n   draw_text(width*0.156, height*0.05, 2, time);\n    draw_text(width*0.156, height*0.91, 2, lives);\n}\n\nfunction quitarpatos() \n{\n for(local i = 0; i < bandada.len(); i++) \n    {\n       bandada[i].destroy();\n    }\n}\n\nfunction checkLevels() \n{\n   level++;\n  play_effect(3);\n fMensaje = true;\n plusPatos += 5;\n  patoMuerto += (10 + plusPatos);\n  time = (level == 4 ? 15 : 50-(plusPatos*2));\n sight = false;\n   quitarpatos();\n   call_function_after_time(positionatedDucks, 2000);\n}\n\nfunction mostrarMensaje() \n{\n   if(fMensaje) \n    {\n       draw_asset(levelImg);\n       move_asset(levelImg, width*0.5, height*0.5);\n    draw_text(width*0.438, height*0.47, 8, level);\n      if(callErraser)\n     {\n          callErraser = false;\n       call_function_after_time(borrarMensaje, 1500);\n      }\n    }\n}\n\nfunction borrarMensaje() \n{\n gameStarted = true;\n  fMensaje = false;\n    sight = true;\n    callErraser = true;\n}\n\nfunction clockTime() \n{\n   time--;\n  if(time == 0)\n    {\n       gameOver();\n  }\n    else\n {\n       call_function_after_time(clockTime, 1000);\n   }\n}\n\n\nfunction positionatedDucks() \n{\n   local _rdn = 0;\n  if(fMensaje || !gameStarted)\n {\n       return;\n  }\n\n  foreach(val in bandada) \n {\n       _rdn = random_int(0, 5);\n    if(_rdn == 0) \n      {\n          val.duckToFly();\n    }\n    }\n\n  if(level == 3)\n   {\n       foreach(val in kiwi) {\n         val.showKiwi();\n     }\n    } \n   if(level == 4)\n   {\n       foreach(val in kiwibear) {\n         val.showKiwi();\n     }\n    }\n\n  call_function_after_time(positionatedDucks, 500);\n}\n\n\nfunction touch_start(pos_x, pos_y)\n{\n  try {\n       phy_move_shape(explosionShape, pos_x, pos_y);\n       phy_move_shape(kiwiExplosion, pos_x, pos_y);\n    phy_move_shape(osoExplosion, pos_x, pos_y);\n     move_asset(explosion, pos_x, pos_y);\n\n      call_function_after_time(removeExplotion, 300);\n  } catch(exception) {\n    print(\"algo anda mal \" + exception);    \n }\n}\n\nfunction removeExplotion() \n{\n  phy_move_shape(explosionShape, -width*3, -height*3);\n  phy_move_shape(osoExplosion, -width*3, -height*3);\n  phy_move_shape(kiwiExplosion, -width*3, -height*3);\n  move_asset(explosion, -width*3, -height*3);\n}\n\nfunction ShootKiwi(shap1, shap2) \n{ \n  play_effect(2);\n gameOver();\n}\n\nfunction shootBear(shape_1, shape_2) \n{\n  play_effect(2);\n   gameOver();\n}\n\nfunction bangPatito(shape1, shape2) \n{\n  local temp = null;\n   local dPos = vector_2();\n shots++;\n patoMuerto--;\n\n  foreach (val in bandada) \n  {\n      if(val.collider != null) \n      {\n         if(compare_shapes(shape1, val.collider)) \n         {\n            temp = val;\n           break;\n         }\n          temp = val;\n     }\n    }\n  play_effect(1);\n  switch(temp.ID) {\n       case 0:\n        score = score + 20;\n        textScore.push(\"+20\");\n       break;\n      case 1:\n        score = score + 10;\n        textScore.push(\"+10\");\n       break;\n      case 2:\n        score = score + 15;\n        textScore.push(\"+15\");\n       break;\n   }\n    \n dPos.x = temp.position.x;\n    dPos.y = temp.position.y;\n    textpos.push(dPos);\n  temp.destroy();\n  call_function_after_time(removeTextScore, 300);\n}\n\nfunction removeTextScore() {\n   shots = 0;\n   textpos = [];\n    textScore = [];    \n}\n\nfunction gameOver() \n{\n  lives--;\n  lives = (lives<0) ? 0 : lives;\n  if(lives > 0 && time > 0)\n  {\n     return;\n  }\n  play_effect(4);\n  foreach(val in kiwi) \n  {\n     val.destroy();\n  }     \n  foreach(val in kiwibear) \n  {\n     val.destroy();\n  }\n\n  textScore = [];\n  textpos = [];\n  patoMuerto = 10;\n  shots =0;\n  level = 1;\n  showLose = true;\n\n  removeExplotion();\n\n  foreach(val in bandada) \n  {\n     val.destroy();\n  }\n  goto_menu_after_ms(\"gameover\",800);   \n}"
  }, {
    "name": "EsquivaAutos",
    "projectID": 1306,
    "gameID": 1306,
    "script": "local backGround = [];\nlocal backGroundHelper;\nlocal header;\nlocal player;\nlocal crash;\nlocal enemies = [];\nlocal powerUps = [];\nlocal arrowSpeed = [];\nlocal enemiesLine = [];\nlocal moveableObjects = [];\nlocal shield;\nlocal goal;\n\nlocal cont;\nlocal kind =0;\nlocal changeMatrix = false;\nlocal canMove = true; \nlocal movimiento = false;\n\n\nlocal width = 720;\nlocal height = 1280;\n\nlocal playerPos = 1;\nlocal plWidth = 0;\nlocal floorSpeed = 0;\nlocal enemySpeed = 0;\nlocal maxPattern = 8;\nlocal lifes = 10;\nlocal speedUp = 0;\nlocal arrowAng = 0;\nlocal totalMeter = 1660;\nlocal currentMeters = 0;\nlocal distanceIncrease = 0;\nlocal time = 0;\nlocal timeFraction = 0;\nlocal timeText = \"00.000\";\nlocal hasShield = false;\nlocal creating = false;\nlocal goalInSight = false;\nlocal gameOverFlag = false;\nlocal damagedFlg = false;\nlocal arrowPos = vector_2();\nlocal goalPos = vector_2();\nlocal playerColli;\nlocal playerCollPowerUps;\nlocal playerColliArrows;\nlocal enemiesColli= [];\nlocal highestPattrn = [0,3];\nlocal patterns = [[1,0,0,1,0],[0,1,0,1,0],[0,0,1,0,1],[0,0,1,1,0],[0,1,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,0,1],[1,0,0,1,0]];\n\nlocal deltaTime = 0;\nlocal previousTime = 0;\n\nclass GameObject\n{\n constructor()\n    {\n       position = vector_2();\n   }\n\n  asset = null;\n    shape = null;\n    position = null;\n\n   function initGameObject(id,withShape)\n    {\n       asset = load_asset(id,false);\n\n     if(withShape)\n       {\n          shape = phy_create_shape_for_asset(asset,false);\n    }\n    }\n\n  function moveObject(posX,posY)\n   {\n       if(asset != null)\n       {\n          move_asset(asset,posX,posY);\n    }\n       if(shape != null)\n       {\n          phy_move_shape(shape,posX,posY);\n    }\n       position.x = posX;\n      position.y = posY;\n   }\n\n  function readjustToPosition()\n    {\n       moveObject(position.x,position.y);\n   }\n\n  function Draw()\n  {\n       if(asset != null)\n       {\n          draw_asset(asset);\n      }\n    }\n}\n\nenum animType\n{\n X_MOVEMENT,\n  Y_MOVEMENT,\n  X_Y_MOVEMENT\n};\nclass FrameRateFreeAnimator extends GameObject\n{\n  constructor()\n    {\n       base.constructor();\n     progress = 2;\n       isRuning = false;\n    }\n\n  duration = null;\n factor = null;\n   initPoint = null;\n    progress = null;\n aType = null;\n    onCompleteCalled = null;\n callBack = null;\n isRuning = null;\n\n   function advanceAnimation()\n  {\n       if(isRuning)\n    {\n          progress += deltaTime * duration;\n\n        if(progress < 1)\n       {\n             runAnim();\n         }\n          else if(!onCompleteCalled)\n         {\n             onCompleteCalled = true;\n          onComplete();\n          }\n       }\n    }\n\n  function runAnim()\n   {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         position.x += factor * (deltaTime * duration);\n      break;\n      case(animType.Y_MOVEMENT):\n         position.y += factor * (deltaTime * duration);\n      break;\n      case(animType.X_Y_MOVEMENT):\n       position.x += factor.x * (deltaTime * duration);\n       position.y += factor.y * (deltaTime * duration);\n    break;\n      }\n       moveObject(position.x,position.y);\n   }\n\n  function setUp(anmType,nFactor,cllBack)\n  {\n       callBack = cllBack;\n     aType = anmType;\n    if(anmType == animType.X_Y_MOVEMENT)\n    {\n          factor = vector_2();\n       factor.x = nFactor.x;\n          factor.y = nFactor.y;\n       }\n       else\n    {\n          factor = nFactor;\n       }\n    }\n\n  function startAnim(nDuration)\n    {\n       if(!isRuning)\n       {\n          isRuning = true;\n       setInit();\n         if(nDuration > 0)\n          {\n             duration = 1.0/nDuration;\n          }\n          progress = 0;\n          onCompleteCalled = false;\n       }\n    }\n\n  function stopAnimation(terminateAnim)\n    {\n       isRuning = false;\n       onCompleteCalled = false;\n       progress = 0;\n       if(terminateAnim)\n       {\n          adjustToAbsolute();\n     }\n    }\n\n  function setInit()\n   {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         initPoint = position.x;\n     break;\n      case(animType.Y_MOVEMENT):\n         initPoint = position.y;\n     break;\n      case(animType.X_Y_MOVEMENT):\n       initPoint = position;\n       break;\n      }\n    }\n\n  function onComplete()\n    {\n       isRuning = false;\n       if(callBack != null)\n    {\n          callBack();\n     }\n    }\n\n  function adjustToAbsolute()\n  {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         position.x = initPoint + factor;\n    break;\n      case(animType.Y_MOVEMENT):\n         position.y = initPoint + factor;\n    break;\n      case(animType.X_Y_MOVEMENT):\n       position.x = initPoint.x + factor.x;\n       position.y = initPoint.y + factor.y;\n    break;\n      }\n       moveObject(position.x,position.y);\n   }\n}\n\nclass BackGround extends FrameRateFreeAnimator\n{\n    constructor()\n    {\n       base.constructor();\n\n       initGameObject(1,false);\n       need2Move = false;\n    }\n    need2Move = null;\n\n  function setUpAnim(initProgress)\n {\n       if(!isRuning)\n       {\n          setUp(animType.Y_MOVEMENT,height*2.05,restart);\n        startAnim(-1);\n         progress = initProgress;\n    }\n    }\n\n  function restart()\n   {\n       startAnim(-1);\n    }\n\n  function accelerateAnim()\n    {\n       duration *= 1.5;\n }\n\n  function deaccelerateAnim()\n  {\n       increaseLvl();\n   }\n\n  function increaseLvl()\n   {\n       duration = 1.0/(3 - floorSpeed);\n }\n}\n\nclass Enemy extends FrameRateFreeAnimator\n{\n constructor()\n    {\n       base.constructor();\n\n       initGameObject(5,true);\n\n       need2Move = false;\n\n    duration = 0.5;\n  }\n    need2Move = null;\n    completed = false;\n\n function setUpAnim()\n {\n       if(!isRuning)\n       {\n          setUp(animType.Y_MOVEMENT,height*1.8,animComplete);\n        startAnim(-1);\n      }\n    }\n\n  function animComplete()\n  {\n       need2Move = false;\n      completed = true;\n       moveObject(-width,-height);\n    }\n\n  function accelerateAnim()\n    {\n       duration *= 1.5;\n }\n\n  function deaccelerateAnim()\n  {\n       increaseLvl();\n   }\n\n  function increaseLvl()\n   {\n       duration = 1.0/(2 - enemySpeed);\n }\n}\n\nclass PowerUp extends FrameRateFreeAnimator\n{\n   constructor(assetId,id)\n  {\n       base.constructor();\n\n       initGameObject(assetId,true);\n\n     need2Move = false;\n      ID = id;\n\n      duration = 0.5;\n  }\n    need2Move = null;\n    ID = null;\n\n function setUpAnim()\n {\n       if(!isRuning)\n       {\n          setUp(animType.Y_MOVEMENT,height*1.8,animComplete);\n        startAnim(-1);\n      }\n    }\n\n  function animComplete()\n  {\n       need2Move = false;\n       moveObject(-width,-height);\n   }\n\n  function accelerateAnim()\n    {\n       duration *= 1.5;\n }\n\n  function deaccelerateAnim()\n  {\n       duration = 1.0/(2 - enemySpeed);\n }\n}\n\nfunction init()\n{\n   header = load_asset(2,false);\n    move_asset(header,width/2,height*0.08);\n\n    backGroundHelper = load_asset(1,false);\n    move_asset(backGroundHelper,width*0.5,height*0.5);\n\n    crash = load_asset(11,false);\n    move_asset(crash,-width,-height);\n    player = load_asset(4,false);\n    move_asset(player,width*0.15,height*0.85);\n   playerColli = phy_create_shape_for_asset(player, true);\n  phy_shape_set_collision_type(playerColli,1);\n playerCollPowerUps = phy_create_shape_for_asset(player,true);\n    phy_shape_set_collision_type(playerCollPowerUps,4);\n  playerColliArrows = phy_create_shape_for_asset(player, true);\n    phy_shape_set_collision_type(playerColliArrows, 5);\n\n    for (local i = 0;i < 4;i++)\n  {\n       backGround.push(BackGround());\n      moveableObjects.push(backGround[i]);\n    backGround[i].moveObject(width*0.5,height*2);\n    }\n    for(local i = 0;i < 7 ;i++)\n  {\n       enemies.push(Enemy());\n      moveableObjects.push(enemies[i]);\n       enemies[i].moveObject(-width,-height);\n      phy_shape_set_collision_type(enemies[i].shape,2);\n    }\n    for (local i = 0;i < 3;i++)\n  {\n       powerUps.push(PowerUp(6+i,i));\n      moveableObjects.push(powerUps[i]);\n      powerUps[i].moveObject(-width,-height);\n     if(i == 2)\n      {\n          phy_shape_set_collision_type(powerUps[i].shape,2);\n      }\n       else\n    {\n          phy_shape_set_collision_type(powerUps[i].shape,3);\n      }\n    }\n    for(local i=0; i<6; i++) \n    {\n       arrowSpeed.push(PowerUp(6,kind));\n       moveableObjects.push(arrowSpeed[i]);\n    arrowSpeed[i].moveObject(-width,-height);\n       phy_shape_set_collision_type(arrowSpeed[i].shape, 6);\n    }\n    for(local i=0; i<6; i++) \n    {\n       enemiesLine.push(Enemy());\n      moveableObjects.push(enemiesLine[i]);\n       enemiesLine[i].moveObject(-width,-height);\n      phy_shape_set_collision_type(enemiesLine[i].shape, 2);\n   }\n    shield = load_asset(9,false);\n    move_asset(shield,-width,-height);\n\n goal = load_asset(10,false);\n goalPos.x = width * 0.5;\n goalPos.y = -asset_get_height(goal);\n move_asset(goal,goalPos.x,goalPos.y);\n\n  phy_create_collision_handler_begin(1,2,enemyCrashed);\n    phy_create_collision_handler_begin(3,4,powerUPTaked);\n    phy_create_collision_handler_begin(5,6,arrowSpeedtaked);\n cont =1;\n}\n\nfunction start_level(level_num)\n{\n    cont = 1;\n    canMove = true; \n movimiento = false;\n  gameOverFlag = false;\n    playerPos = 3;\n   lifes = 10;\n   plWidth = ((width*0.19)*playerPos)-(asset_get_width(player)*0.5);\n    move_asset(player,plWidth,height*0.85);\n  phy_move_shape(playerColli,plWidth,height*0.85);\n phy_move_shape(playerCollPowerUps,plWidth,height*0.85);\n  phy_move_shape(playerColliArrows,plWidth, height*0.85);\n  reStartBG();\n createEnemies();\n creating = true;\n newClock();\n  previousTime = get_time();\n}\n\nfunction update()\n{     \n deltaTime = (get_time() - previousTime) * 0.002;\n moveBackGround();\n    if(changeMatrix) \n    {\n       change();\n       changeMatrix = false;\n    }\n    if(goalInSight)\n  {\n       for(local i = 0;i < 6;i++)\n      {\n          enemies[i].moveObject(-width,-height);\n         enemies[i].need2Move = false;\n       }\n       goalPos.y = goalPos.y + 10;\n     move_asset(goal,goalPos.x,goalPos.y);\n       if(goalPos.y > height)\n      {\n          gameOver();\n        goto_menu_after_ms(\"game\",50);\n    }\n    }\n    foreach (val in moveableObjects)\n {\n       if(val.need2Move)\n       {\n          val.advanceAnimation();\n        if(val.shape != null)\n          {\n             phy_shape_set_angle(val.shape,0);\n          }\n       }\n    }\n    previousTime = get_time();\n   evaluateEnemies();\n}\n\nfunction draw()\n{\n  draw_asset(backGroundHelper);\n  foreach (val in moveableObjects)\n {\n       draw_asset(val.asset);\n   }\n    draw_asset(goal);\n    if(hasShield)\n    {\n       draw_asset(shield);\n  }\n    else\n {\n       draw_asset(player);\n  }\n    draw_asset(header);\n  draw_asset(crash);\n   draw_text(width*0.16,height*0.05,2,lifes);\n   draw_text(width*0.78,height*0.05,1.5,timeText);\n  draw_text(width*0.48, height*0.04,2.5,cont);\n}\n\nfunction get_arrow_keys(key, state)\n{\n    if(gameOverFlag)\n {\n       return;\n  }\n    plWidth = asset_get_width(player) * 0.5;\n if(key == 0 && state == 0 && playerPos > 1)\n  {\n       playerPos--;\n }\n    if(key == 1 && state == 0 && playerPos < 5)\n  {\n       playerPos++;\n }\n    if(state == 0)\n   {\n       plWidth = ((width*0.19)*playerPos)-plWidth;\n     move_asset(player,plWidth,height*0.85);\n     phy_move_shape(playerColli,plWidth,height*0.85 );\n       phy_move_shape(playerCollPowerUps,plWidth,height*0.85);\n     phy_move_shape(playerColliArrows, plWidth, height*0.85);\n    if(hasShield)\n       {\n          move_asset(shield,plWidth,height*0.85);\n     }\n    }\n}\n\nfunction on_accelerometer_update(x,y,z)\n{\n   if((x >= -0.1 && x <= 0.1) || (y >= -0.1 && y <= 0.1) || (z >= -0.1 && z <= 0.1))\n    {\n       return;\n  }  \n\n   local widthass = asset_get_width(player)*0.5;\n    \n if(x > 1 && playerPos < 5 && canMove)\n    {\n       movimiento = true;\n      canMove = false;\n    playerPos++;\n }\n    if(x < -1 && playerPos > 1 && canMove)\n   {\n       movimiento = true;\n      canMove = false;\n    playerPos--;\n }\n  \n    widthass = ((width*0.19)*playerPos)-widthass;\n    move_asset(player,widthass, height*0.85);\n    if(hasShield)\n    {\n       move_asset(shield,widthass,height*0.85);\n }\n    phy_move_shape(playerColli, widthass,height*0.85);\n   phy_move_shape(playerCollPowerUps, widthass,height*0.85);\n    phy_move_shape(playerColliArrows, widthass, height*0.85);\n\n  if(movimiento) \n  {\n       movimiento = false;\n     call_function_after_time(moverse, 200);\n  }  \n}\n\nfunction moverse() \n{\n    canMove = true;\n}\n\nfunction touch_start(x, y) \n{\n if(x > 0 && x <360)\n  {\n       if(playerPos > 1) \n      {\n          playerPos--;\n    }\n    }\n    else if( x >= 361 && x <720) \n    {\n       if(playerPos < 5)  \n    {\n          playerPos++;\n    }\n    }\n    local widthass = 38.5;\n   plWidth = ((width*0.19)*playerPos)-widthass;\n move_asset(player,plWidth,height*0.85);\n  phy_move_shape(playerColli,plWidth,height*0.85);\n phy_move_shape(playerCollPowerUps,plWidth,height*0.85);\n  phy_move_shape(playerColliArrows,plWidth, height*0.85);\n  if(hasShield)\n    {\n       move_asset(shield,plWidth,height*0.85);\n  }\n}\n\nfunction arrowSpeedtaked(shape_1,shape_2)\n{\n local temp = null;\n   foreach(val in arrowSpeed) \n  {\n       temp = val;\n  }\n    if(temp.ID == 0) \n    { \n      increaseSpeed(); \n       speedUp++; \n     call_function_after_time(haveToDecrease,3000);\n   }\n}\n\nfunction powerUPTaked(shape_1,shape_2) \n{\n   local temp = null;\n   foreach (val in powerUps)\n    {\n       if(compare_shapes(shape_1,val.shape))\n       {\n          temp = val;\n        break;\n      }\n    }\n    if(temp.ID == 0)\n {\n       increaseSpeed();\n    speedUp++;\n      call_function_after_time(haveToDecrease,3000);\n   }\n    else if(temp.ID == 1)\n    {\n       temp.moveObject(temp.position.x,-height);\n       temp.need2Move = false;\n     if(!hasShield)\n      {\n          move_asset(shield,plWidth,height*0.85);\n        hasShield = true;\n        play_effect(2);\n       }\n    }\n    else if(temp.ID == 2)\n    {\n       lifes--;\n    damaged();\n   }\n}\n\nfunction enemyCrashed(shape_1,shape_2) \n{\n   if(hasShield)\n    {\n       move_asset(shield,-width,-height);\n      hasShield = false;\n   }\n    else\n {\n       damaged();\n      lifes--;\n    if(lifes == 0)\n      {\n          gameOver();\n     }\n    }\n}\n\nfunction increaseSpeed()\n{\n  if(speedUp < 2)\n  {\n       for(local i = 0;i < moveableObjects.len();i++)\n      {\n          moveableObjects[i].accelerateAnim();\n    }\n    }\n}\n\nfunction haveToDecrease()\n{\n speedUp--;\n   if(speedUp == 0)\n {\n       for(local i = 0;i < moveableObjects.len();i++)\n      {\n          moveableObjects[i].deaccelerateAnim();\n      }\n    }\n}\n\nfunction moveBackGround()\n{\n for(local i = 0;i < backGround.len();i++)\n   {\n       backGround[i].advanceAnimation();\n      if(backGround[i].position.y >= height*1.49)\n    {\n          backGround[i].moveObject(backGround[i].position.x,(getBackgroundsLowestPosition())-(height*0.95));\n    }\n    }\n}\n\nfunction reStartBG()\n{\n  local yInitPos = height * 0.5;\n   for(local i = 0;i < backGround.len();i++)\n   {\n       backGround[i].moveObject(width*0.5,yInitPos);\n      backGround[i].duration = 1.0/3;\n       yInitPos -= height;\n     if(i > 0)\n       {\n          backGround[i].setUpAnim(0);\n    }\n    }\n    backGround[0].setUpAnim(0.5);\n}\n\nfunction getBackgroundsLowestPosition()\n{\n   local pos = height;\n  for(local i = 0;i < backGround.len();i++)\n   {\n       if(backGround[i].position.y < pos)\n     {\n          pos = backGround[i].position.y;\n    }\n    }\n    return pos;\n}\n\nfunction createEnemies()\n{\n  local al = random_int(0, 10);\n    if(cont == 2) \n   {\n       if(al == 0)\n     {\n          arrowVel();\n     } \n   } \n   else if(cont == 3) \n  {\n       if(al == 5)\n     {\n          rowEnemies();\n       }\n    } \n   else if(cont == 4) \n  {\n       for(local i=0; i<5; i++) \n       {\n          enemiesLine[i].moveObject(-width,-height);\n         enemiesLine[i].need2Move = false;\n       }\n    }\n    call_function_after_time(randEnemies,450);\n}\n\nfunction randEnemies() \n{\n  local rdm = random_int(0,maxPattern);\n    local selected = patterns[rdm];\n  local enemyHeight = asset_get_height(enemies[0].asset);\n  local enemyWidth = asset_get_width(enemies[0].asset)*0.5;\n    local lowest = 1000;\n local minIndex = 0;\n  local posIndex = 0;\n\n    if(enemies[0].position.y >= 0)\n   {\n       minIndex = 3;\n    posIndex = 1;\n }\n    else\n {\n       minIndex = 0;\n    posIndex = 0;\n }\n    for(local i = 0;i < 5;i++)\n   {\n       if(selected[i] == 1)\n    {\n     enemies[minIndex].position.x = ((width*0.19)*(i+1))-enemyWidth;\n     enemies[minIndex].position.y = random_int(0,height*0.7);\n\n      enemies[minIndex].moveObject(enemies[minIndex].position.x,-enemies[minIndex].position.y);\n       enemies[minIndex].need2Move = true;\n     enemies[minIndex].setUpAnim();\n         if(enemies[minIndex].position.y < lowest)\n          {\n             lowest = enemies[minIndex].position.y;\n            highestPattrn[posIndex] = minIndex;\n        }\n          minIndex++;\n     }\n       else if(selected[i] == 0)\n       {\n          generatePowerUp(((width*0.19)*(i+1))-enemyWidth,enemyHeight);\n       }\n    }\n    creating = false;\n}\n\nfunction arrowVel() \n{\n  local minIndex = 0;\n  local widthl = 38.5;\n local enemyHeight = asset_get_height(arrowSpeed[minIndex].asset);\n    local enemyWidth = widthl;\n   local _rdm = random_int(0, 2);\n   for(local i=0; i<5; i++) \n    {\n       arrowSpeed[minIndex].position.x = ((width*0.19)*(i+1))-enemyWidth;\n      arrowSpeed[minIndex].position.y = random_int(_rdm-(enemyHeight*2),_rdm-enemyHeight);\n\n      arrowSpeed[minIndex].moveObject(arrowSpeed[minIndex].position.x,arrowSpeed[minIndex].position.y);\n       arrowSpeed[minIndex].need2Move = true;\n      arrowSpeed[minIndex].setUpAnim();\n       minIndex++;\n  }\n}\n\nfunction rowEnemies() \n{\n    local enemyHeight = asset_get_height(enemiesLine[0].asset);\n  local enemyWidth = asset_get_width(enemiesLine[0].asset)*0.5;\n    local minIndex=0;\n    local _rdm = random_int(0, 2);\n   for(local i=0; i<5; i++) \n    {\n       enemiesLine[minIndex].position.x = ((width*0.19)*(i+1))-enemyWidth;\n     enemiesLine[minIndex].position.y = random_int(_rdm-(enemyHeight*2),_rdm-enemyHeight);\n\n     enemiesLine[minIndex].moveObject(enemiesLine[minIndex].position.x,enemiesLine[minIndex].position.y);\n    enemiesLine[minIndex].need2Move = true;\n     enemiesLine[minIndex].setUpAnim();\n      minIndex++;\n  }\n    if(cont == 4) \n   {\n       for(local i=0; i<5; i++)\n    {\n          enemiesLine.moveObject(-width,-height);\n        enemiesLine[i].need2Move = false;\n       }\n    }\n}\n\nfunction evaluateEnemies()\n{\n    local isBusy = false;\n    for(local i = 0;i < enemies.len();i++)\n   {\n       if(enemies[i].isRuning)\n     {\n          isBusy = true;\n      }\n    }\n    if(!isBusy && !creating && !goalInSight)\n {\n       createEnemies();\n    creating = true;\n }\n}\n\nfunction generatePowerUp(intWidth,intHeight)\n{\n  local rdm14 = random_int(0,2);\n   local rdm2 = random_int(1,2);\n    local rdm5 = random_int(0, 1);\n\n switch(cont) \n    {\n    case 1:\n     if(!powerUps[rdm14].isRuning)\n       {\n          powerUps[rdm14].moveObject(intWidth,-random_int(0,height*0.7));\n        powerUps[rdm14].need2Move = true;\n          powerUps[rdm14].setUpAnim();\n    }\n       break;\n   case 2:\n     if(!powerUps[rdm2].isRuning)\n    {\n          powerUps[rdm2].moveObject(intWidth,-random_int(0,height*0.7));\n         powerUps[rdm2].need2Move = true;\n       powerUps[rdm2].setUpAnim();\n     }\n       break;\n   case 3:\n     if(!powerUps[rdm5].isRuning)\n    {\n          powerUps[rdm5].moveObject(intWidth,-random_int(0,height*0.7));\n         powerUps[rdm5].need2Move = true;\n       powerUps[rdm5].setUpAnim();\n     }\n       break;\n   case 4:\n     if(!powerUps[rdm5].isRuning)\n    {\n          powerUps[rdm5].moveObject(intWidth,-random_int(0,height*0.7));\n         powerUps[rdm5].need2Move = true;\n       powerUps[rdm5].setUpAnim();\n     }\n       break;\n   case 5:\n     if(!powerUps[rdm5].isRuning)\n    {\n          powerUps[rdm5].moveObject(intWidth,-random_int(0,height*0.7));\n         powerUps[rdm5].need2Move = true;\n       powerUps[rdm5].setUpAnim();\n     }\n       break;\n   }\n}\n\nfunction damaged()\n{\n  play_effect(1);\n    damagedFlg = true;\n   move_asset(crash,((width*0.19)*playerPos)-(asset_get_width(player)*0.5),height*0.8);\n call_function_after_time(removeCrash,200);\n}\n\nfunction change() \n{\n   local select;  \n for(local j=0; j<9; j++) \n    {\n       select = patterns[j];\n       for(local i=0 ; i<5; i++)\n       {\n          if(select[i] == 0)\n         {\n             select[i] = 1;\n         } \n         else  \n         {\n             select[i] = 0;\n         }\n       }\n       patterns[j] = select;\n    }\n}\n\nfunction removeCrash()\n{\n    damagedFlg = false;\n  move_asset(crash,-width,-height);\n}\n\nfunction restartGame()\n{\n  time = 0;\n    timeFraction = 0;\n    timeText = 0;\n    gameOverFlag = true;\n goalInSight = false;\n hasShield = false;\n   creating = false;\n    enemySpeed = 0;\n  currentMeters = 0;\n   speedUp = 0;\n damagedFlg = false;\n  goalPos.x = width * 0.5;\n goalPos.y = -asset_get_height(goal);\n move_asset(goal,goalPos.x,goalPos.y);\n    move_asset(crash,-width,-height);\n    move_asset(shield,-100,height*0.85);\n patterns = [[1,0,0,1,0],[0,1,0,1,0],[0,0,1,0,1],[0,0,1,1,0],[0,1,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,0,1],[1,0,0,1,0]];\n    for(local i = 0;i < enemies.len();i++)\n   {\n       enemies[i].moveObject(-width,-height);\n      enemies[i].need2Move = false;\n    enemies[i].isRuning = false;\n   }\n    for(local i = 0;i < powerUps.len();i++)\n  {\n       powerUps[i].moveObject(-width,-height);\n    powerUps[i].need2Move = false;\n   powerUps[i].isRuning = false;\n   }\n    for(local i=0; i< arrowSpeed.len();i++) \n {\n       arrowSpeed[i].moveObject(-width,-height);\n    arrowSpeed[i].need2Move = false;\n     arrowSpeed[i].isRuning = false;\n   }\n  for(local i=0; i< enemiesLine.len(); i++) \n    {\n       enemiesLine[i].moveObject(-width,-height);\n      enemiesLine[i].need2Move = false;\n      enemiesLine[i].isRuning = false;\n    }\n}\n\nfunction gameOver()\n{\n  play_effect(4);\n  cont = 1;\n    restartGame();\n   goto_menu_after_ms(\"gameOver\",1);\n}\n\nfunction newClock() \n{  \n time++;\n  if(time == 60) \n  {\n       time = 0;\n       timeFraction++;\n  } \n   if(time < 10) \n   {\n       timeText = \"0\" + timeFraction + \":0\" + time;\n } \n   else \n    {\n       timeText = \"0\" + timeFraction + \":\" + time;\n  }     \n if(timeText == \"00:30\")\n    {\n       increaseLevel();\n } \n   else if(timeText == \"01:00\")\n   {\n       increaseLevel();\n } \n   else if(timeText == \"01:30\")\n   {\n       changeMatrix = true;\n    increaseLevel();\n }\n    else if(timeText == \"02:00\")\n   {\n       increaseLevel();\n } \n   else if(timeText == \"02:30\")\n   {\n       goalInSight = true;\n  }\n    call_function_after_time(newClock, 1000);\n}\n\nfunction increaseLevel()\n{\n  play_effect(3);\n  floorSpeed += 0.2;\n   cont++;\n  enemySpeed += 0.3;\n   for(local i = 0;i < backGround.len();i++)\n    {\n       backGround[i].increaseLvl();\n }\n    for(local i = 0;i < enemies.len();i++)\n   {\n       enemies[i].increaseLvl();\n    }\n}"
  }, {
    "name": "TrepaKiwi",
    "projectID": 1304,
    "gameID": 1304,
    "script": "local width = 720;\nlocal height = 1280;\n\nlocal player;\nlocal inGameItem;\nlocal hud;\nlocal levelLabel;\nlocal backGrounds = [];\nlocal backGroundHelper;\nlocal walls = [];\nlocal staticwalls = [];\nlocal obstacles = [];\nlocal coins = [];\nlocal hudItems = [];\nlocal particles = [];\n\nlocal hardObstacles = false;\nlocal isGameRunning = true;\nlocal canSpawnItem = true;\nlocal canSpawnObstacles = true;\nlocal showLevel = false;\n\nlocal deltaTime = 0;\nlocal previousTime = 0;\nlocal coinsRows = 0;\nlocal score = 0;\nlocal itemLevel = 1;\n\nenum enemiesType\n{\n  SPIKES_BALL,\n BEAR\n};\n\nenum collisionsType\n{\n   NONE,\n    PLAYER,\n  OBSTACLE,\n    ITEMS,\n   COINS\n}\n\nenum itemsType\n{\n    ITEM_LEVEL_1_01,\n ITEM_LEVEL_1_02,\n ITEM_LEVEL_1_03,\n ITEM_LEVEL_2_01,\n ITEM_LEVEL_2_02,\n ITEM_LEVEL_2_03,\n ITEM_LEVEL_3_01,\n ITEM_LEVEL_3_02,\n ITEM_LEVEL_3_03\n}\n\nclass GameObject\n{\n    constructor()\n    {\n       position = vector_2();\n   }\n\n  asset = null;\n    shape = null;\n    position = null;\n\n   function initGameObject(id,withShape)\n    {\n       asset = load_asset(id,false);\n\n     if(withShape)\n       {\n          shape = phy_create_shape_for_asset(asset,false);\n    }\n    }\n\n  function moveObject(posX,posY)\n   {\n       if(asset != null)\n       {\n          move_asset(asset,posX,posY);\n    }\n       if(shape != null)\n       {\n          phy_move_shape(shape,posX,posY);\n    }\n       position.x = posX;\n      position.y = posY;\n   }\n\n  function readjustToPosition()\n    {\n       moveObject(position.x,position.y);\n   }\n\n  function Draw()\n  {\n       if(asset != null)\n       {\n          draw_asset(asset);\n      }\n    }\n}\n\nenum animType\n{\n X_MOVEMENT,\n  Y_MOVEMENT,\n  X_Y_MOVEMENT\n};\nclass FrameRateFreeAnimator extends GameObject\n{\n  constructor()\n    {\n       base.constructor();\n     progress = 2;\n       isRuning = false;\n    }\n\n  duration = null;\n factor = null;\n   initPoint = null;\n    progress = null;\n aType = null;\n    onCompleteCalled = null;\n callBack = null;\n isRuning = null;\n\n   function advanceAnimation()\n  {\n       if(isRuning)\n    {\n          progress += deltaTime * duration;\n\n        if(progress < 1)\n       {\n             runAnim();\n         }\n          else if(!onCompleteCalled)\n         {\n             onCompleteCalled = true;\n          onComplete();\n          }\n       }\n    }\n\n  function runAnim()\n   {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         position.x += factor * (deltaTime * duration);\n      break;\n      case(animType.Y_MOVEMENT):\n         position.y += factor * (deltaTime * duration);\n      break;\n      case(animType.X_Y_MOVEMENT):\n       position.x += factor.x * (deltaTime * duration);\n       position.y += factor.y * (deltaTime * duration);\n    break;\n      }\n       moveObject(position.x,position.y);\n   }\n\n  function setUp(anmType,nFactor,cllBack)\n  {\n       callBack = cllBack;\n     aType = anmType;\n    if(anmType == animType.X_Y_MOVEMENT)\n    {\n          factor = vector_2();\n       factor.x = nFactor.x;\n          factor.y = nFactor.y;\n       }\n       else\n    {\n          factor = nFactor;\n       }\n    }\n\n  function startAnim(nDuration)\n    {\n       if(!isRuning)\n       {\n          isRuning = true;\n       setInit();\n         if(nDuration > 0)\n          {\n             duration = 1.0/nDuration;\n          }\n          progress = 0;\n          onCompleteCalled = false;\n       }\n    }\n\n  function stopAnimation(terminateAnim)\n    {\n       isRuning = false;\n       onCompleteCalled = false;\n       progress = 0;\n       if(terminateAnim)\n       {\n          onComplete();\n       }\n    }\n\n  function setInit()\n   {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         initPoint = position.x;\n     break;\n      case(animType.Y_MOVEMENT):\n         initPoint = position.y;\n     break;\n      case(animType.X_Y_MOVEMENT):\n       initPoint = position;\n       break;\n      }\n    }\n\n  function onComplete()\n    {\n       isRuning = false;\n       if(callBack != null)\n    {\n          callBack();\n     }\n    }\n\n  function adjustToAbsolute()\n  {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         position.x = initPoint + factor;\n    break;\n      case(animType.Y_MOVEMENT):\n         position.y = initPoint + factor;\n    break;\n      case(animType.X_Y_MOVEMENT):\n       position.x = initPoint.x + factor.x;\n       position.y = initPoint.y + factor.y;\n    break;\n      }\n       moveObject(position.x,position.y);\n   }\n}\n\nclass BackGround extends FrameRateFreeAnimator\n{\n    constructor()\n    {\n       base.constructor();\n\n       initGameObject(100,false);\n   }\n\n  function setUpAnim(initProgress)\n {\n       if(!isRuning)\n       {\n          setUp(animType.Y_MOVEMENT,height*2,restart);\n       startAnim(-1);\n         progress = initProgress;\n    }\n    }\n\n  function restart()\n   {\n       startAnim(-1);\n   }\n}\n\nclass Wall extends FrameRateFreeAnimator\n{\n  constructor()\n    {\n       base.constructor();\n\n       initGameObject(901,false);\n\n    wallHeight = asset_get_height(asset);\n       wallWidth = asset_get_width(asset);\n  }\n    wallHeight = null;\n   wallWidth = null;\n\n  function setUpAnim()\n {\n       if(!isRuning)\n       {\n          setUp(animType.Y_MOVEMENT,height+wallHeight,restart);\n          startAnim(-1);\n      }\n    }\n\n  function restart()\n   {\n       startAnim(-1);\n   }  \n}\n\nclass Player extends FrameRateFreeAnimator\n{\n  constructor()\n  {\n    base.constructor();\n\n    particles = [];\n    isOnRightSide = false;\n    areFootsOnRight = false;\n    isInvincible = false;\n\n    normalAsset = load_asset(1,false);\n    asset = normalAsset;\n    moveObject(walls[0].wallWidth+(asset_get_width(asset)*0.5),height*0.9);\n    invincibleAsset = load_asset(2,true);\n\n    normalShape = phy_create_rect_shape(0,0,asset_get_width(normalAsset)*0.9,asset_get_height(normalAsset)*0.7,false);\n    shape = normalShape;\n    invincibleShape = phy_create_shape_for_asset(invincibleAsset,false);\n    phy_move_shape(normalShape,width*2,height*2);\n    phy_move_shape(invincibleShape,width*2,height*2);\n    phy_shape_set_collision_type(normalShape,collisionsType.PLAYER);\n    phy_shape_set_collision_type(invincibleShape,collisionsType.PLAYER);\n    setUpAnim();\n  }\n  isInvincible = null;\n  isOnRightSide = null;\n  areFootsOnRight = null;\n  invincibleTimer = null;\n  invincibleAsset = null;\n  normalAsset = null;\n  invincibleShape = null;\n  normalShape = null;\n  particles = null;\n  animFactor = null;\n  previousXPosition = null;\n\n function setUpAnim()\n {\n       if(!isRuning)\n       {\n          animFactor = width-(walls[0].wallWidth*1.5)-(asset_get_width(normalAsset));\n        setUp(animType.X_MOVEMENT,animFactor,completeCallback);\n        startAnim(0.5);\n     }\n    }\n\n  function completeCallback()\n  {\n       isOnRightSide = isOnRightSide == true ? false : true;\n    }\n\n  function changeSide()\n    {\n       factor = isOnRightSide ? -animFactor : animFactor;\n      startAnim(-1);\n   }\n\n  function adjustToSide()\n  {\n       if(isOnRightSide)\n       {\n          moveObject((width-walls[0].wallWidth)-(asset_get_width(asset)*0.5),height*0.9);\n     }\n       else\n    {\n          moveObject(walls[0].wallWidth+(asset_get_width(asset)*0.5),height*0.9);\n     }\n       if(position.x < (width*0.5))\n    {\n          if(isInvincible)\n       {\n             flip_asset(asset,true);\n        }\n          else\n       {\n             flip_asset(asset,false);\n       }\n       }\n       else if(position.x > (width*0.5))\n       {\n          if(isInvincible)\n       {\n             flip_asset(asset,false);\n       }\n          else\n       {\n             flip_asset(asset,true);\n        }\n       }\n    }\n\n  function onUpdate()\n  {\n    previousXPosition = position.x;\n    advanceAnimation();\n    assetFlipValidator();\n    local halfWidth = asset_get_width(asset)*0.5;\n    if((position.x-halfWidth) < walls[0].wallWidth)\n    {\n      position.x = walls[0].wallWidth + halfWidth;\n      readjustToPosition();\n    }\n    else if((position.x+halfWidth) > (width-walls[0].wallWidth))\n    {\n      position.x = (width-walls[0].wallWidth)-halfWidth;\n      readjustToPosition();\n    }\n    verifyPosition();\n  }\n\n  function assetFlipValidator()\n    {\n       if(position.x < (width*0.5) && areFootsOnRight)\n     {\n          areFootsOnRight = false;\n       if(isInvincible)\n       {\n             flip_asset(asset,true);\n        }\n          else\n       {\n             flip_asset(asset,false);\n       }\n       }\n       else if(position.x > (width*0.5) && !areFootsOnRight)\n       {\n          areFootsOnRight = true;\n        if(isInvincible)\n       {\n             flip_asset(asset,false);\n       }\n          else\n       {\n             flip_asset(asset,true);\n        }\n       }\n    }\n\n  function activateInvincibility()\n {\n       local posHelper = vector_2();\n       posHelper.x = position.x;\n       posHelper.y = position.y;\n       moveObject(width*2,height*2);\n       isInvincible = true;\n    asset = invincibleAsset;\n    shape = invincibleShape;\n    moveObject(posHelper.x,posHelper.y);\n }\n\n  function deactivateInvincibility()\n  {\n    moveObject(width*2,height*2);\n    isInvincible = false;\n    asset = normalAsset;\n    shape = normalShape;\n    adjustToSide();\n  }\n\n  function verifyPosition()\n  {\n    if(previousXPosition == position.x && !isInvincible )\n    {\n      if(previousXPosition != (width-walls[0].wallWidth)-(asset_get_width(asset)*0.5) &&\n      previousXPosition != walls[0].wallWidth+(asset_get_width(asset)*0.5))\n      {\n        if(isOnRightSide)\n        {\n          moveObject((width-walls[0].wallWidth)-(asset_get_width(asset)*0.5),height*0.9);\n        }\n        else\n        {\n          moveObject(walls[0].wallWidth+(asset_get_width(asset)*0.5),height*0.9);\n        }\n     }\n    }\n  }\n}\n\nclass Particles extends GameObject\n{\n    constructor()\n    {\n       base.constructor();\n\n       assetID = 0;\n    assets = [];\n    for(local i = 0;i < 3 ;i++)\n     {\n          assets.push(load_asset(701+i,false));\n       }\n    }\n    lifeTime = null;\n size = null;\n assetID = null;\n  assets = null;\n\n function spawnParticle()\n {\n       lifeTime = get_time() + random_int(300, 800);\n       chooseAsset();\n      setSize();\n      moveObject(player.position.x,player.position.y-(asset_get_height(player.asset)*0.5));\n    }\n    \n function setSize()\n   {\n       size = (random_int(3,6))/4.0;\n       scale_asset(asset,size,size);\n    }\n    \n function chooseAsset()\n   {\n       assetID = random_int(0,2);\n      asset = assets[assetID];\n }\n    \n function step()\n  {\n       if(lifeTime > get_time())\n       {\n          position.y += random_int(2, 5);\n     }     \n    else\n    {\n          local playerHalfHeight = asset_get_height(player.asset)*0.5;\n       local playerPos = player.position;\n         local initX = 0;\n    \n       lifeTime = get_time() + random_int(500, 1000);\n         position.y = playerPos.y + (asset_get_height(player.asset)*0.2);\n       chooseAsset();\n         setSize();\n         \n       if(!player.isOnRightSide)\n          {\n             initX = playerPos.x - playerHalfHeight;\n           position.x = random_int(initX,initX+20);\n       }\n          else\n       {\n             initX = playerPos.x + playerHalfHeight;\n           position.x = random_int(initX-20,initX);\n       }\n       }\n       readjustToPosition();     \n }\n    \n function Draw()\n  {\n       if(!player.isInvincible)\n    {\n          draw_asset(asset);\n      }\n    }\n}\n\nclass Obstacle extends FrameRateFreeAnimator\n{\n  constructor()\n    {\n       base.constructor();\n     onScene = false;\n    setUpAnim();\n }\n    onScene = null;\n  shapeHeight = null;\n\n    function  initGameObject(id)\n {\n       base.initGameObject(id,false);\n      shapeHeight = asset_get_height(asset)*0.8;\n      shape = phy_create_rect_shape(0,0,asset_get_width(asset)*0.7,asset_get_height(asset)*0.8,false);\n    phy_shape_set_collision_type(shape,collisionsType.OBSTACLE);\n    moveObject(-width,-height);\n  }\n\n  function setUpAnim()\n {\n       setUp(animType.Y_MOVEMENT,height*1.2,despawn);\n   }\n\n  function despawn()\n   {\n       onScene = false;\n    moveObject(-width,-height);\n  }\n\n  function spawnObstacle(posX)\n {\n       local rdm = random_int(0,10);\n       local nPos = posX;\n\n    if(nPos < 0)\n    {\n          if(rdm < 5)\n        {\n             nPos = (width-walls[0].wallWidth)-(asset_get_width(asset)*0.5);\n        }\n          else\n       {\n             nPos = walls[0].wallWidth+(asset_get_width(asset)*0.5);\n        }\n       }\n       moveObject(nPos,height*(-0.1));\n     onScene = true;\n     startAnim(2);\n    }\n\n  function Draw()\n  {\n       if(onScene)\n     {\n          draw_asset(asset);\n      }\n    }\n}\n\nclass Coin extends FrameRateFreeAnimator\n{\n  constructor()\n    {\n       base.constructor();\n     onScene = false;\n    setUpAnim();\n }\n    onScene = null;\n\n    function initCoin(id)\n    {\n       initGameObject(id,true);\n    phy_shape_set_collision_type(shape,collisionsType.COINS);\n       moveObject(-width,-height);\n  }\n\n  function setUpAnim()\n {\n       setUp(animType.Y_MOVEMENT,height*1.3,despawn);\n   }\n\n  function spawn(posX)\n {\n       onScene = true;\n     phy_shape_set_angle(shape,0);\n       moveObject(posX,-(asset_get_height(asset)));\n    startAnim(2.5);\n  }\n\n  function despawn()\n   {\n       onScene = false;\n    moveObject(-width,-height);\n  }\n\n  function Draw()\n  {\n       if(onScene)\n     {\n          draw_asset(asset);\n      }\n    }\n}\n\nclass Item extends FrameRateFreeAnimator\n{\n  constructor(hasAnim)\n {\n       base.constructor();\n     assets = [];\n    assetID = -1;\n       onScene = false;\n\n      itemInit();\n     if(hasAnim)\n     {\n          setUpAnim();\n    }\n    }\n    assets = null;\n   assetID = null;\n  direction = null;\n    onScene = null;\n\n    function itemInit()\n  {\n       for(local i = 0;i < 9;i++)\n      {\n          assets.push(load_asset(11+i,false));\n    }\n       asset = assets[0];\n   }\n\n  function setUpAnim()\n {\n       local nPos = setInitPos();\n      setUp(animType.X_Y_MOVEMENT,nPos,despawn);\n   }\n\n  function setInitPos()\n    {\n       local nPos = vector_2();\n    local initX = 0;\n    local direction = random_int(0,10);\n\n       nPos.y = position.y + (height*1.5);\n     if((direction%2) == 0)\n      {\n       nPos.x = -(position.x + (width*0.8));\n          initX = width;\n      }\n       else\n    {\n          nPos.x = position.x + width;\n       initX = 0;\n      }\n       moveObject(initX,0);\n    return nPos;\n }\n\n  function spawn()\n {\n       factor = setInitPos();\n      onScene = true;\n     selectAsset(-1,true);\n       startAnim(2);\n    }\n\n  function despawn()\n   {\n       moveObject(0,0);\n    onScene = false;\n }\n\n  function selectAsset(asstID,withShape)\n   {\n       if(asstID < 0)\n      {\n          assetID = random_int((3*(itemLevel-1)),(3*itemLevel)-1);\n    }\n       else\n    {\n          assetID = asstID;\n       }\n       asset = assets[assetID];\n    if(withShape)\n       {\n          if(shape != null)\n          {\n             phy_remove_shape(shape);\n       }\n          shape = phy_create_shape_for_asset(asset,false);\n       phy_shape_set_collision_type(shape,collisionsType.ITEMS);\n       }\n    }\n\n  function Draw()\n  {\n       if(onScene)\n     {\n          draw_asset(asset);\n      }\n    }\n}\n\nclass HUD extends GameObject\n{\n  constructor()\n    {\n       base.constructor();\n\n       initGameObject(3,false);\n    setAsset();\n  }\n\n  function setAsset()\n  {\n       asset = load_asset(3+(itemLevel-1),false);\n      moveObject(width*0.5,asset_get_height(asset)*0.5);\n   }\n\n  function markAsComplete(assetID)\n {\n       switch(assetID)\n     {\n       case(itemsType.ITEM_LEVEL_1_01):\n       setItem(0,width*0.115,assetID);\n          asset_set_scale(hudItems[0].asset,0.8,0.8);\n     break;\n      case(itemsType.ITEM_LEVEL_1_02):\n       setItem(2,width*0.435,assetID);\n         asset_set_scale(hudItems[2].asset,0.8,0.8);\n     break;\n      case(itemsType.ITEM_LEVEL_1_03):\n       setItemWithY(1,width*0.248,height*0.058,assetID);\n         rotate_asset(hudItems[1].asset,-25);\n       asset_set_scale(hudItems[1].asset,0.8,0.8);\n     break;\n      case(itemsType.ITEM_LEVEL_2_01):\n       setItem(0,width*0.115,assetID);\n          asset_set_scale(hudItems[0].asset,0.8,0.8);\n     break;\n      case(itemsType.ITEM_LEVEL_2_02):\n       setItem(1,width*0.435,assetID);\n         asset_set_scale(hudItems[1].asset,0.8,0.8);\n     break;\n      case(itemsType.ITEM_LEVEL_2_03):\n       setItemWithY(2,width*0.29,height*0.054,assetID);\n         asset_set_scale(hudItems[2].asset,0.8,0.8);\n     break;\n      case(itemsType.ITEM_LEVEL_3_01):\n       setItem(0,width*0.11,assetID);\n          asset_set_scale(hudItems[0].asset,0.8,0.8);\n     break;\n      case(itemsType.ITEM_LEVEL_3_02):\n       setItem(1,width*0.275,assetID);\n         asset_set_scale(hudItems[1].asset,0.82,0.82);\n     break;\n      case(itemsType.ITEM_LEVEL_3_03):\n       setItem(2,width*0.445,assetID);\n         asset_set_scale(hudItems[2].asset,0.8,0.8);\n     break;\n      }\n       call_function_after_time(evaluateLevel,700);\n }\n\n  function setItemWithY(index,posX,posY,assetID)\n {\nsetItem(index,posX,assetID);\n     hudItems[index].moveObject(posX,posY);\n    }\n\n  function setItem(index,posX,assetID)\n {\n       hudItems[index].selectAsset(assetID,false);\n     hudItems[index].onScene = true;\n     hudItems[index].moveObject(posX,height*0.05);\n    }\n\n  function clearHUD()\n  {\n       setAsset();\n     for(local i = 0;i < 3;i++)\n      {\n          hudItems[i].assetID = -1;\n          hudItems[i].onScene = false;\n       hudItems[i].moveObject(-width,-height);\n     }\n    }\n\n  function evaluateLevel()\n {\n       if(hudItems[0].onScene && hudItems[1].onScene && hudItems[2].onScene && itemLevel < 3)\n      {\n          itemLevel++;\n       clearHUD();\n        if(itemLevel == 4)\n         {\n             print(\"Gano-------------\");\n             gameOver();\n        }\n          else\n       {\n             showLevelUp();\n         }\n       }\n    }\n}\n\nfunction init()\n{\n   for (local i = 0;i < 4;i++)\n  {\n       backGrounds.push(BackGround());\n     backGrounds[i].moveObject(width*0.5,height*2);\n   }\nbackGroundHelper = BackGround();\nbackGroundHelper.moveObject(width*0.5,height*0.5);\n  for(local i = 0;i < 10;i++)\n  {\n    walls.push(Wall());\n    walls[i].moveObject(-width,-height);\n  }\n  for(local i = 0;i < 8;i++)\n  {\n    staticwalls.push(Wall());\n  }\n  player = Player();\n  hud = HUD();\n  levelLabel = GameObject();\n  levelLabel.initGameObject(200,false);\n  inGameItem = Item(true);\n  levelLabel.moveObject(width*0.5,height*0.5);\n  for(local i = 0;i < 8;i++)\n   {\n       obstacles.push(Obstacle());\n     if(i < 4)\n       {\n          obstacles[i].initGameObject(802);\n       }\n       else\n    {\n          obstacles[i].initGameObject(801);\n       }\n    }\n    for(local i = 0;i < 30;i++)\n  {\n       coins.push(Coin());\n     coins[i].initCoin(20);\n   }\n    for(local i = 0;i < 6;i++)\n   {\n       hudItems.push(Item(false));\n  }\n    for(local i = 0;i < 30;i++)\n  {\n       particles.push(Particles());\n }\n    phy_create_collision_handler_begin(collisionsType.PLAYER,collisionsType.OBSTACLE,obstacleCollision);\n phy_create_collision_handler_begin(collisionsType.PLAYER,collisionsType.COINS,coinTaken);\n    phy_create_collision_handler_begin(collisionsType.PLAYER,collisionsType.ITEMS,itemTaken);\n}\n\nfunction start_level(level_num)\n{\n    reStartBG();\n    restartStaticWalls();\n reStartWalls();\n  previousTime = get_time();\nhud.setAsset();\n for(local i = 0;i < particles.len();i++)\n {\n       particles[i].spawnParticle();\n    }\n   call_function_after_time(internalStart,500);\n}\n\nfunction internalStart()\n{\n   isGameRunning = true;\n    spawnItem();\n           player.adjustToSide();\n   call_function_after_time(createObstacle,4000);\n}\n\nfunction spawnItem()\n{\n  if(canSpawnItem)\n {\n       inGameItem.spawn();\n     call_function_after_time(spawnItem,3000);\n    }\n}\n\nfunction reStartBG()\n{\n  local yInitPos = height * 0.5;\n   for(local i = 0;i < backGrounds.len();i++)\n   {\n       backGrounds[i].moveObject(width*0.5,yInitPos);\n      backGrounds[i].duration = 1.0/10;\n       yInitPos -= height;\n     if(i > 0)\n       {\n          backGrounds[i].setUpAnim(0);\n    }\n    }\n    backGrounds[0].setUpAnim(0.5);\n}\n\nfunction restartStaticWalls()\n{\n  local yInitPos = -(walls[0].wallHeight*0.5);\n  for(local i = 0;i < staticwalls.len();i+=2)\n  {\n    staticwalls[i].moveObject(staticwalls[i].wallWidth*0.5,yInitPos);\n    staticwalls[i+1].moveObject(width-(staticwalls[i].wallWidth*0.5),yInitPos);\n    rotate_asset(staticwalls[i+1].asset,180);\n    yInitPos+= walls[0].wallHeight;\n  }\n}\n\nfunction reStartWalls()\n{\n  local yInitPos = -(walls[0].wallHeight*1.5);\n  for(local i = 0;i < walls.len();i+=2)\n  {\n    walls[i].moveObject(walls[i].wallWidth*0.5,yInitPos);\n    walls[i].duration = 1.0/2.5;\n    walls[i+1].moveObject(width-(walls[i].wallWidth*0.5),yInitPos);\n    walls[i+1].duration = 1.0/2.5;\n    rotate_asset(walls[i+1].asset,180);\n    walls[i].setUpAnim();\n    walls[i+1].setUpAnim();\n    yInitPos+= walls[0].wallHeight;\n  }\n}\n\nfunction update()\n{      \n deltaTime = (get_time() - previousTime) * 0.0017;\n if(isGameRunning)\n    {\n       moveBackGround();\n       moveWalls();\n    updateObstacles();\n      updateCoins();\n      player.onUpdate();\n      inGameItem.advanceAnimation();\n      for(local i = 0;i < particles.len();i++)\n    {\n          particles[i].step();\n    }\n    }\n    previousTime = get_time();\n}\n\nfunction updateObstacles()\n{\n   for(local i = 0;i < obstacles.len();i++)\n {\n       if(obstacles[i].onScene)\n    {\n          obstacles[i].advanceAnimation();\n    }\n    }\n}\n\nfunction updateCoins()\n{\n    for(local i = 0;i < coins.len();i++)\n {\n       if(coins[i].onScene)\n    {\n          coins[i].advanceAnimation();\n    }\n    }\n}\n\nfunction moveBackGround()\n{\n for(local i = 0;i < backGrounds.len();i++)\n   {\n       backGrounds[i].advanceAnimation();\n      if(backGrounds[i].position.y >= height*1.49)\n    {\n          backGrounds[i].moveObject(backGrounds[i].position.x,(getBackgroundsLowestPosition())-(height*0.95));\n    }\n    }\n}\n\nfunction getBackgroundsLowestPosition()\n{\n   local pos = height;\n  for(local i = 0;i < backGrounds.len();i++)\n   {\n       if(backGrounds[i].position.y < pos)\n     {\n          pos = backGrounds[i].position.y;\n    }\n    }\n    return pos;\n}\n\nfunction moveWalls()\n{\n    for(local i = 0;i < walls.len();i++)\n {\n       walls[i].advanceAnimation();\n    if(walls[i].position.y >= (height+(walls[0].wallHeight *0.45)))\n     {\n          walls[i].moveObject(walls[i].position.x,(getWallsLowestPosition())-(walls[0].wallHeight*0.4));\n         if((i%2) == 0)\n         {\n             score += 1;\n        }\n       }\n    }\n}\n\nfunction getWallsLowestPosition()\n{\n local pos = height;\n  for(local i = 0;i < walls.len();i++)\n {\n       if(walls[i].position.y < pos)\n       {\n          pos = walls[i].position.y;\n      }\n    }\n    return pos;\n}\n\nfunction draw()\n{\nbackGroundHelper.Draw();\n for(local i = 0;i < backGrounds.len();i++)\n   {\n       backGrounds[i].Draw();\n   }\n    for(local i = 0;i < staticwalls.len();i++)\n {\n       staticwalls[i].Draw();\n }\n    for(local i = 0;i < walls.len();i++)\n {\n       walls[i].Draw();\n }\n    player.Draw();\n   inGameItem.Draw();\n   for(local i = 0;i < obstacles.len();i++)\n {\n       obstacles[i].Draw();\n }\n    for(local i = 0;i < coins.len();i++)\n {\n       coins[i].Draw();\n }\n    for(local i = 0;i < particles.len();i++)\n {\n       particles[i].Draw();\n }\n    drawHUD();\n}\n\nfunction drawHUD()\n{\n   hud.Draw();\n  for(local i = 0;i < hudItems.len();i++)\n  {\n       hudItems[i].Draw();\n  }\n    draw_text(width*0.85,height*0.03,1.8,score);\n if(showLevel)\n    {\n       levelLabel.Draw();\n      draw_text(width*0.55,height*0.472,3,itemLevel);\n  }\n}\n\nfunction showLevelUp()\n{\n    showLevel = true;\n    play_effect(4);\n    call_function_after_time(removeShowLevel,1000);\n}\n\nfunction removeShowLevel()\n{\n  showLevel = false;\n}\n\nfunction touch_move(pos_x, pos_y)\n{\n    if(player.isInvincible)\n  {\n       player.moveObject(pos_x,player.position.y);\n  }\n}\n\nfunction touch_end(pos_x,pos_y)\n{\n   if(!player.isInvincible)\n {\n       if(player.isRuning)\n     {\n             player.stopAnimation(true);\n           player.adjustToSide();\n          player.changeSide();\n       }\n       else if(isGameRunning)\n    {\n          player.changeSide();\n    }\n    play_effect(1);\n  }\n}\n\nfunction createObstacle()\n{\n if(!isGameRunning || !canSpawnObstacles)\n {\n       return;\n  }\n\n  if(!hardObstacles)\n   {\n       spawnObstacleOfType(enemiesType.SPIKES_BALL,-1);\n    call_function_after_time(createObstacle,800);\n    }\n    else\n {\n       local rdm = random_int(1,3);\n    local nPos = -1;\n    switch(rdm)\n     {\n       case(1):\n       nPos = width * 0.3;\n     break;\n      case(2):\n       nPos = width * 0.5;\n     break;\n      case(3):\n       nPos = width * 0.7;\n     break;\n      }\n       spawnObstacleOfType(enemiesType.BEAR,nPos);\n     call_function_after_time(createObstacle,1000);\n   }\n}\n\nfunction spawnObstacleOfType(type,posX)\n{\n   local start = 0;\n local end = 0;\n\n if(type == enemiesType.SPIKES_BALL)\n  {\n       start = 0;\n      end = 4;\n }\n    else if(type == enemiesType.BEAR)\n    {\n       start = 4;\n      end = obstacles.len();\n   }\n    for(local i = start;i < end;i++)\n {\n       if(!obstacles[i].onScene)\n       {\n          obstacles[i].spawnObstacle(posX);\n          break;\n      }\n    }\n}\n\nfunction spawnCoinsWave()\n{\n if(coinsRows <= 0)\n   {\n       coinsRows = random_int(8,15);\n       spawnCoinsWave();\n    }\n    else\n {\n       coinsRows--;\n    if(coinsRows > 0)\n       {\n          spawnCoinsRow(10);\n         call_function_after_time(spawnCoinsWave,300);\n       }\n       else\n    {\n          call_function_after_time(onWaveComplete,2000);\n      }\n    }\n}\n\nfunction spawnCoinsRow(probability)\n{\n   local rdm = 0;\n   local spawnArea = (width -(walls[0].wallWidth*2));\n\n for(local i = 0;i < 5;i++)\n   {\n       rdm = random_int(0,probability);\n    if(rdm < 5)\n     {\n          spawnCoin(spawnArea*(0.2*(i+1))+(walls[0].wallWidth*0.45));\n     }\n    }\n}\n\nfunction spawnCoin(posX)\n{\n  for(local i = 0;i < coins.len();i++)\n {\n       if(!coins[i].onScene)\n       {\n          coins[i].spawn(posX);\n          break;\n      }\n    }\n}\n\nfunction onWaveComplete()\n{\n canSpawnObstacles = true;\n    canSpawnItem = true;\n hardObstacles = true;\n    createObstacle();\n    spawnItem();\n player.deactivateInvincibility();\n    call_function_after_time(deactivateHardObstacles,5000);\n}\n\nfunction deactivateHardObstacles()\n{\n  hardObstacles = false;\n}\n\nfunction obstacleCollision(shape_1,shape_2)\n{\n  local shp1Pos = phy_get_shape_position(shape_1);\n local shp2Pos = phy_get_shape_position(shape_2);\n local shpHeight = 0;\n local deathPos = 0;\n\n    for(local i = 0;i < obstacles.len();i++)\n {\n       if(compare_shapes(obstacles[i].shape,shape_2))\n      {\n          shpHeight = obstacles[i].shapeHeight;\n          break;\n      }\n    }\n    deathPos = shp2Pos.y - (shpHeight*0.5) + (shpHeight*0.65);\n\n if(shp1Pos.y >= deathPos)\n    {\n       gameOver();\n  }\n    else\n {\n       bouncePlayer();\n  }\n}\n\nfunction coinTaken(shape_1,shape_2)\n{\n   for(local i = 0;i < coins.len();i++)\n {\n       if(compare_shapes(shape_2,coins[i].shape))\n      {\n          coins[i].stopAnimation(true);\n          score += 5;\n          play_effect(5);\n        break;\n      }\n    }\n}\n\nfunction itemTaken(shape_1,shape_2)\n{\n   inGameItem.stopAnimation(true);\n  local count = 0;\n\n   score += getItemScore(inGameItem.assetID);\nplay_effect(2);\n   for(local i = 3;i < 6;i++)\n   {\n       count++;\n    if(!hudItems[i].onScene)\n    {\n          if(i == 3 || hudItems[i-1].assetID != inGameItem.assetID)\n          {\n             clearBottomHUD();\n             setBottomItem(3);\n             break;\n         }\n          else\n       {\n             count++;\n          setBottomItem(i);\n             break;\n         }\n       }\n    }\n    if(count == 4)\n   {\n       hud.markAsComplete(inGameItem.assetID);\n     removeObstacles();\n      clearBottomHUD();\n       canSpawnObstacles = false;\n      canSpawnItem = false;\n       spawnCoinsWave();\n       player.activateInvincibility();\n  }\n}\n\nfunction getItemScore(assetID)\n{\n    local result = 0;\n    switch(assetID)\n  {\n    case(itemsType.ITEM_LEVEL_1_01):\n    result = 1;\n  break;\n   case(itemsType.ITEM_LEVEL_1_02):\n    result = 3;\n  break;\n   case(itemsType.ITEM_LEVEL_1_03):\n    result = 2;\n  break;\n   case(itemsType.ITEM_LEVEL_2_01):\n    result = 1;\n  break;\n   case(itemsType.ITEM_LEVEL_2_02):\n    result = 3;\n  break;\n   case(itemsType.ITEM_LEVEL_2_03):\n    result = 2;\n  break;\n   case(itemsType.ITEM_LEVEL_3_01):\n    result = 1;\n  break;\n   case(itemsType.ITEM_LEVEL_3_02):\n    result = 2;\n  break;\n   case(itemsType.ITEM_LEVEL_3_03):\n    result = 3;\n  break;\n   }\n    return result;\n}\n\nfunction setBottomItem(index)\n{\n    hudItems[index].selectAsset(inGameItem.assetID,false);\n   hudItems[index].onScene = true;\n  hudItems[index].moveObject((width*0.25)*(index-2),height*0.95);\n}\n\nfunction clearBottomHUD()\n{\n   for(local i = 3;i < 6;i++)\n   {\n       hudItems[i].assetID = -1;\n       hudItems[i].onScene = false;\n    hudItems[i].moveObject(-width,-height);\n  }\n}\n\nfunction removeObstacles()\n{\n    for(local i = 0;i < obstacles.len();i++)\n {\n       if(obstacles[i].onScene)\n    {\n          obstacles[i].stopAnimation(true);\n       }\n    }\n}\n\nfunction bouncePlayer()\n{\n   player.stopAnimation(true);\n  player.changeSide();\n}\n\nfunction gameOver()\n{\n    isGameRunning = false;\nplay_effect(3);\n   call_function_after_time(resetGame,500);\n    goto_menu_after_ms(\"gameover\",600);\n}\n\nfunction resetGame()\n{\n    removeObstacles();\n   clearBottomHUD();\n    hud.clearHUD();\n  hardObstacles = false;\n   score = 0;\n   itemLevel = 1;\n   inGameItem.stopAnimation(true);\n  for(local i = 0;i < backGrounds.len();i++)\n   {\n       backGrounds[i].stopAnimation(false);\n }\n    for(local i = 0;i < walls.len();i++)\n {\n       walls[i].stopAnimation(false);\n   }\n}"
  }, {
    "name": "KiwiNinja",
    "projectID": 1315,
    "gameID": 1315,
    "script": "local img_background;\nlocal img_hud;\nlocal img_bomb;\nlocal img_timer_bomb;\nlocal img_bomb_effect;\nlocal img_timer_bomb_effect;\nlocal available_fruits = [];\nlocal img_fruits= [];\nlocal fruits= [];\nlocal particles= [];\nlocal spot_particles= [];\nlocal dedos= [];\nlocal bombs= [];\nlocal img_time = [];\nlocal hud_chance;\nlocal circles_chance = [];\nlocal circles_chance_off = [];\nlocal isLive;\nlocal Lifes;\nlocal time_game;\nlocal time_start_game;\nlocal timerfruit;\nlocal timerbomb;\nlocal lastdedo;\nlocal penultimodedo;\nlocal puntos;\nlocal cut;\nlocal speed_game;\nlocal min_time;\nlocal max_time;\nlocal min_time_bomb;\nlocal max_time_bomb;\nlocal angle;\nlocal timeDamage;\nlocal img_timer_bomb_effect_duration;\nlocal timerBombTime;\nlocal timerBombExploded;\nlocal cuadrant;\nlocal timeFlow;\nlocal specialFruit;\nlocal specialFruitIndex;\nlocal specialFruitCounter;\nlocal specialFruitTrigger;\nlocal stopTimeDuration;\nlocal sword;\nlocal hud_color;\nlocal hud_color_titles;\nlocal waitTime;\nlocal gameCountdown;\nlocal secondCountdown;\nlocal losingTimeCounter;\nlocal timeSize;\nlocal deltaTime;\nlocal goingUp;\nlocal timerBombProbability;\nlocal pointsLevel;\nlocal destroyedAll;\n\nlocal combo = 0;\nlocal timeElapsed = 0;\nlocal passed10 = false;\nlocal passed20 = false;\nlocal chance = false;\n\nlocal loseByTime;\nlocal loseByProducts;\n\nfunction init()\n{\n  img_background= load_asset(0,true);\n  move_asset(img_background,360,640);\n  img_hud= load_asset(1, true);\n    if(img_hud != null)\n  {\n       move_asset(img_hud, 360, 130);\n   }\n    cut= cut_data();\n cut.img= load_asset(2, true);\n    img_bomb= load_asset(3, true);\n   img_bomb_effect= load_asset(4, true);\n    move_asset(img_bomb_effect,360,640);\n for(local i = 0; i<4; i++) \n  {\n       img_time.push(load_asset(50+i, true));\n      move_asset(img_time[i], 360, 640);\n   }\n\n  hud_chance = load_asset(54, true);\n   move_asset(hud_chance, 360, 1210);\n   \n local tmp;\n   local iter = 30;\n for(local i = 0;i < 6;i++,iter+=3)\n   {\n       tmp= fruit_img_data();\n      tmp.img= load_asset(iter, true);\n    if(tmp.img != null)\n     {\n          tmp.width= asset_get_width(tmp.img)/2;\n         tmp.height= asset_get_height(tmp.img)/2;\n       tmp.img_part= load_asset(iter + 1 , true);\n         tmp.img_spot= load_asset(iter + 2, true);\n          img_fruits.push(tmp);\n          tmp.fruits_index = img_fruits.len() - 1;\n       available_fruits.push(tmp);\n     }\n    }\n    tmp = fruit_img_data();\n  tmp.img = load_asset(5, true);\n   tmp.width= asset_get_width(tmp.img)/2;\n   tmp.height= asset_get_height(tmp.img)/2;\n tmp.img_part= load_asset(6 , true);\n  tmp.img_spot= load_asset(8, true);\n   img_fruits.push(tmp);\n\n  phy_set_gravity(0,0);\n    local f;\n for(local i=0; i<5; i++)\n {\n       f= finger_data();\n       f.x= -100;\n      f.y= -100;\n      f.live= -1;\n     dedos.push(f);\n   }\n    hud_color = make_rgba(255, 249, 125, 255);\n   hud_color_titles = make_rgba(255, 255, 255, 255);\n\n  for(local i=0; i<3; i++)\n {\n       circles_chance.push(load_asset(55, true));\n      circles_chance_off.push(load_asset(56, true));\n   }\n\n  loseByProducts = load_asset(13,false);\n   move_asset(loseByProducts,720*0.5,1280*0.5);\n\n   loseByTime = load_asset(14,false);\n   move_asset(loseByTime,720*0.5,1280*0.5);\n}\n\nfunction start_level(level_num)\n{\n    time_start_game= get_time();\n gameCountdown = 3;\n   waitTime = time_start_game + 3000;\n   fruits.clear();\n  particles.clear();\n   spot_particles.clear();\n  bombs.clear();\n   specialFruit = null;\n cut.life= 0;\n timerBombExploded = false;\n   stopTimeDuration = 0;\n    specialFruitCounter = 0;\n Lifes= 3;\n    isLive= true;\n    img_timer_bomb_effect_duration = 1000;\n   timeFlow = true;\n lastdedo= 0;\n penultimodedo = 0;\n   angle = 0;\n   cuadrant = -1;\n   puntos= 0;\n   combo = 0;\n   min_time= 1000;\n  max_time= 2000;\n  min_time_bomb= 2000;\n max_time_bomb= 6000;\n speed_game= 15;\n  timerfruit= get_time() + 3000;\n   time_game= 30900;\n    timeDamage = 5000;\n   timerbomb= get_time() + 5000;\n    specialFruitTrigger = random_int(30, 60);\n    secondCountdown = 1000.0;\n    losingTimeCounter = get_time() - 1;\n  goingUp = true;\n  timeSize = 0.5;\n  timerBombProbability = 0;\n   pointsLevel = 20;\n    destroyedAll = true;\n timeElapsed = 0;\n passed10 = false;\n    passed20 = false;\n    chance = false;\n  for(local i=0; i<3; i++) \n    {\n       move_asset(circles_chance[i], 180*(i+1), 1210);\n     move_asset(circles_chance_off[i], 180*(i+1), 1210);\n  }\n}\n\n\nfunction update()\n{\n   deltaTime = get_time() - time_start_game;\n    if(get_time() < waitTime)\n    {\n       secondCountdown -= deltaTime;\n       if(secondCountdown < 0)\n     {\n          secondCountdown = 1000.0;\n       }\n       time_start_game = get_time();\n       gameCountdown = ((waitTime - get_time())/1000).tointeger() + 1;\n     return;\n  }\n    if(isLive)\n   {\n       if(losingTimeCounter > get_time() || timeSize != 0.5)\n       {\n          if(goingUp){\n          timeSize += 2 * deltaTime / 1000.0;\n           goingUp = timeSize < 1;\n        }\n          else\n       {\n             timeSize -= 2 * deltaTime / 1000.0;\n           goingUp = timeSize <= 0;\n       }\n          if(losingTimeCounter < get_time())\n         {\n             if(timeSize <= 0.55 && timeSize >= 0.45)\n          {\n                timeSize = 0.5;\n              goingUp = true;\n           }\n          }\n       }\n\n     local lis_delete= [];\n       time_game -= deltaTime;\n     timeElapsed += deltaTime;\n       if(timeElapsed >= 10000 && !passed10)\n       {\n          passed10 = true;\n       min_time = 750;\n        max_time  = 1500;\n       }\n       else if(timeElapsed >= 20000 && !passed20)\n      {\n          passed20 = true;\n       min_time = 200;\n        max_time  = 800;\n    }\n      time_start_game= get_time();\n      if(time_game <= 0)\n      { \n        time_game= 0;\n        play_effect(2);\n        endGame();\n        return;\n     }\n    if(timeFlow)\n    {\n          if(time_game >= 29000)\n         {\n             chance = true;\n         }\n          foreach(idx,val in fruits)\n         {\n             val.y-= val.vely * (deltaTime*0.001*0.5);\n             if(val.x <= (720-(img_fruits[val.index].width)) && val.x>(img_fruits[val.index].width))\n           {\n                val.x += val.velx * (deltaTime*0.001*0.33333);\n            }\n             if(val.vely > 10)\n             {\n                val.vely-= val.vely * (deltaTime*0.0003);\n             }\n             else\n          {\n                val.vely-= 1280 * (deltaTime*0.001);\n          }\n             if(val.y <= -150 && val.vely > 0)\n             { \n               val.vely= 0;\n          }\n             if(chance) \n           {\n                if(val.vely < 0 && val.y >= 1280 + img_fruits[val.index].height)\n             {\n                   lis_delete.push(idx);\n                   move_asset(circles_chance[Lifes-1],-1000,-1000);\n                Lifes--;\n                combo = 0;\n                  if(Lifes == 0)\n                  {\n                    play_effect(3);\n                    endGame();\n                    break;\n                  }\n                }\n             }\n          }\n          foreach(idx, val in lis_delete)\n        {\n             fruits.remove(val);\n        }\n          lis_delete.clear();\n        foreach(idx,val in bombs)\n          {\n             val.y-= val.vely * (deltaTime*0.001*0.5);\n             val.x += val.velx * (deltaTime*0.001*0.33333);\n            if(val.vely > 10)\n             {\n                val.vely-= val.vely * (deltaTime*0.0003);\n             }\n             else\n          {\n                val.vely-= 1280 * (deltaTime*0.001);\n          }\n             if(val.timeBomb)\n          {\n                if(val.vely < 0 && val.y >= 1280 + asset_get_height(img_bomb)/2)\n             {\n                   lis_delete.push(idx);\n                }\n             }\n             else\n          {\n                if(val.vely < 0 && val.y >= 1280 + asset_get_height(img_bomb)/2)\n             {\n                   lis_delete.push(idx);\n                }\n             }\n          }\n          foreach(idx, val in lis_delete)    \n       {\n             bombs.remove(val);\n         }\n          lis_delete.clear();\n        foreach(idx, val in particles)\n         {\n             if(val.y < 1280 + asset_get_height(img_fruits[val.index].img_part)/2)\n             {\n                val.y+=random_int(10, 15);\n            }\n             else\n          {\n                lis_delete.push(idx);\n             }\n          }\n          if(fruits.len() == 0 && destroyedAll)\n          {\n             timerfruit= get_time() + random_int(min_time, max_time);   \n          destroyedAll = false;        \n       }\n          foreach(idx, val in lis_delete)\n        {\n             try\n           {\n                particles.remove(val);\n               spot_particles.remove(val);\n           }\n             catch(error)\n          {\n                print(\"Error al borrar partículas\");\n               continue;\n             }\n          }\n          if(timerfruit < get_time())\n        {\n             createfruit();\n            local rdm = random_int(min_time, max_time);\n           timerfruit= get_time() + rdm;\n          }\n\n        if(timerbomb < get_time())\n         {\n             creatbomb();\n          timerbomb= get_time() + random_int(min_time_bomb, max_time_bomb);\n          }\n          if(timerBombTime < get_time())\n         {\n             timerBombExploded = false;\n         }\n          checkhits();\n       if(puntos == pointsLevel)\n          {\n             pointsLevel *= 2;\n        }\n       }\n       else\n    {\n          timeFlow = get_time() > stopTimeDuration;\n          checkSpecialHits(timeFlow);\n     }\n       foreach(idx,val in dedos)\n       {\n          if(val.live <= get_time())\n         {\n             val.live= -1;\n          }\n       }\n    }\n}\n\nfunction draw() \n{\n  draw_asset(img_background);\n  if (cut.img != null && cut.life > get_time())\n    {\n       move_asset(cut.img, cut.x, cut.y);\n      draw_asset(cut.img);\n }\n    foreach (idx, val in particles)\n  {\n       if (img_fruits[val.index].img_spot != null)\n     {\n          move_asset(img_fruits[val.index].img_spot, spot_particles[idx].x,spot_particles[idx].y);\n       draw_asset(img_fruits[val.index].img_spot);\n     }\n       move_asset(img_fruits[val.index].img_part, val.x, val.y);\n       draw_asset(img_fruits[val.index].img_part);\n  }\n    foreach (idx, val in fruits)\n {  \n    move_asset(img_fruits[val.index].img, val.x, val.y);\n    draw_asset(img_fruits[val.index].img);\n   }\n    foreach (idx, val in bombs)\n  {\n       if(val.timeBomb)\n    {\n          move_asset(img_bomb, val.x, val.y);\n        draw_asset(img_bomb);  \n    }\n       else\n    {\n          move_asset(img_bomb, val.x, val.y);\n        draw_asset(img_bomb);  \n    }\n    }\n    if (timerBombExploded)\n   {\n       draw_asset(img_bomb_effect);\n }\n    if(img_hud != null)\n  {\n       draw_asset(img_hud);\n }\n    draw_text_center2(597, 70, 3, puntos.tostring(), hud_color);\n draw_text_center2(125, 70,3, (floor(time_game*0.001)).tostring(), hud_color); \n   if(get_time() < waitTime)\n    {\n       if(gameCountdown == 3) \n     {\n          draw_asset(img_time[2])\n     } \n      else if (gameCountdown == 2) \n       {\n          draw_asset(img_time[1]);\n    } \n      else \n       {\n          draw_asset(img_time[0]);\n    } \n   }\n    if(Lifes == 0)\n   {\n       draw_asset(loseByProducts);\n  }\n    else if (!isLive && time_game == 0)\n  {\n       draw_asset(loseByTime);\n  }\n    if(chance)\n   {\n       draw_asset(hud_chance);\n     for(local i=circles_chance_off.len()-1; i>=0; i--) \n     {\n          draw_asset(circles_chance_off[i]); \n    }\n       for(local i=circles_chance.len()-1; i>=0; i--) \n     {\n          draw_asset(circles_chance[i]);\n      }\n    }  \n}\n\nfunction check_hit(x, y, w, h)\n{\n if(isSlashing())\n {\n       if (dedos[lastdedo].x > x-w && dedos[lastdedo].x < x + w)\n       {\n          if (dedos[lastdedo].y > y-h && dedos[lastdedo].y < y + h)\n          {\n             return true;\n       }\n       }\n    }\n    return false;\n}\n\nfunction checkhits()\n{\n  local fruitWidth = 0;\n    local fruitHeight = 0;\n\n if (dedos[lastdedo].live != -1)\n  {\n       local lis_delete = [];\n      foreach (idx, val in fruits)\n    {\n          fruitWidth = img_fruits[val.index].width <= 90 ? 90 : img_fruits[val.index].width; \n        fruitHeight = img_fruits[val.index].height <= 90 ? 90 : img_fruits[val.index].height; \n         if (check_hit(val.x, val.y,fruitWidth,fruitHeight))\n        {\n             lis_delete.push(idx);\n             puntos += 2;\n             play_effect(1);\n          combo++;\n          if(combo == 5)\n            {\n                puntos += 10;\n                time_game += 15000;\n           }\n             else if(combo == 10)\n          {\n                puntos += 20;\n                time_game += 20000;\n              combo = 0;\n            }\n             destroyedAll = fruits.len() == 0;\n             if (puntos % 16 == 0 && puntos > 0)\n           { \n               if (min_time > 400)\n              {\n                   min_time -=200;\n                 max_time  -= 200;\n                }\n                if (speed_game < 20)\n             {\n                   speed_game += 25;\n                }\n             }\n             createParticles(val);\n             createCut(val);\n        }\n       }\n       foreach (idx, val in lis_delete)\n    {\n          fruits.remove(val);\n     }\n       foreach (idx, val in bombs)\n     {\n          local sizew = asset_get_width(img_bomb)*0.3;\n       local sizeh = asset_get_height(img_bomb)*0.3;\n          if (check_hit(val.x, val.y, sizew, sizeh))\n          {\n            if(val.timeBomb)\n            {\n              losingTimeCounter = get_time() + 2000;\n              timerBombExploded = true;\n              timerBombTime = get_time() + img_timer_bomb_effect_duration;\n              bombs.remove(idx);\n            }\n            endGame();\n            move_asset(img_bomb_effect, val.x, val.y);\n            specialFruitCounter = 0;\n            break;\n          }\n       }\n    } \n}\n\nfunction checkSpecialHits(destroy)\n{\n   if(check_hit(specialFruit.x, specialFruit.y, img_fruits[specialFruit.index].width, img_fruits[specialFruit.index].height))\n   {\n       createCut(specialFruit)\n  }\n    if(destroy)\n  {\n       createParticles(specialFruit);\n      fruits.remove(specialFruitIndex);\n       specialFruit = null;\n    specialFruitIndex = -1;\n  }\n}\n\nfunction createParticles(val)\n{\n local p = particles_data();\n  p.x = val.x;\n p.y = val.y;\n p.index = val.index;\n particles.push(p);\n   p = particles_data();\n    p.x = val.x;\n p.y = val.y;\n p.index = val.index;\n spot_particles.push(p);\n}\n\nfunction createCut(val)\n{\n if (cut.img != null)\n {\n       cut.life = get_time() + 500;\n    cut.x = val.x;\n      cut.y = val.y;\n      angle = getAngle(dedos[lastdedo].x, dedos[lastdedo].y, dedos[penultimodedo].x, dedos[penultimodedo].y) - 60;\n    rotate_asset(cut.img, angle);\n    }\n}\n\nfunction distance(x1, y1, x2, y2)\n{\n return abs(x1 - x2) + abs(y1 - y2);\n}\n\nfunction secondsToTime(seconds)\n{\n local min = seconds / 60;\n    min = min.tointeger();\n   local sec = seconds % 60;\n    return format(\"%2u:%02u\", min, sec);\n}\n\nfunction getAngle(x1, y1, x2, y2)\n{\n    local x = x2 - x1;\n   local y = y2 - y1;\n   local hip = x*x + y*y;\n   if(hip == 0)\n {\n       return 0;\n    }\n    hip = sqrt(hip);\n local ang = acos(abs(x)/hip) * (180/PI);\n cuadrant = getCuadrant(x, y);\n    switch(cuadrant)\n {\n       case 0:\n        ang = 90 - ang;\n        break;\n      case 1:\n        ang = 180 - ang;\n       break;\n      case 2:\n        ang = 180 + ang;\n       break;\n      case 3:\n        ang = 360 - ang;\n       break;\n   }\n    return ang.tointeger();\n}\n\nfunction getCuadrant(x, y)\n{\n  if( x == 0 && y == 0)\n    {\n       return -1;\n   }\n    else if(x >= 0 && y > 0)\n {\n       return 0;\n    }\n    else if(x < 0 && y > 0)\n  {\n       return 1;\n    }\n    else if(x < 0 && y <= 0)\n {\n       return 2;\n    }\n    return 3;\n}\n\nfunction isSlashing()\n{\n if(penultimodedo == 0)\n   {\n       return false;\n    } \n   local slash = 0;\n foreach(idx, d in dedos)\n {\n       if(d.live != -1)\n    {\n          slash++;\n    }\n       if(slash >=2)\n       {\n          return true;\n    }\n    }\n    return false;\n}\n\nfunction endGame()\n{\n    isLive = false;\n  goto_menu_after_ms(\"gameover\", 3000);\n  save_highscore_gameover(puntos);\n}\n\nfunction less_space_text(t, size_text)\n{\n if (size_text > 1)\n   {\n       size_text--;\n }\n    size_text = size_text * 10;\n  local spaceadd = -1;\n do\n   {\n       t = t / 10;\n     spaceadd++;\n  }\n    while (t > 9)\n    return spaceadd * size_text;\n}\n\nfunction touch_start(x, y)\n{\n if (isLive)\n  {\n       dedos[0].x = x;\n     dedos[0].y = y;\n     dedos[0].live = get_time() + 350;\n       lastdedo = 0;\n       for (local i = 1; i < dedos.len(); i++)\n     {\n          dedos[i].live = -1;    \n    }\n    }\n}\n\nfunction touch_move(x, y)\n{\n if (isLive)\n  {\n       if (distance(dedos[lastdedo].x, dedos[lastdedo].y, x, y) > 10)\n      {\n          for (local i = 0; i < dedos.len(); i++)\n        {\n             if (dedos[i].live == -1)\n          {\n                dedos[i].x = x;\n              dedos[i].y = y;\n              dedos[i].live = get_time() + 350;\n                penultimodedo = lastdedo;\n                lastdedo = i;\n                return;\n           }\n          }\n          local f = finger_data();\n       f.x = x;\n       f.y = y;\n       f.live = get_time() + 350;\n         dedos.push(f);\n         penultimodedo = lastdedo;\n          lastdedo = dedos.len() - 1;\n     }\n    }\n}\n\nfunction touch_end(pos_x, pos_y)\n{\n  for (local i = 0; i < dedos.len(); i++)\n  {\n       dedos[i].live = -1;\n  }\n}\n\nclass cut_data\n{\n    constructor()\n    {}\n   x= 0;\n    y= 0;\n    img= null;\n   life= 0;\n}\n\nclass fruit_data\n{\n   constructor()\n    {}\n   x= 0;\n    y= 0;\n    vely= 0;\n velx= 0;\n index= 0;\n    special= false;\n}\n\nclass bomb_data\n{\n constructor()\n    {}\n   x= 0;\n    y= 0;\n    velx= 0;\n vely= 0;\n timeBomb=false;\n}\n\nclass particles_data\n{\n    constructor()\n    {}\n   x=0;\n y=0;\n index= 0;\n}\n\nclass fruit_img_data\n{\n  constructor()\n    {}\n   width=0;\n height=0;\n    img=null;\n    img_part=null;\n   img_spot= null;\n  fruits_index = 0;\n}\n\nclass finger_data\n{\n constructor()\n    {}\n   x= 0;\n    y= 0;\n    live= 0;\n}\n\nclass sword_data\n{\n   constructor()\n    {}\n   imgActive= null;\n imgInactive= null;\n   x= 0;\n    y= 0;\n    cutting= false;\n}\n\nfunction createfruit()\n{\n  if(available_fruits.len() == 0)\n  {\n       return;\n  }\n    specialFruitCounter++;\n   local index;\n local tmp = fruit_data();\n    if(specialFruitCounter >= specialFruitTrigger && specialFruit == null)\n   {\n       index = img_fruits.len() - 1;\n       specialFruitCounter = 0;\n    tmp.special = true;\n     specialFruitTrigger = random_int(50, 60);\n    }\n    else\n {\n       local availableIndex = random_int(0, available_fruits.len() - 1);\n       index = available_fruits[availableIndex].fruits_index;\n      tmp.special = false;\n }\n    tmp.x = random_int(img_fruits[index].width, 720 - (img_fruits[index].width)*0.5);\n    tmp.y = random_int(1280 + img_fruits[index].height,1500);\n    tmp.vely = random_int(1200,1800);\n    tmp.index = index;\n   if (tmp.x < 360)\n {\n       tmp.velx = random_int(200,720);\n  }\n    else\n {\n       tmp.velx = -random_int(200,720);\n }\n    fruits.push(tmp);\n}\n\nfunction creatbomb()\n{\n  if (img_bomb != null)\n    {\n       local tmp = bomb_data();\n    local lessX = asset_get_width(img_bomb) / 2;\n    tmp.x = random_int(lessX, 720 - lessX);\n     tmp.y = random_int(1280 + asset_get_height(img_bomb),1500);\n     tmp.vely = random_int(1200,1800);\n       local rn = 0;\n       tmp.timeBomb = rn <= timerBombProbability;\n      if (tmp.x < 360)\n    {\n          tmp.velx = random_int(50,720);\n      }\n       else\n    {\n          tmp.velx = -random_int(50,720);\n     }\n       bombs.push(tmp);\n }\n}"
  }, {
    "name": "Blocks",
    "projectID": 1307,
    "gameID": 1307,
    "script": "local width = 720;\nlocal height = 1280;\nlocal ceilingPos = 140;\nlocal initialBalls = 20;\nlocal bigBarMilSecondsTime = 5000;\nlocal brickXspace = 13;\nlocal brickYspace = 10;\nlocal brickScore = 5;\nlocal kiwiPowerUpRatio = 15;\nlocal bigBarPowerUpRatio = 40;\nlocal extraLifePowerUpRatio = 15;\n\nlocal backGround;\nlocal player;\nlocal gridManager;\nlocal powerUpManager;\nlocal hud;\nlocal reseting = false;\nlocal gameRunning = false;\nlocal initMagnitude = vector_2();\nlocal scoreCounter;\nlocal livesCounter;\nlocal levelCounter;\n\nlocal leftW;\nlocal rightW;\nlocal ceiling;\nlocal floor;\n\nlocal levelsConfig = [6,9,9,12,12];\nlocal levelPositions = [0.44,0.41,0.41,0.375,0.375];\nlocal secondsForDescending = [7,7,5,4,3];\n\nlocal showLvlText = false;\nlocal showWinText = false;\nlocal showLoseText = false;\n\nlocal isBigBarAvailable = false;\nlocal isKiwiAvailable = false;\nlocal isExtraLifeAvailable = false;\n\nlocal drawPlus1 = false;\nlocal plus1Object;\n\nlocal levelImg;\nlocal loseImg;\nlocal wonImg;\n\nlocal deltaTime = 0;\nlocal previousTime = 0;\n\nlocal stockOnX = -1;\n\nenum colType\n{\n    NONE,\n    BALL,\n    PLAYER,\n  WALL,\n    CEILING,\n DEAD_AREA,\n   BRICK,\n   POWER_UP\n};\n\nclass GameObject\n{\n  constructor()\n    {\n       position = vector_2();\n   }\n\n  asset = null;\n    shape = null;\n    position = null;\n\n   function initGameObject(id,withShape)\n    {\n       asset = load_asset(id,false);\n\n     if(withShape)\n       {\n          shape = phy_create_shape_for_asset(asset,true);\n     }\n    }\n\n  function moveObject(posX,posY)\n   {\n       if(asset != null)\n       {\n          move_asset(asset,posX,posY);\n    }\n       if(shape != null)\n       {\n          phy_move_shape(shape,posX,posY);\n    }\n       position.x = posX;\n      position.y = posY;\n   }\n\n  function Draw()\n  {\n       draw_asset(asset);\n   }\n}\n\nenum animType\n{\n X_MOVEMENT,\n  Y_MOVEMENT,\n  X_Y_MOVEMENT\n};\nclass FrameRateFreeAnimator extends GameObject\n{\n  constructor()\n    {\n       base.constructor();\n     progress = 2;\n       isRuning = false;\n    }\n\n  duration = null;\n factor = null;\n   initPoint = null;\n    progress = null;\n aType = null;\n    onCompleteCalled = null;\n callBack = null;\n isRuning = null;\n\n   function advanceAnimation()\n  {\n       if(isRuning)\n    {\n          progress += deltaTime * duration;\n\n        if(progress < 1)\n       {\n             runAnim();\n         }\n          else if(!onCompleteCalled)\n         {\n             onCompleteCalled = true;\n          onComplete();\n          }\n       }\n    }\n\n  function runAnim()\n   {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         position.x += factor * (deltaTime * duration);\n      break;\n      case(animType.Y_MOVEMENT):\n         position.y += factor * (deltaTime * duration);\n      break;\n      case(animType.X_Y_MOVEMENT):\n       position.x += factor.x * (deltaTime * duration);\n       position.y += factor.y * (deltaTime * duration);\n    break;\n      }\n       moveObject(position.x,position.y);\n   }\n\n  function setUp(anmType,nFactor,cllBack)\n  {\n       callBack = cllBack;\n     aType = anmType;\n    if(anmType == animType.X_Y_MOVEMENT)\n    {\n          factor = vector_2();\n       factor.x = nFactor.x;\n          factor.y = nFactor.y;\n       }\n       else\n    {\n          factor = nFactor;\n       }\n    }\n\n  function startAnim(nDuration)\n    {\n       if(!isRuning)\n       {\n          isRuning = true;\n       setInit();\n         if(nDuration > 0)\n          {\n             duration = 1.0/nDuration;\n          }\n          progress = 0;\n          onCompleteCalled = false;\n       }\n    }\n\n  function stopAndComplete(terminateAnim)\n  {\n       isRuning = false;\n       onCompleteCalled = false;\n       progress = 0;\n       if(terminateAnim)\n       {\n          adjustToAbsolute();\n     }\n    }\n\n  function setInit()\n   {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         initPoint = position.x;\n     break;\n      case(animType.Y_MOVEMENT):\n         initPoint = position.y;\n     break;\n      case(animType.X_Y_MOVEMENT):\n       initPoint = position;\n       break;\n      }\n    }\n\n  function onComplete()\n    {\n       adjustToAbsolute();\n     isRuning = false;\n       callBack();\n  }\n\n  function adjustToAbsolute()\n  {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         position.x = initPoint + factor;\n    break;\n      case(animType.Y_MOVEMENT):\n         position.y = initPoint + factor;\n    break;\n      case(animType.X_Y_MOVEMENT):\n       position.x = initPoint.x + factor.x;\n       position.y = initPoint.y + factor.y;\n    break;\n      }\n       moveObject(position.x,position.y);\n   }\n}\n\nclass NumberCountWithAssets\n{\n   constructor(initCount,deep)\n  {\n       allNumbers = [];\n    values = [];\n    currentCount = 0;\n\n     for(local i = 0;i < (10*deep);i++)\n      {\n          allNumbers.push(GameObject());\n         if((i%10) == 0)\n        {\n             values.push(-1);\n       }\n       }\n\n     addCount(initCount);\n }\n\n  allNumbers = null;\n   values = null;\n   assetsInitialIndex = null;\n   currentCount = null;\n\n   function loadAssets(startNdx)\n    {\n       assetsInitialIndex = startNdx;\n      for(local i = 0;i < allNumbers.len();i++)\n       {\n          allNumbers[i].initGameObject(assetsInitialIndex+(i%10),false);\n      }\n    }\n\n  function DrawImgText()\n   {\n       for(local i = 0;i < values.len();i++)\n       {\n          if(values[i] != -1)\n        {\n             draw_asset(allNumbers[(10*i)+values[i]].asset);\n        }\n       }\n    }\n\n  function resetCount(initVal)\n {\n       for(local i = 0;i < values.len();i++)\n       {\n          values[i] = -1;\n     }\n       currentCount = 0;\n       addCount(initVal);\n   }\n\n  function positionateCounterHorizontal(posX,posY)\n {\n       local dif = -1;\n     for(local i = 0;i < allNumbers.len();i++)\n       {\n          if((i%10) == 0)\n        {\n             dif++;\n         }\n          allNumbers[i].moveObject(posX - (width*(0.05*dif)),posY);\n       }\n    }\n\n  function positionateCounterVertical(posX,posY)\n   {\n       local dif = -1;\n     for(local i = 0;i < allNumbers.len();i++)\n       {\n          if((i%10) == 0)\n        {\n             dif++;\n         }\n          allNumbers[i].moveObject(posX,posY - (width*(0.05*dif)));\n       }\n    }\n\n  function rotateCounter(angle)\n    {\n       for(local i = 0;i < allNumbers.len();i++)\n       {\n          rotate_asset(allNumbers[i].asset,angle);\n    }\n    }\n\n  function addCount(nCount)\n    {\n       currentCount += nCount;\n     local toIncrease = nCount > 0 ? 1 : -1;\n     for(local i = 0;i < abs(nCount);i++)\n    {\n          addValue(0,toIncrease);\n     }\n    }\n\n  function addValue(index,incrs)\n   {\n       if(values[index] == -1)\n     {\n          values[index] = 1;\n      }\n       else\n    {\n          values[index] += incrs;\n     }\n       if(values[index] == 10)\n     {\n          values[index] = 0;\n         addValue(index+1,incrs);\n    }\n    }\n}\n\nclass Player\n{\n  constructor() \n   {\n       for(local i = 0;i < 2;i++)\n      {\n          bigbarAsset.push(load_asset(11,false));\n        smallAsset.push(load_asset(2,false));\n\n        currentAssests.push(smallAsset[i]);\n\n          smallShape.push(phy_create_shape_for_asset(smallAsset[i],true));\n       bigShape.push(phy_create_shape_for_asset(bigbarAsset[i],true));\n        phy_shape_set_collision_type(smallShape[i],colType.PLAYER);\n        phy_shape_set_collision_type(bigShape[i],colType.PLAYER);\n\n        currentShapes.push(smallShape[i]);\n\n       positions.push(vector_2());\n     }\n       initMagnitude.x = initMagnitude.y = asset_get_height(smallAsset[0])*0.9;\n\n      local flagFirst = true;\n\n       for (local i = 0;i < initialBalls;i++) \n     {\n          balls.push(Ball(flagFirst,i));\n         flagFirst = false;\n      }\n    }\n\n  isBigBar = false;\n    balls = [];\n  smallShape = [];\n bigShape = [];\n   bigbarAsset = [];\n    smallAsset = [];\n positions = [];\n  currentShapes = [];\n  currentAssests = [];\n\n   function moveCompletePlayer(posX,posY)\n   {\n       moveBottomBar(posX,posY);\n       moveTopBar(posX,height-posY);\n    }\n\n  function  controlBottomBar(posX)\n {\n       moveBarByIndex(posX,positions[0].y,0);\n   }\n\n  function  moveBottomBar(posX,posY)\n   {\n       moveBarByIndex(posX,posY,0);\n }\n\n  function  controlTopBar(posX)\n    {\n       moveBarByIndex(posX,positions[1].y,1);\n   }\n\n  function moveTopBar(posX,posY)\n   {\n       moveBarByIndex(posX,posY,1);\n }\n\n  function moveBarByIndex(posX,posY,index)\n {\n       move_asset(currentAssests[index],posX,posY);\n    phy_move_shape(currentShapes[index],posX,posY);\n     positions[index].x = posX;\n      positions[index].y = posY;\n   }\n\n  function resetPlayer()\n   {\n       turnIntoSmallBar();\n     moveCompletePlayer(width*0.4,height*0.88);\n\n    balls[0].onScene = true;\n    balls[0].lastBall = 1;\n\n    balls[0].moveObject(width*0.3,height*0.8);\n      balls[0].setUpAnim(initMagnitude);\n   }\n\n  function reStart()\n   {\n       for(local i = 0;i < balls.len();i++)\n    {\n          balls[i].destroyBall();\n     }\n\n     turnIntoSmallBar();\n     moveCompletePlayer(width*0.4,height*0.88);\n   }\n\n  function turnIntoBigBar()\n    {\n       if(!isBigBar)\n       {\n          for(local i = 0;i < 2;i++)\n         {\n             local smallPos = phy_get_shape_position(currentShapes[i]);\n            currentShapes[i] = bigShape[i];\n           phy_move_shape(bigShape[i],smallPos.x,smallPos.y);\n            phy_move_shape(smallShape[i],-1500,-1500);\n\n          currentAssests[i] = bigbarAsset[i];\n           move_asset(currentAssests[i],smallPos.x,smallPos.y);\n       }\n          isBigBar = true;\n       call_function_after_time(turnIntoSmallBar,bigBarMilSecondsTime);\n    }\n    }\n\n  function turnIntoSmallBar()\n  {\n       for(local i = 0;i < 2;i++)\n      {\n          local bigPos = phy_get_shape_position(currentShapes[i]);\n       currentShapes[i] = smallShape[i];\n          phy_move_shape(smallShape[i],bigPos.x,bigPos.y);\n       phy_move_shape(bigShape[i],-1500,-1500);\n\n         currentAssests[i] = smallAsset[i];\n         move_asset(currentAssests[i],bigPos.x,bigPos.y);\n    }\n\n     isBigBar = false;\n    }\n\n  function showBall()\n  {\n       for(local i = 0;i < balls.len();i++)\n    {\n          if(!balls[i].onScene)\n          {\n             balls[i].onScene = true;\n          balls[i].lastBall = getLastBall().lastBall + 1;\n           return balls[i];\n       }\n       }\n\n     return null;\n }\n\n  function getAllBalls()\n   {\n       local result = [];\n\n    for(local i = 0;i < balls.len();i++)\n    {\n          if(balls[i].onScene)\n       {\n             result.push(balls[i]);\n         }\n       }\n\n     return result;\n   }\n\n  function Draw()\n  {\n       for(local i = 0;i < 2;i++)\n      {\n          draw_asset(currentAssests[i]);\n      }\n    }\n\n  function DrawBalls()\n {\n       for(local i = 0;i < balls.len();i++)\n    {\n          if(balls[i].onScene)\n       {\n             draw_asset(balls[i].asset);\n        }\n       }\n    }\n\n  function updateBalls()\n   {\n       for(local i = 0;i < balls.len();i++)\n    {\n          balls[i].updateBall();\n      }\n    }\n\n  function getBallByShape(collShape)\n   {\n       for(local i = 0;i < balls.len();i++)\n    {\n          if(balls[i].onScene)\n       {\n             if(compare_shapes(balls[i].shape,collShape))\n          {\n                return balls[i];\n          }\n          }\n       }\n       return balls[balls.len()-1];\n }\n\n  function getLastBall()\n   {\n       local temp = 0;\n     local tempIndex = 0;\n\n      for(local i = 0;i < balls.len();i++)\n    {\n          if(balls[i].lastBall > temp)\n       {\n             temp = balls[i].lastBall;\n             tempIndex = i;\n         }\n       }\n       return balls[tempIndex];\n }\n\n  function haveLost()\n  {\n       for (local i = 0;i < balls.len();i++) \n      {\n          if(balls[i].onScene)   \n       {\n             return false;\n          }\n       }\n       return true;\n }\n\n  function removePhysicsFromPlayer()\n   {\n       for(local i = 0;i < 2;i++)\n      {\n          phy_shape_set_angle(currentShapes[i],0);\n       phy_shape_set_velocity(currentShapes[i],0,0);\n          phy_reset_forces(currentShapes[i]);\n     }\n    }\n}\n\nclass Ball extends FrameRateFreeAnimator\n{\n  constructor(firstBall,index) \n    {\n       base.constructor();\n\n       initGameObject(3,false);\n\n      local radio = (asset_get_width(asset) * 0.5) - 2;\n       shape = phy_create_circle_shape_for_asset (asset,radio);\n    phy_shape_set_collision_type(shape,colType.BALL);\n       onScene = false;\n    lastBall = 0;\n       counter = 4;\n    initiated = false;\n      number = index;\n     previousPosition = vector_2();\n     history = [];\n     factor = vector_2();\n\n    if(!firstBall)\n      {\n          moveObject(-500*index,-500*index);\n      }\n    }\n\n  dirX = null;\n dirY = null;\n onScene = null;\n  lastBall = null;\n previousPosition = null;\n counter = null;\n  number = null;\n   initiated = null;\n   history = null;\n\n  function firstInit()\n {\n       previousPosition = vector_2();\n      counter = 4;\n\n      moveObject(width*0.3,height*0.8);\n\n     onScene = true;\n     setUpAnim(initMagnitude);\n\n     lastBall = 1;\n\n     initiated = false;\n   }\n\n  function setUpAnim(factorVal)\n    {\n       setUp(animType.X_Y_MOVEMENT,factorVal,restartAnim);\n     startAnim(0.04);\n }\n\n  function restartAnim()\n   {\n       local helper = vector_2();\n       helper.x = position.x;\n       helper.y = position.y;\n       history.push(helper);\n       startAnim(-1);\n       if(history.len() >= counter)\n       {\n        checkIfStock();\n       }\n   }\n\n   function checkIfStock()\n   {\n     if(history[0].x == history[history.len()-1].x)\n      {\n          factor.x = factor.x > 0 ? factor.x+5 : factor.x-5;\n      }\n       if(history[0].y == history[history.len()-1].y)\n      {\n          factor.y = factor.y > 0 ? factor.y+10 : factor.y-10;\n    }\n       history.clear();\n   }\n\n  function updateBall()\n    {\n       if(onScene)\n     {\n          registerPrevious();\n        advanceAnimation();\n        if(position.y > (height*0.95) || position.y < (height*0.05))\n       {\n             destroyBall();\n            checkLoseCondition();\n          }\n          if(position.x > (width*0.8) || position.x < (width*0.03))\n          {\n             factor.x *= -1;\n           moveObject(position.x+factor.x,position.y);\n           if(stockOnX == position.y)\n            {\n                factor.y =initMagnitude;\n          }\n             stockOnX = position.y;\n         }\n       }\n    }\n\n  function destroyBall()\n   {\n       phy_reset_forces(shape);\n\n      onScene = false;\n    initiated = false;\n      lastBall = 0;\n\n     stopAndComplete(false);\n\n       moveObject(-500 * number,-500 * number);\n }\n\n  function registerPrevious()\n  {\n       previousPosition.x = position.x;\n    previousPosition.y = position.y;\n }\n}\n\nclass PowerUpManager\n{\n  constructor() \n   {\n       ballsInSceneInfo = [];\n\n    for(local i = 0;i < 2;i++)\n      {\n          initPowerUp(kiwiCollider,9);\n       initPowerUp(bigBarCollider,10);\n        initPowerUp(extraLifeCollider,12);\n      }\n    }\n\n  kiwiCollider = [];\n   bigBarCollider = [];\n extraLifeCollider = [];\n  isKiwiOnScene = false;\n   isBigBarOnScene = false;\n isExtraLifeOnScene = false;\n  ballsInSceneInfo = null;\n\n   function initPowerUp(powerArray,assetID)\n {\n       local lastIndex = 0;\n    powerArray.push(GameObject());\n      lastIndex = powerArray.len() -1;\n    powerArray[lastIndex].initGameObject(assetID,false);\n    powerArray[lastIndex].shape = phy_create_shape_for_asset(powerArray[lastIndex].asset,false);\n    phy_shape_set_collision_type(powerArray[lastIndex].shape,colType.POWER_UP);\n     phy_set_sensor(powerArray[lastIndex].shape, true);\n      powerArray[lastIndex].moveObject(-2000,-2000);\n   }\n\n  function createPowerUp(barCollider)\n  {\n       local nVec = phy_get_shape_position(barCollider);\n\n     if(canCreatePowerUp(extraLifePowerUpRatio,isExtraLifeOnScene,isExtraLifeAvailable,extraLifeCollider,nVec))\n      {\n          isExtraLifeOnScene = true;\n         return;\n     }\n\n     if(canCreatePowerUp(kiwiPowerUpRatio,isKiwiOnScene,isKiwiAvailable,kiwiCollider,nVec))\n      {\n          isKiwiOnScene = true;\n          return;\n     }\n\n     if(canCreatePowerUp(bigBarPowerUpRatio,isBigBarOnScene,isBigBarAvailable,bigBarCollider,nVec)\n          && !player.isBigBar)\n    {\n          isBigBarOnScene = true;\n        return;\n     }\n    }\n\n  function canCreatePowerUp(ratio,onSceneFlag,isAvailable,powerArray,powerPos)\n {\n       local randomNum = random_int(0,100);\n    if(randomNum <= ratio && !onSceneFlag && isAvailable)\n       {\n          powerArray[0].moveObject(powerPos.x,powerPos.y);\n       powerArray[1].moveObject(powerPos.x,powerPos.y);\n       return true;\n    }\n       return false;\n    }\n\n  function updatePowersOnScene()\n   {\n       if(isKiwiOnScene)\n       {\n          isKiwiOnScene = isPowerUpOnScene(kiwiCollider);\n     }\n       if(isBigBarOnScene)\n     {\n          isBigBarOnScene = isPowerUpOnScene(bigBarCollider);\n     }\n       if(isExtraLifeOnScene)\n      {\n          isExtraLifeOnScene = isPowerUpOnScene(extraLifeCollider);\n       }\n    }\n\n  function isPowerUpOnScene(powerArray)\n    {\n       powerArray[0].moveObject(powerArray[0].position.x,powerArray[0].position.y+3);\n     powerArray[1].moveObject(powerArray[1].position.x,powerArray[1].position.y-3);\n\n       if(powerArray[0].position.y >= height && powerArray[1].position.y <= 0)\n     {\n          return false;\n       }\n       return true;\n }\n\n  function drawPowerUp()\n   {\n       if(isKiwiOnScene)\n       {\n          draw_asset(kiwiCollider[0].asset);\n         draw_asset(kiwiCollider[1].asset);\n      }\n\n     if(isBigBarOnScene)\n     {\n          draw_asset(bigBarCollider[0].asset);\n       draw_asset(bigBarCollider[1].asset);\n    }\n\n     if(isExtraLifeOnScene)\n      {\n          draw_asset(extraLifeCollider[0].asset);\n        draw_asset(extraLifeCollider[1].asset);\n     }\n    }\n\n  function resolvePowerUp(powerUpCollider)\n {\n       if(compare_shapes(powerUpCollider,kiwiCollider[0].shape) || compare_shapes(powerUpCollider,kiwiCollider[1].shape))\n      {\n          local temp = player.getAllBalls();\n         local helper = 0;\n\n        for(local i = 0;i < temp.len();i++)\n        {\n             helper = temp[i].factor.x;\n            ballsInSceneInfo.push(helper);\n            helper = temp[i].factor.y;\n            ballsInSceneInfo.push(helper);\n            helper = temp[i].position.x;\n          ballsInSceneInfo.push(helper);\n            helper = temp[i].position.y;\n          ballsInSceneInfo.push(helper);\n         }\n\n        call_function_after_time(kiwiPowerUP,500);\n\n       isKiwiOnScene = false;\n         kiwiCollider[0].moveObject(-2000,-2000);\n       kiwiCollider[1].moveObject(-2000,-2000);\n    }\n       else if(compare_shapes(powerUpCollider,bigBarCollider[0].shape) || compare_shapes(powerUpCollider,bigBarCollider[1].shape))\n     {\n          player.turnIntoBigBar();\n\n         isBigBarOnScene = false;\n       bigBarCollider[0].moveObject(-2000,-2000);\n         bigBarCollider[1].moveObject(-2000,-2000);\n      }\n       else if(compare_shapes(powerUpCollider,extraLifeCollider[0].shape) || compare_shapes(powerUpCollider,extraLifeCollider[1].shape))\n       {\n          drawPlus1 = true;\n          plus1Object.moveObject(width*0.78,height*0.32);\n\n          call_function_after_time(turnOffPlus1,800);\n\n          isExtraLifeOnScene = false;\n        extraLifeCollider[0].moveObject(-2000,-2000);\n          extraLifeCollider[1].moveObject(-2000,-2000);\n       }\n    }\n\n  function kiwiPowerUP()\n   {\n       local nBall = null;\n     local tempV2 = vector_2();\n\n    for(local i = 0;i < ballsInSceneInfo.len();i+=4)\n    {\n          nBall = player.showBall();\n\n       if(nBall != null)\n          {\n             tempV2.x = ballsInSceneInfo[i];\n           tempV2.y = ballsInSceneInfo[i+1];\n\n           nBall.moveObject(ballsInSceneInfo[i+2],ballsInSceneInfo[i+3]);\n            nBall.setUpAnim(tempV2);\n       }\n       }\n\n     ballsInSceneInfo = [];\n   }\n\n  function removePowerUps()\n    {\n       isKiwiOnScene = false;\n      kiwiCollider[0].moveObject(-2000,-2000);\n    kiwiCollider[1].moveObject(-2000,-2000);\n\n      isBigBarOnScene = false;\n    bigBarCollider[0].moveObject(-2000,-2000);\n      bigBarCollider[1].moveObject(-2000,-2000);\n\n    isExtraLifeOnScene = false;\n     extraLifeCollider[0].moveObject(-2000,-2000);\n       extraLifeCollider[1].moveObject(-2000,-2000);\n    }\n}\n\nclass Bar extends GameObject\n{\n  constructor(id,nLifes) \n  {\n       base.constructor();\n\n       _ID = id;\n       initGameObject(id,true);\n\n      phy_shape_set_collision_type(shape,colType.BRICK);\n\n    onScene = true;\n     lifes = nLifes;\n  }\n\n  onScene = null;\n  lifes = null;\n    _ID = null;\n\n    function removeBar()\n {\n       if(lifes == 0)\n      {\n          onScene = false;\n\n         moveObject(-10000,-10000);\n      }\n       else\n    {\n          lifes--;\n    }\n    }\n\n  function descend()\n   {\n       moveObject(position.x,position.y + asset_get_height(asset));\n }\n}\n\nclass BarManager\n{\n  constructor()\n    {\n       grid = [];\n   }\n\n  columns = 5;\n rows = 0;\n    percentWidthArea = 0.8;\n  grid = null;\n addLife = false;\n\n   function createGrid()\n    {\n       local id = 4;\n       local maxIterator = 0;\n\n    rows = levelsConfig[levelCounter.currentCount-1];\n       maxIterator = (columns*rows) - grid.len();\n\n    for(local i = 0;i < maxIterator;i++)\n    {\n          id = random_int(4,8);\n             \n       grid.push(Bar(id,0));\n\n        if(((i+1)%columns) == 0)\n       {\n             id++;\n          }\n       }\n    }\n\n  function positionateGrid(posX)\n   {\n       local tempX = posX;\n     local tempY = height * levelPositions[levelCounter.currentCount-1];\n     local maxIterator = 0;\n\n    rows = levelsConfig[levelCounter.currentCount-1];\n       maxIterator = (columns*rows);\n\n     local rowToHide = random_int(0,columns-1);\n\n    for(local i = 0;i < maxIterator;i++)\n    {\n          if((i%columns) != rowToHide)\n       {\n             grid[i].moveObject(tempX,tempY);\n          grid[i].onScene = true;\n        }\n          else\n       {\n             grid[i].moveObject(-1000,-1000);\n       }\n\n        tempX += asset_get_width(grid[i].asset) + brickXspace;\n\n       if(((i+1)%columns) == 0)\n       {\n             tempY += asset_get_height(grid[i].asset) + brickYspace;\n           tempX = posX;\n          }\n       }\n       addLivesToBars();\n    }\n\n  function addLivesToBars()\n    {\n       if(addLife)\n     {\n          for(local i = 0;i < grid.len();i++)\n        {\n             if(grid[i]._ID == 8)\n          {\n                grid[i].lifes = 1;\n            }\n          }\n       }\n    }\n\n  function descendGrid()\n   {\n       if(!gameRunning)\n    {\n          return;\n     }\n\n     for (local  i = 0;i < grid.len();i++)\n       {\n          grid[i].descend();\n      }\n\n     call_function_after_time(descendGrid,1000*secondsForDescending[levelCounter.currentCount-1]);\n    }\n\n  function DrawGrid()\n  {\n       for(local i = 0;i < grid.len();i++)\n     {\n          grid[i].Draw();\n     }\n    }  \n\n   function getBarByShape(collShape)\n    {\n       for(local i = 0;i < grid.len();i++)\n     {\n          if(compare_shapes(grid[i].shape,collShape))\n        {\n             return grid[i];\n        }\n       }\n    }\n\n  function wasLastBar()\n    {\n       for(local i = 0;i <  grid.len();i++)\n    {\n          if(grid[i].position.x > 0 && grid[i].position.x < width)\n       {\n             return false;\n          }\n       }\n       return true;\n }\n}\n\nfunction init()\n{\n   backGround = load_asset(1,false);\n    move_asset(backGround,width*0.5,height*0.5);\n rotate_asset(backGround,90);\n\n   hud = load_asset(14,false);\n  move_asset(hud,width*0.5,height*0.5);\n    rotate_asset(hud,90);\n\n  player = Player();\n   player.moveCompletePlayer(width*0.4,height*0.88);\n\n  gridManager = BarManager();\n\n    powerUpManager = PowerUpManager();\n\n leftW = phy_create_rect_shape(0,ceilingPos,30,height,true);\n  phy_shape_set_collision_type(leftW,colType.WALL);\n    phy_move_shape(leftW,-10,height * 0.5);\n\n    rightW = phy_create_rect_shape(0,ceilingPos,30,height,true);\n phy_shape_set_collision_type(rightW,colType.WALL);\n   phy_move_shape(rightW,width*0.85,height * 0.5);\n\n    ceiling = phy_create_rect_shape(0,(width*0.5)-5,width,80,true);\n  phy_shape_set_collision_type(ceiling,colType.DEAD_AREA);\n phy_move_shape(ceiling,width*0.5,(height*0.07)-40);\n\n    floor = phy_create_rect_shape(0,(width*0.5)-5,width,80,true);\n    phy_shape_set_collision_type(floor,colType.DEAD_AREA);\n   phy_move_shape(floor,width*0.5,(height*0.92)+30);\n\n  initializeHUD();\n\n   setCollisionsHandlers();\n}\n\nfunction initializeHUD()\n{\n   plus1Object = GameObject();\n  plus1Object.initGameObject(13,false);\n    rotate_asset(plus1Object.asset,90);\n\n    scoreCounter = NumberCountWithAssets(0,5);\n   scoreCounter.loadAssets(20);\n scoreCounter.rotateCounter(90);\n  scoreCounter.positionateCounterVertical(width*0.88,height*0.62);\n\n   livesCounter = NumberCountWithAssets(3,5);\n   livesCounter.loadAssets(20);\n livesCounter.rotateCounter(90);\n  livesCounter.positionateCounterVertical(width*0.88,height*0.42);\n\n   levelCounter = NumberCountWithAssets(1,5);\n   levelCounter.loadAssets(20);\n levelCounter.rotateCounter(90);\n  levelCounter.positionateCounterVertical(width*0.88,height*0.75);\n\n    levelImg = load_asset(15,false);\n move_asset(levelImg,width*0.5,height*0.5);\n   rotate_asset(levelImg,90);\n\n loseImg = load_asset(30,false);\n  move_asset(loseImg,width*0.5,height*0.5);\n    rotate_asset(loseImg,90);\n\n  wonImg = load_asset(31,false);\n   move_asset(wonImg,width*0.5,height*0.5);\n rotate_asset(wonImg,90);\n}\n\nfunction setCollisionsHandlers()\n{\n   phy_create_collision_handler_begin(colType.BALL,colType.BALL,onBetweenBalls);\n    phy_create_collision_handler_begin(colType.BALL,colType.PLAYER,onPlayerCollision);\n   phy_create_collision_handler_begin(colType.BALL,colType.BRICK,onBarCollision);\n   phy_create_collision_handler_begin(colType.PLAYER,colType.POWER_UP,onPowerUpCought);\n}\n\nfunction start_level(level_num)\n{\n  livesCounter.resetCount(3);\n scoreCounter.resetCount(0);\n  levelCounter.resetCount(1);\n    internalStart();\n}\n\nfunction internalStart()\n{\n   gridManager.createGrid();\n    gridManager.positionateGrid(width*0.1);\n\n    showLvlText = true;\n\n    call_function_after_time(logicalInit,1400);\n  previousTime = get_time();\n}\n\nfunction logicalInit()\n{\n   player.balls[0].firstInit();\n\n   gameRunning = true;\n  call_function_after_time(turnOffText,100);\n}\n\n\nfunction update()\n{\n  deltaTime = (get_time() - previousTime) * 0.001;\n if(!reseting)\n    {\n       powerUpManager.updatePowersOnScene();\n    }\n\n  if(drawPlus1)\n    {\n       plus1Object.moveObject(plus1Object.position.x+4,plus1Object.position.y);\n }\n    player.updateBalls();\n    previousTime = get_time();\n}\n\nfunction draw()\n{\n  draw_asset(backGround);\n\n    draw_asset(hud);\n\n   scoreCounter.DrawImgText();\n  livesCounter.DrawImgText();\n  levelCounter.DrawImgText();\n\n    player.Draw();\n\n gridManager.DrawGrid();\n\n    powerUpManager.drawPowerUp();\n\n  player.DrawBalls();\n\n    if(showLvlText)\n  {\n       draw_asset(levelImg);\n    }\n    if(showLoseText)\n {\n       draw_asset(loseImg);\n }\n    if(showWinText)\n  {\n       draw_asset(wonImg);\n  }\n\n  if(drawPlus1)\n    {\n       draw_asset(plus1Object.asset);\n   }\n}\n\nfunction turnOffText()\n{\n    showLvlText = false;\n showWinText = false;\n showLoseText = false;\n}\n\nfunction turnOffPlus1()\n{\n   drawPlus1 = false;\n   livesCounter.addCount(1);\n}\n\nfunction gameCanRun()\n{\n if(reseting || !gameRunning)\n {\n       return false;\n    }\n\n  return true;\n}\n\nfunction onBetweenBalls(shape_1,shape_2)\n{\n  if(!gameCanRun())\n  {\n     return;\n  }\n\n  local temp = player.getBallByShape(shape_1);\n\n  temp.factor.x *= -1;\n  temp.factor.y *= -1;\n\n  temp = player.getBallByShape(shape_2);\n\n  temp.factor.x *= -1;\n  temp.factor.y *= -1;\n  play_effect(1);\n}\n\nfunction onPlayerCollision(shape_1,shape_2)\n{\n  if(!gameCanRun())\n  {\n     return;\n  }\n\n  stockOnX = -1;\n  ballBounce(shape_1,shape_2);\n\n  local temp = player.getBallByShape(shape_1);\n  temp.initiated = true;\n}\n\nfunction ballBounce(shape_1,shape_2)\n{\n  local temp = player.getBallByShape(shape_1);\n  local tempV2 = vector_2();\n  local magnitude = 0;\n\n  temp.stopAndComplete(false);\n  tempV2.x = temp.position.x - temp.previousPosition.x;\n  tempV2.y = temp.position.y - temp.previousPosition.y;\n  magnitude = sqrt((tempV2.x*tempV2.x) + (tempV2.y*tempV2.y));\n  tempV2.x = tempV2.x/magnitude; \n  tempV2.y = tempV2.y/magnitude;\n\n  tempV2.y *= -1;\n  tempV2.x *= initMagnitude.x;\n  tempV2.y *= initMagnitude.y;\n\n  temp.moveObject(temp.position.x,temp.position.y-(temp.factor.y*1.3));\n  temp.setUpAnim(tempV2);\n  player.removePhysicsFromPlayer();\n  play_effect(1);\n}\n\nfunction checkLoseCondition()\n{\n if(player.haveLost())\n    {\n       livesCounter.addCount(-1);\n\n    if(livesCounter.currentCount == 0)\n      {  \n      local tempLevel = levelCounter.currentCount;\n       levelCounter.resetCount(5);\n        increaseLevel(tempLevel);\n\n         showLoseText = true;\n       call_function_after_time(turnOffText,1000);\n     }\n       else\n    {\n          reseting = true;\n       call_function_after_time(resetPhysics,500);\n     }\n    }\n}\n\nfunction resetPhysics()\n{\n   reseting = false;\n    player.resetPlayer();\n    player.balls[0].initiated = false;\n}\n\nfunction onBarCollision(shape_1,shape_2)\n{\n  if(!gameCanRun())\n  {\n     return;\n  }\n  ballBounce(shape_1,shape_2);\n  local tempBar = gridManager.getBarByShape(shape_2);\n  if(tempBar.lifes == 0)\n  {\n     powerUpManager.createPowerUp(shape_2);\n  }\n  tempBar.removeBar();\n  scoreCounter.addCount(brickScore);\n  if(gridManager.wasLastBar())\n  {\n    showWinText = true;\n    call_function_after_time(turnOffText,1000);\n    increaseLevel(0);\n  }\n  player.removePhysicsFromPlayer();\n}\n\nfunction onPowerUpCought(shape_1,shape_2)\n{\n  if(!gameCanRun())\n  {\n     return;\n  }\n  powerUpManager.resolvePowerUp(shape_2);\n  player.removePhysicsFromPlayer();\n  play_effect(2);\n}\n\nfunction touch_move(pos_x,pos_y) \n{\n if(pos_y < (height*0.5))\n {\n       if(pos_x < ((phy_get_shape_position(rightW).x)-(asset_get_width(player.currentAssests[1])*0.5)) \n       &&  pos_x > (asset_get_width(player.currentAssests[1])*0.5))\n    {\n          player.controlTopBar(pos_x);\n    }\n    }\n    else\n {\n       if(pos_x < ((phy_get_shape_position(rightW).x)-(asset_get_width(player.currentAssests[0])*0.5)) \n       &&  pos_x > (asset_get_width(player.currentAssests[0])*0.5))\n    {\n          player.controlBottomBar(pos_x);\n     }\n    }\n\n  player.removePhysicsFromPlayer();\n}\n\nfunction increaseLevel(currentLevel)\n{\n  levelCounter.addCount(1);\n\n  player.reStart();\n\n  powerUpManager.removePowerUps();\n\n   player.resetPlayer();\n\n  switch(levelCounter.currentCount)\n    {\n       case(2):\n    {\n          isExtraLifeAvailable = true;\n       levelImg = load_asset(16,false);\n    }\n       break;\n      case(3):\n    {\n          isKiwiAvailable = true;\n        isBigBarAvailable = true;\n          levelImg = load_asset(17,false);\n    }\n       break;\n      case(4):\n    {\n          levelImg = load_asset(18,false);\n    }\n       break;\n      case(5):\n    {\n          gridManager.addLife = true;\n        levelImg = load_asset(19,false);\n    }\n       break;\n      case(6):\n    {\n      isBigBarAvailable = false;\n      isKiwiAvailable = false;\n      isExtraLifeAvailable = false;\n\n      gridManager.addLife = false;\n\n      levelImg = load_asset(15,false);\n      levelCounter.resetCount(currentLevel);\n\n      gameOver();\n     }\n       break;\n   }\n  move_asset(levelImg,width*0.5,height*0.5);\n  rotate_asset(levelImg,90);\n  if(gameRunning)\n  {\n    play_effect(4);\n    resetGame();\n    call_function_after_time(internalStart,1500);\n  }\n}\n\nfunction gameOver()\n{\n  play_effect(3);\n  resetGame();\n  goto_menu_after_ms(\"gameOver\",2000);\n}\n\nfunction resetGame()\n{\n  player.reStart();\n  powerUpManager.removePowerUps();\n  for(local i = 0;i < gridManager.grid.len();i++)\n  {\n     gridManager.grid[i].removeBar();\n  }\n  gameRunning = false;\n}"
  }, {
    "name": "2048",
    "projectID": 1316,
    "gameID": 1316,
    "script": "local width = 720;\nlocal height = 1280;\n\nlocal fondo;\nlocal logo;\nlocal score;\nlocal grid;\nlocal score_n = 0;\nlocal touchX;\nlocal touchY;\nlocal blocks = [];\nlocal move_begin_time=0;\nlocal moved = false;\n\nlocal objetivo;\nlocal ganaste;\nlocal flag = false;\nlocal flag2 = false;\nlocal erraseMsg = false;\nlocal erraseMsg2 = false;\n\nenum directions\n{\n   NONE,\n    UP,\n  DOWN,\n    RIGHT,\n   LEFT\n};\n\nenum numberValue\n{\n  NUM_2,\n   NUM_4,\n   NUM_8,\n   NUM_16,\n  NUM_32,\n  NUM_64,\n  NUM_128,\n NUM_256,\n NUM_512,\n NUM_1024,\n    NUM_2048,\n    NUM_4096,\n    NUM_8192,\n};\n\nclass NumberBlock\n{\n    constructor(_x,_y)\n    {\n        x = _x;\n        y = _y;\n        asstes = [];\n\n        for(local i = 0;i < 13;i++)\n        {\n           asstes.push(load_asset(10+i,true));\n        }\n    }\n    movex = null;\n    movey = null;\n    x = null;\n    y = null;\n    tipo = null;\n    isActive = null;\n    combine = null;\n    asstes = null;\n\n    function  initialize()\n    {\n      movex=-1;\n        movey=-1;\n        tipo = numberValue.NUM_2;\n        isActive = false;\n        combine = false;\n\n        for(local i = 0;i < 13;i++)\n        {\n           move_asset(asstes[i],-100,-100);\n        }\n    }\n\n    function drawAsset()\n    {\n        if(isActive)\n     {\n           draw_asset(asstes[tipo]);\n           checkIfNeedMessage();\n        }\n    }\n\n    function checkIfNeedMessage()\n    {\n        if(tipo == numberValue.NUM_2048)\n        {\n            if(!erraseMsg && !flag)\n            {\n                flag = true;\n            }\n        }\n        else if(tipo == numberValue.NUM_8192)\n        {\n            if(!erraseMsg2 && !flag2)\n            {\n               flag2 = true;\n            }\n        }\n    }\n\n    function moveAsset()\n    {\n        if(isActive)\n     {\n            local tempx = x;\n         local tempy = y;\n         if (movex != -1 && movey != -1 && move_begin_time >= get_time()-100)\n         {\n                x = movex+((x-movex)*((get_time()-move_begin_time)/100.0));\n              y = movey+ ((y-movey)*((get_time()-move_begin_time)/100.0));\n         }\n            else\n         {\n                movex = -1;\n              movey = -1;\n          }\n           move_asset(asstes[tipo],136+(149*x),568+(149*y));\n            x = tempx;\n           y = tempy;\n       }\n    }\n}\n\nfunction init()\n{\n    fondo = load_asset(1,true);\n    move_asset(fondo,width*0.5,height*0.5);\n    \n    grid = load_asset(2,true);\n    move_asset(grid,360,795);\n\n    score = load_asset(3,true);\n    move_asset(score,535,255);\n\n    logo = load_asset(4,true);\n    move_asset(logo,185,255);\n\n    objetivo = load_asset( 5,true);\n    move_asset(objetivo,width*0.5,height*0.5);\n    ganaste = load_asset( 6,true);\n    move_asset(ganaste,width*0.5,height*0.5);\n\n    for(local i = 0;i < 4;i++)\n    {\n      for(local j = 0;j < 4;j++)\n       {\n           blocks.push(NumberBlock(j,i));\n       }\n    }\n}\n\nfunction start_level(level_num)\n{\n    for(local i = 0;i < blocks.len();i++)\n    {\n     blocks[i].initialize();\n    }\n\n    score_n = 0;\n    flag = false;\n    flag2 = false;\n    erraseMsg = false;\n    erraseMsg2 = false;\n    add();\n    add();\n}\n\nfunction add()\n{\n    local p = random_int(0,blocks.len()-1);\n    local tipo = random_int(1,10);\n    if (tipo == 10)\n    {\n        tipo = 1;\n    }\n    else\n    {\n       tipo = 0;\n    }\n    if (blocks[p].isActive == false)\n    {\n        spawnOn(p,tipo);\n    }\n    else\n    {\n     if(!checkIfLose())\n       {\n           for(local i = 0;i < blocks.len();i++)\n           {\n              if(!blocks[i].isActive)\n            {\n                 spawnOn(i,tipo);\n              break;\n             }\n           }\n        }\n    }\n}\n\nfunction  spawnOn(ndx,type)\n{\n    blocks[ndx].isActive = true;\n blocks[ndx].tipo = type;\n blocks[ndx].movex = -1;\n  blocks[ndx].movey = -1;\n}\n\nfunction update()\n{\n    for(local i = 0;i < blocks.len();i++)\n    {\n        blocks[i].moveAsset();\n    }\n}\n\nfunction draw()\n{\n    draw_asset(fondo);\n    draw_asset(logo);\n    draw_asset(score);\n    draw_asset(grid);\n\n    draw_text_center2(530,250,3,number_to_commastring(score_n),make_rgba(0,0,0,255));\n\n    for(local i = 0;i < blocks.len();i++)\n    {\n        blocks[i].drawAsset();\n    }\n    mensajes();\n    mensaje2();\n}\n\nfunction mensajes() \n{\n    if(flag) \n    {\n        draw_asset(objetivo); \n        if(!erraseMsg)\n        {\n              call_function_after_time(borrarMensaje, 800);\n           erraseMsg = true;\n        }    \n    }\n}\nfunction mensaje2() \n{\n    if(flag2) \n    {\n        draw_asset(ganaste);\n        if(!erraseMsg2)\n        {\n         call_function_after_time(borrarMensaje2, 800);\n           erraseMsg2 = true;\n        }\n    }         \n}\n\nfunction borrarMensaje() \n{\n   flag = false;\n}\nfunction borrarMensaje2() \n{\n   flag2 = false;\n}\n\nfunction touch_start(pos_x,pos_y) \n{\n    touchX = pos_x;\n    touchY = pos_y;\n}\n\nfunction touch_end(pos_x,pos_y) \n{\n    local dir = directions.NONE;\n  local deltaY = abs(touchY - pos_y);\n  local deltaX = abs(touchX - pos_x);\n\nif(deltaY > deltaX)\n{\n    if(pos_y < touchY)\n    {\n        dir = directions.UP;\n    }\n    else\n    {\n        dir = directions.DOWN;\n    }\n}\nelse\n{\n    if(pos_x < touchX)\n    {\n        dir = directions.LEFT;\n    }\n    else\n    {\n        dir = directions.RIGHT;\n    }\n}\n    play_effect(2);\n    workDirection(dir);\n}\n\nfunction workDirection(nDir)\n{\n moved = false;\n   switch(nDir)\n {\n    case(directions.UP):\n        for (local y = 0; y <= 3; y++)\n        {\n            for (local x = 0; x < 4; x++)\n            {\n                checkVertical(x+(y*4),-1,x,y);\n            }\n        }\n break;\n   case(directions.DOWN):\n        for (local y = 3; y >= 0; y--)\n        {\n            for (local x = 0; x < 4; x++)\n            {\n              checkVertical(x+(y*4),1,x,y);\n            }\n        }\n  break;\n   case(directions.RIGHT):\n        for (local x = 3; x >= 0; x--)\n        {\n            for (local y = 0; y < 4; y++)\n            {\n             checkHorizontal(x+(y*4),1,x,y);\n            }\n        }\n    break;\n   case(directions.LEFT):\n        for (local x = 0; x <= 3; x++)\n        {\n            for (local y = 0; y < 4; y++)\n            {\n              checkHorizontal(x+(y*4),-1,x,y);\n            }\n        }\n   break;\n   }\n    checkMovement(moved);\n}\n\nfunction checkVertical(ndx,dir,pX,pY)\n{\n    local tempAxis = 0;\n    local nIndex = 0;\n    local pIndex = 0;\n    if (blocks[ndx].isActive)\n    {\n     tempAxis = pY + dir;\n     nIndex = pX+(tempAxis*4);\n        while (canMoveOnAxisTo(tempAxis,nIndex))\n        {\n           pIndex = pX+((tempAxis + (-dir))*4);\n         makeMovement(pIndex,nIndex,pX,pY);\n            moved = true;\n            tempAxis += dir;\n            nIndex = pX+(tempAxis*4);\n        }\n        nIndex = pX+((tempAxis+(-dir))*4);\n        pIndex = pX+(tempAxis*4);\n        if (checkForCombinationOnAxis(tempAxis,nIndex,pIndex))\n        {\n          makeCombination(nIndex,pIndex,pX,pY);\n            moved = true;\n        }\n    }\n}\n\nfunction checkHorizontal(ndx,dir,pX,pY)\n{\n    local tempAxis = 0;\n    local nIndex = 0;\n    local pIndex = 0;\n    if (blocks[ndx].isActive)\n    {\n     tempAxis = pX + dir;\n     nIndex = tempAxis+(pY*4);\n        while (canMoveOnAxisTo(tempAxis,nIndex))\n        {\n           pIndex = (tempAxis + (-dir))+(pY*4);\n         makeMovement(pIndex,nIndex,pX,pY);\n            moved = true;\n            tempAxis += dir;\n            nIndex = tempAxis+(pY*4);\n        }\n        nIndex = (tempAxis + (-dir))+(pY*4);\n        pIndex = tempAxis+(pY*4);\n        if (checkForCombinationOnAxis(tempAxis,nIndex,pIndex))\n        {\n            makeCombination(nIndex,pIndex,pX,pY);\n            moved = true;\n        }\n    }\n}\n\nfunction canMoveOnAxisTo(axisPos,nPos)\n{\n   if(axisPos > -1 && axisPos < 4)\n  {\n       return !blocks[nPos].isActive;\n   }\n    return false;\n}\n\nfunction makeMovement(prevIndex,newIndex,posX,posY)\n{\n    blocks[prevIndex].isActive = false;\n    blocks[newIndex].isActive = true;\n    blocks[newIndex].tipo = blocks[prevIndex].tipo;\n    blocks[newIndex].movey = posY;\n    blocks[newIndex].movex = posX;\n    move_begin_time = get_time();\n}\n\nfunction checkForCombinationOnAxis(axisPos,currntIndex,nextIndex)\n{\n    if(axisPos > -1 && axisPos < 4)\n  {\n       if(blocks[currntIndex].isActive && blocks[nextIndex].isActive && blocks[currntIndex].tipo == blocks[nextIndex].tipo)\n    {\n          return true;\n    }  \n }\n    return false;\n}\n\nfunction makeCombination(prevIndex,newIndex,posX,posY)\n{\n    blocks[newIndex].movey = posY;\n    blocks[newIndex].movex = posX;\n    blocks[prevIndex].isActive = false;\n    blocks[newIndex].tipo +=1;\n    blocks[newIndex].combine = true;\n    score_n += (pow(2,blocks[newIndex].tipo)) * 2;\n    play_effect(1);\n}\n\nfunction checkMovement(mvnt)\n{\n    if(mvnt)\n    {\n        call_function_after_time(add,200);\n        for (local i = 0; i < (blocks.len()-1); i++)\n        {\n           blocks[i].combine = false;\n        }\n    }\n    else\n    {\n        checkIfLose();\n    }\n}\n\nfunction checkIfLose()\n{\n    local end = 0;\n    for (local i = 0; i < (blocks.len()-1); i++)\n    {\n       if(blocks[i].isActive)\n       {\n            if (i==0 || i==3 || i==12 || i==15)\n          {\n               end +=1;\n         }\n            else if (i==1 || i==2)\n           {\n                if(blocks[i].tipo != blocks[i+1].tipo && blocks[i].tipo != blocks[i-1].tipo)\n             {\n                   end +=1;\n             }\n            }\n             else if (i==13 || i==14)\n            {\n                if (blocks[i].tipo != blocks[i+1].tipo && blocks[i].tipo != blocks[i-1].tipo)\n                {\n                   end +=1;\n             }\n            }\n             else if (i==4 || i==8)\n          {\n                if (blocks[i].tipo != blocks[i+4].tipo && blocks[i].tipo != blocks[i-4].tipo)\n                {\n                   end +=1;\n            }\n            }\n            else if (i==7 || i==11)\n          {\n                if (blocks[i].tipo != blocks[i+4].tipo && blocks[i].tipo != blocks[i-4].tipo)\n                {  \n                end +=1;\n             }\n            }\n            else if (blocks[i].tipo != blocks[i+1].tipo && blocks[i].tipo != blocks[i-1].tipo && blocks[i].tipo != blocks[i+4].tipo && blocks[i].tipo != blocks[i-4].tipo)\n           {\n                end+=1;\n          }\n        }\n    }\n    if (end == (blocks.len()-1))\n    {\n        play_effect(3);\n        goto_menu_after_ms(\"gameOver\",1000);\n       return true;\n    }\n    return false;\n}"
  }, {
    "name": "Psych",
    "projectID": 1309,
    "gameID": 1309,
    "script": "local width = 720;\nlocal height = 1280;\n\nlocal bckGround;\nlocal player;\nlocal buttonDown;\nlocal buttonUp;\n\n\nlocal platformTypes = 6;\nlocal platformOnPool = 2;\nlocal initialProbability = 1;\nlocal increasingprobability = 0.1;\n\nlocal Ydist = 0;\nlocal currentUpdate = 0;\nlocal updatesPerCheck = 3;\nlocal score = 0;\nlocal lives = 3;\nlocal haveLost = false;\nlocal canLose = true;\nlocal drawPlayer = false;\nlocal drawCount = 0;\nlocal paths = [];\nlocal speed = 0;\nlocal level = 0;\nlocal levelScore = [500,1500,2500];\nlocal touchInit = vector_2();\n\nlocal cloud1;\nlocal cloud2;\nlocal scoreImg;\nlocal livesImg;\nlocal livesCounter;\nlocal numbers = [];\nlocal decenas = [];\nlocal centenas = [];\nlocal millares = [];\nlocal decenasMillares = [];\nlocal unit = -1;\nlocal dece = -1;\nlocal cent = -1;\nlocal mill = -1;\nlocal deMi = -1;\n\nlocal showLevelText = false;\nlocal showLoseText = false;\nlocal showWinText = false;\nlocal hud_color = make_rgba(0, 0, 0, 255);\n\nlocal deltaTime = 0;\nlocal previousTime = 0;\n\nlocal HUDbackground;\n\nclass GameObject\n{\n    constructor()\n    {\n       position = vector_2();\n   }\n\n  asset = null;\n    shape = null;\n    position = null;\n\n   function initGameObject(id,withShape)\n    {\n       asset = load_asset(id,false);\n\n     if(withShape)\n       {\n          shape = phy_create_shape_for_asset(asset,true);\n     }\n    }\n\n  function moveObject(posX,posY)\n   {\n       if(asset != null)\n       {\n          move_asset(asset,posX,posY);\n    }\n       if(shape != null)\n       {\n          phy_move_shape(shape,posX,posY);\n    }\n       position.x = posX;\n      position.y = posY;\n   }\n\n  function readjustToPosition()\n    {\n       moveObject(position.x,position.y);\n   }\n\n  function Draw()\n  {\n       draw_asset(asset);\n   }\n}\n\nenum animType\n{\n X_MOVEMENT,\n  Y_MOVEMENT,\n  X_Y_MOVEMENT\n};\nclass FrameRateFreeAnimator extends GameObject\n{\n  constructor()\n    {\n       base.constructor();\n     progress = 2;\n       isRuning = false;\n    }\n\n  duration = null;\n factor = null;\n   initPoint = null;\n    progress = null;\n aType = null;\n    onCompleteCalled = null;\n callBack = null;\n isRuning = null;\n\n   function advanceAnimation()\n  {\n       progress += deltaTime * duration;\n\n     if(progress < 1)\n    {\n          runAnim();\n      }\n       else if(!onCompleteCalled)\n      {\n          onCompleteCalled = true;\n       onComplete();\n       }\n    }\n\n  function runAnim()\n   {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         position.x += factor * (deltaTime * duration);\n      break;\n      case(animType.Y_MOVEMENT):\n         position.y += factor * (deltaTime * duration);\n      break;\n      case(animType.X_Y_MOVEMENT):\n       position.x += factor.x * (deltaTime * duration);\n       position.y += factor.y * (deltaTime * duration);\n    break;\n      }\n       moveObject(position.x,position.y);\n   }\n\n  function setUp(anmType,nFactor,cllBack)\n  {\n       callBack = cllBack;\n     aType = anmType;\n    if(anmType == animType.X_Y_MOVEMENT)\n    {\n          factor = vector_2();\n       factor.x = nFactor.x;\n          factor.y = nFactor.y;\n       }\n       else\n    {\n          factor = nFactor;\n       }\n    }\n\n  function startAnim(nDuration)\n    {\n       if(!isRuning)\n       {\n          isRuning = true;\n       setInit();\n         if(nDuration > 0)\n          {\n             duration = 1.0/nDuration;\n          }\n          progress = 0;\n          onCompleteCalled = false;\n       }\n    }\n\n  function stopAnimation(terminateAnim)\n    {\n       isRuning = false;\n       onCompleteCalled = false;\n       progress = 0;\n       if(terminateAnim)\n       {\n          adjustToAbsolute();\n     }\n    }\n\n  function setInit()\n   {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         initPoint = position.x;\n     break;\n      case(animType.Y_MOVEMENT):\n         initPoint = position.y;\n     break;\n      case(animType.X_Y_MOVEMENT):\n       initPoint = position;\n       break;\n      }\n    }\n\n  function onComplete()\n    {\n       isRuning = false;\n       callBack();\n  }\n\n  function adjustToAbsolute()\n  {\n       switch(aType)\n       {\n       case(animType.X_MOVEMENT):\n         position.x = initPoint + factor;\n    break;\n      case(animType.Y_MOVEMENT):\n         position.y = initPoint + factor;\n    break;\n      case(animType.X_Y_MOVEMENT):\n       position.x = initPoint.x + factor.x;\n       position.y = initPoint.y + factor.y;\n    break;\n      }\n       moveObject(position.x,position.y);\n   }\n}\n\nclass Player extends GameObject\n{\n   constructor(id) \n {\n       base.constructor();\n\n       gameStarted = false;\n    checkPosition = false;\n\n    initGameObject(id,false);  \n    assetWidth = asset_get_width(asset) * 0.5;\n      assetHeight = asset_get_height(asset) * 0.5;\n }\n\n  initialIndex = 4;\n    assetWidth = null;\n   assetHeight = null;\n  gameStarted = null;\n  checkPosition = null;\n\n  plPlatform = null;\n   plPath = null;\n\n  function changePathOrPlatform(nPath,nPlatform,withSound)\n  {\n    plPlatform = nPlatform;\n    plPath = nPath;\n    if(withSound)\n    {\n      play_effect(1);\n    }\n\n    readjustToPlatform();\n  }\n\n  function readjustToPlatform()\n    {\n       if(!gameStarted)\n    {\n          return;\n     }\n       \n    local temp = vector_2();\n\n      if(checkPosition)\n       {\n          temp = position;\n\n         if(plPlatform != null )\n        {\n             temp.x = plPlatform.position.x;\n        }\n          \n       if(plPath != null)\n         {\n             temp.y = plPath.Ycenter;\n       }\n       }\n       else\n    {\n          temp.x = plPlatform.position.x;\n        temp.y = plPath.Ycenter;\n    }\n\n     moveObject(temp.x,temp.y);\n   }\n\n  function checkIfIsOnPlatform()\n   {\n       local tempPltfm = null;\n     local tempPath = getNearestPath();\n\n    for(local i = 0;i < tempPath.platforms.len();i++)\n       {\n          if(tempPath.platforms[i].onScene)\n          {\n             tempPltfm = tempPath.platforms[i];\n\n          if((position.x + assetWidth) > (tempPltfm.position.x - tempPltfm.assetWidth) &&\n              (position.x - assetWidth) < (tempPltfm.position.x + tempPltfm.assetWidth))\n            {\n                tempPltfm.haveStepped();\n             return true;\n          }\n          }\n       }\n       if(!gameStarted)\n    {\n          return true;\n    }\n       return false;\n    }\n\n  function checkIfOnScene()\n    {\n       if((position.x+assetWidth) > 0 && (position.x-assetWidth) < width &&\n    (position.y+assetHeight) > 0 && (position.y-assetHeight) < height)\n      {\n          return true;\n    }\n       if(!gameStarted)\n    {\n          return true;\n    }\n       return false;\n    }\n\n  function getNearestPath()\n    {\n       local tempDist = height;\n    local result = 0;\n       local index = 0;\n\n      for(local i = 0;i < paths.len();i++)\n    {\n          result = (position.y + 20)-paths[i].Ycenter;\n\n         if(result <= 0)\n        {\n             result *= -1;\n          }\n\n        if(result < tempDist)\n          {\n             tempDist = result;\n            index = i;\n         }\n       }\n\n     initialIndex = index;\n       return paths[index];\n }\n\n  function getNearestPlatform(selectedPath)\n    {\n       local tempDist = asset_get_width(asset) * 1.5;\n      local result = 0;\n       local index = -1;\n\n     for(local i = 0;i < selectedPath.platforms.len();i++)\n       {\n          if(selectedPath.platforms[i].onScene)\n          {\n             result = (position.x)-selectedPath.platforms[i].position.x;\n\n             if(result <= 0)\n           {\n                result *= -1;\n             }\n\n           if(result < tempDist)\n             {\n                tempDist = result;\n               index = i;\n            }\n          }\n       }\n\n     if(index >= 0)\n      {\n          return selectedPath.platforms[index];\n       }\n       else\n    {\n          return null;\n    }\n    }\n\n  function getPathIndex(diference)\n {\n       getNearestPath();\n\n     local result = initialIndex + diference;\n\n      if(result >= paths.len())\n       {\n          result = result - paths.len();\n      }\n       else if(result < 0)\n     {\n          result = (paths.len()) + result;\n    }\n\n     return result;\n   }\n}\n\nclass Platform extends FrameRateFreeAnimator \n{\n constructor(id) \n {\n       base.constructor();\n\n       initGameObject(id,false);\n       assetWidth = asset_get_width(asset) * 0.5;\n      initialSpeed = 6;\n    }\n\n  internalID = null;\n   onScene = null;\n  assetWidth = null;\n   timeAlive = null;\n    playerSteppedOnIt = null;\n    toDespawn = null;\n    goingLeft = null;\n    initialSpeed = null;\n\n   function initializePlatform(id,toLeft)\n   {\n       moveObject(1000,-1000);\n     internalID = id;\n    goingLeft = toLeft;\n     timeAlive = 0;\n      playerSteppedOnIt = false;\n      toDespawn = false;\n      setUpAnim();\n }\n\n  function setUpAnim()\n {\n       if(goingLeft)\n       {\n          setUp(animType.X_MOVEMENT,width*(-1.5),despawn);\n    }\n       else\n    {\n          setUp(animType.X_MOVEMENT,width*1.5,despawn);\n       }\n    }\n\n  function increaseLevel()\n {\n       initialSpeed -= speed;\n      if(isRuning)\n    {\n          duration = 1/initialSpeed;\n      }\n    }\n\n  function onSceneUpdate(pos_y)\n    {\n       if(onScene)\n     {\n          timeAlive++;\n       advanceAnimation();\n        position.y = pos_y;\n        readjustToPosition();\n\n        if((internalID == 5) && playerSteppedOnIt && !toDespawn && score > levelScore[0])\n          {\n             toDespawn = true;\n             call_function_after_time(despawn,300);\n         }\n       }\n    }\n\n  function despawn()\n   {\n       moveObject(1000,-1000);\n     toDespawn = false;\n      onScene = false;\n    timeAlive = 0;\n      playerSteppedOnIt = false;\n      stopAnimation(false);\n    }\n\n  function spawn(posY)\n {\n       if(goingLeft)\n       {\n          moveObject((width + assetWidth),posY);\n      }\n       else\n    {\n          moveObject(-assetWidth,posY);\n       }\n       onScene = true;\n     timeAlive = 0;\n      startAnim(initialSpeed);\n }\n\nfunction haveStepped()\n{\n  if(!playerSteppedOnIt)\n  {\n    playerSteppedOnIt = true;\n\n    addScore(50);\n\n    if(score >= levelScore[level])\n    {\n      level++;\n      play_effect(3);\n      if(level < levelScore.len())\n      {\n        showLevelText = true;\n        call_function_after_time(turnOffText,1000);\n        speed += 1.0;\n        for(local i = 0;i < paths.len();i++)\n        {\n          paths[i].increaseLevel();\n        }\n      }\n      else\n      {\n        showWinText = true;\n        haveLost = true;\n        call_function_after_time(turnOffText,1000);\n        call_function_after_time(gameOver,1100);\n      }\n    }\n  }\n}\n\n  function addScore(nScore)\n    {\n       score += nScore;\n    for(local i = 0;i < nScore;i++)\n     {\n          if(unit == -1)\n         {\n             unit = 1;\n          }\n          else\n       {\n             unit++;\n        }\n          if(unit == 10)\n         {\n             unit = 0;\n             if(dece == -1)\n            {\n                dece = 1;\n             }\n             else\n          {\n                dece++;\n           }\n             if(dece == 10)\n            {\n                dece = 0;\n                if(cent == -1)\n               {\n                   cent = 1;\n                }\n                else\n             {\n                   cent++;\n              }\n                if(cent == 10)\n               {\n                   cent = 0;\n                   if(mill == -1)\n                  {\n                      mill = 1;\n                   }\n                   else\n                {\n                      mill++;\n                 }\n                   if(mill == 10)\n                  {\n                      mill = 0;\n                      if(deMi == -1)\n                     {\n                         deMi = 1;\n                      }\n                      else\n                   {\n                         deMi++;\n                    }\n\n                 }\n                }\n             }\n          }\n       }\n    }\n}\n\nclass Path extends FrameRateFreeAnimator\n{\n  constructor(posY,toLeft) \n    {\n       base.constructor();\n\n       platforms = [];\n     goingLeft = toLeft;\n\n       local platformID = 5;\n       for(local i = 0;i < (platformTypes*platformOnPool);i+=2)\n    {\n          platforms.push(Platform(platformID));\n          platforms.push(Platform(platformID));\n          platformID++;\n       }\n\n     initialSpeed = 8;\n       position.y = posY;\n      initializePath(posY);\n       setUpAnim();\n }\n\n  platforms = null;\n    Ycenter = null;\n  resetY = null;\n   first = null;\n    goingLeft = null;\n    initialSpeed = null;\n\n   function initializePath(posY)\n    {\n       first = true;\n       Ycenter = posY;\n     resetY = -1 * (Ydist*0.5);\n\n    local platformID = 5;\n       for(local i = 0;i < (platformTypes*platformOnPool);i+=2)\n    {\n          platforms[i].initializePlatform(platformID,goingLeft);\n         platforms[i+1].initializePlatform(platformID,goingLeft);\n       platformID++;\n       }\n    }\n\n  function getNearestLeftPlatformOf(posX)\n  {\n       local tempDif = -width;\n     local result = 0;\n       local returnIndex = 0;\n\n    for(local i = 0;i < platforms.len();i++)\n    {\n          result = platforms[i].position.x - (posX - 20);\n        if(result < 0 && result > tempDif)\n         {\n             tempDif = result;\n             returnIndex = i;\n       }\n       }\n\n     if(!isAnEmptySpace(platforms[returnIndex]))\n     {\n          return null;\n    }\n\n     return platforms[returnIndex];\n   }\n\n  function getNearestRightPlatformOf(posX)\n {\n       local tempDif = width;\n      local result = 0;\n       local returnIndex = 0;\n\n    for(local i = 0;i < platforms.len();i++)\n    {\n          result = platforms[i].position.x - (posX+40);\n          if(result > 0 && result < tempDif)\n         {\n             tempDif = result;\n             returnIndex = i;\n       }\n       }\n\n     if(!isAnEmptySpace(platforms[returnIndex]))\n     {\n          return null;\n    }\n\n     return platforms[returnIndex];\n   }\n\n  function isAnEmptySpace(nPlatform)\n   {\n       local diferenceDist = 0;\n\n      if(player.plPlatform != null)\n       {\n          diferenceDist = abs(nPlatform.position.x - player.plPlatform.position.x);\n          diferenceDist -= asset_get_width(player.plPlatform.asset) * 0.5;\n    }\n       else\n    {\n          diferenceDist = abs(nPlatform.position.x - player.position.x);\n      }\n       \n    diferenceDist -= asset_get_width(nPlatform.asset) * 0.5;\n\n      if(diferenceDist >= asset_get_width(player.asset))\n      {\n          return false;\n       }\n\n     return true;\n }\n\n  function DrawPlatforms()\n {\n       for(local i = 0;i < platforms.len();i++)\n    {\n          if(platforms[i].onScene)\n       {\n             platforms[i].Draw();\n       }\n       }\n    }\n\n  function setUpAnim()\n {\n       setUp(animType.Y_MOVEMENT,height,restart);\n      startAnim(initialSpeed);\n }\n\n  function restart()\n   {\n       startAnim(initialSpeed);\n }\n\n  function increaseLevel()\n {\n       initialSpeed -= speed;\n      if(isRuning)\n    {\n          duration = 1/initialSpeed;\n      }\n\n     for(local i = 0;i < platforms.len();i++)\n    {\n          platforms[i].increaseLevel();\n       }\n    }\n\n  function onUpdate(moreProbability)\n   {\n       advanceAnimation();\n     Ycenter = position.y;\n\n     if(Ycenter >= (height+(-1*resetY)))\n     {\n          position.y = resetY;\n    }\n\n     for(local i = 0;i < platforms.len();i++)\n    {\n          platforms[i].onSceneUpdate(Ycenter);\n    }\n\n     if(currentUpdate >= updatesPerCheck)\n    {\n          spawnNewPlatform(first,moreProbability);\n       first = false;\n      }\n    }\n\n  function getNewestPlatform()\n {\n       local newest = 10000;\n       local index = 0;\n\n      for(local i = 0;i < platforms.len();i++)\n    {\n          if(platforms[i].onScene)\n       {\n             if(platforms[i].timeAlive < newest)\n           {\n                newest = platforms[i].timeAlive;\n             index = i;\n            }\n          }\n       }\n\n     return platforms[index];\n }\n\n  function verifyIfNewestIsFullOnScene()\n   {\n       local temp = getNewestPlatform();\n\n     if((temp.position.x + temp.assetWidth) < width && goingLeft)\n    {\n          return true;\n    }\n       else if((temp.position.x - temp.assetWidth) > 0 && !goingLeft)\n      {\n          return true;\n    }\n\n     return false;\n    }\n\n  function spawnNewPlatform(firstOnPath,moreProbability)\n   {\n       local platformProbability = initialProbability;\n     local rdm = 0;\n\n    if(firstOnPath)\n     {\n          spawnPlatformByIndex(random_int(0,platforms.len()-1));\n         for(local i = 0;i < platforms.len();i++)\n       {\n             if(platforms[i].onScene)\n          {\n                platforms[i].position.x = width * 0.5;\n            }\n          }\n          return;\n     }\n\n     if(verifyIfNewestIsFullOnScene())\n       {\n          for(local i = 0;i < platforms.len();i+=2)\n          {\n             rdm = random_int(0,100);\n          rdm -= moreProbability;\n           if (rdm <= platformProbability)\n           {\n                if(spawnPlatformByIndex(i))\n              {\n                   return;\n              }\n             }\n             else\n          {\n                platformProbability += increasingprobability;\n             }\n          }\n       }\n    }\n\n  function spawnPlatformByIndex(ndx)\n   {\n       if(!platforms[ndx].onScene)\n     {\n          platforms[ndx].spawn(Ycenter);\n         return true;\n    }\n       else if(!platforms[ndx+1].onScene)\n      {\n          platforms[ndx+1].spawn(Ycenter);\n       return true;\n    }\n\n     return false;\n    }\n\n  function despawnAll()\n    {\n       initialSpeed = 8;\n       for(local i = 0;i < platforms.len();i++)\n    {\n          platforms[i].despawn();\n        platforms[i].initialSpeed = 6;\n      }\n    }\n\n    function adjustPathTo(nPosY)\n    {\n        position.y = nPosY;\n      readjustToPosition();\n       for(local i = 0;i < platforms.len();i++)\n       {\n            platforms[i].position.y = nPosY;\n         platforms[i].readjustToPosition();;\n          }\n    }\n}\n\nfunction init()\n{\n  bckGround = load_asset(1,false);\n  move_asset(bckGround,width*0.5,height*0.5);\n\n  HUDbackground = load_asset(15,false);\n  move_asset(HUDbackground,width*0.5,asset_get_height(HUDbackground)*0.5);\n\n  player = Player(2);\n  player.moveObject(-1000,-1000);\n\n  scoreImg = load_asset(11,false);\n  move_asset(scoreImg,width*0.15,height*0.14);\n\n  livesImg = load_asset(14,false);\n  move_asset(livesImg,width*0.75,height*0.14);\n\n  livesCounter = load_asset(20+lives,false);\n  move_asset(livesCounter,width*0.92,height*0.14);\n\n   for(local i = 0;i < 10;i++)\n  {\n    numbers.push(load_asset(20+i,false));\n    move_asset(numbers[i],width*0.45,height*0.14);\n    decenas.push(load_asset(20+i,false));\n    move_asset(decenas[i],width*0.4,height*0.14);\n    centenas.push(load_asset(20+i,false));\n    move_asset(centenas[i],width*0.35,height*0.14);\n    millares.push(load_asset(20+i,false));\n    move_asset(millares[i],width*0.3,height*0.14);\n    decenasMillares.push(load_asset(20+i,false));\n    move_asset(decenasMillares[i],width*0.25,height*0.14);\n   }\n\n  cloud1 = load_asset(12,false);\n  move_asset(cloud1,width*0.4,height*0.4);\n\n  cloud2 = load_asset(13,false);\n  move_asset(cloud2,width*0.6,height*0.6);\n\n  Ydist = height/9;\n  local dirFlag = false;\n  paths.push(Path(-1 * (Ydist*0.5),dirFlag));\n  for(local i = 0;i < 9;i++)\n  {\n    dirFlag = dirFlag == false ? true : false;\n    paths.push(Path((Ydist*i)+(Ydist*0.5),dirFlag));\n  }\n}\n\nfunction start_level(level_num)\n{\n   unit = -1;\n   dece = -1;\n   cent = -1;\n   mill = -1;\n   deMi = -1;\n\n turnOffText();\n\n paths[0].initializePath(-1 * (Ydist*0.5));\n   for(local i = 0;i < 9;i++)\n   {\n       paths[i+1].initializePath((Ydist*i)+(Ydist*0.5));\n    }\n\n      livesCounter = load_asset(20+lives,false);\n       move_asset(livesCounter,width*0.92,height*0.14);\n    drawPlayer = false;\n    previousTime = get_time();\n\n    call_function_after_time(internalStart,500);\n}\n\nfunction internalStart()\n{\n  checkPlatform();\n\n   showLevelText = true;\n    call_function_after_time(turnOffText,1000);\n\n    haveLost = false;\n}\n\nfunction checkPlatform()\n{\n for(local i = 0;i < paths[4].platforms.len();i++)\n    {\n       if(paths[4].platforms[i].onScene)\n       {\n          if(paths[4].platforms[i].position.x < (width*0.7))\n         {\n             call_function_after_time(setPlayerToCenter,200);\n          return;\n        }\n       }\n    }\n    call_function_after_time(checkPlatform,50);\n}\n\nfunction setPlayerToCenter()\n{\n    haveLost = true;\n    player.moveObject(width*0.5,height*0.5);\n local nPath = player.getNearestPath();\n   local tempPltfm = player.getNearestPlatform(nPath);\n\n    if(tempPltfm != null)\n    {  \n     player.gameStarted = true;\n    player.changePathOrPlatform(nPath,tempPltfm,false);\n       canLose = true;\n      player.checkPosition = true;\n    call_function_after_time(setPlayer,100);\n }\n    else\n {\n       haveLost = false;\n       call_function_after_time(setPlayerToCenter,300);\n }\n}\n\nfunction setPlayer()\n{    \n    parpadeo();\n}\n\nfunction update()\n{\n  deltaTime = (get_time() - previousTime) * 0.004;\n  if(!haveLost)\n  {\n    verifyPathsPosition();\n    player.readjustToPlatform();\n\n    currentUpdate++;\n    for(local i = 0;i <paths.len();i++)\n    {\n      if(i == player.getPathIndex(1) || i == player.getPathIndex(-1))\n      {\n        paths[i].onUpdate(70);\n      }\n      else if(i == player.getPathIndex(2) || i == player.getPathIndex(-2))\n      {\n        paths[i].onUpdate(40);\n      }\n      else\n      {\n        paths[i].onUpdate(0);\n      }\n    }\n    if(canLose)\n    {\n      if(currentUpdate >= updatesPerCheck)\n      {\n        currentUpdate = 0;\n        if(!player.checkIfIsOnPlatform() || !player.checkIfOnScene())\n        {\n          haveLost = true;\n          call_function_after_time(playerFall,500);\n        }\n      }\n    }\n  }\n  previousTime = get_time();\n}\n\nfunction verifyPathsPosition()\n{\n   for(local i = 0;i < (paths.len()-1);i++)\n {\n       local dist = abs(paths[i+1].position.y-paths[i].position.y);\n    if(dist < (Ydist*0.95))\n     {\n          paths[i+1].adjustPathTo(paths[i].position.y + Ydist);\n       }\n    }\n}\n\nfunction playerFall()\n{\n  lives--;\n  livesCounter = load_asset(20+lives,false);\n  move_asset(livesCounter,width*0.92,height*0.14);\n  haveLost = true;\n  canLose = false;\n  drawPlayer = false;\n  play_effect(2);\n  call_function_after_time(respawn,1000);\n}\n\nfunction respawn()\n{\n  if(lives == 0)\n   {\n       gameOver();\n  }\n    else\n {\n       setPlayerToCenter();\n  }\n}\n\nfunction parpadeo()\n{\n   if(drawPlayer)\n   {\n       drawPlayer = false;\n  }\n    else\n {\n       drawPlayer = true;\n   }\n\n  if(drawCount < 5)\n    {\n       drawCount ++;\n       call_function_after_time(parpadeo,200);\n  }\n    else\n {\n       drawPlayer = true;\n      drawCount = 0;\n      call_function_after_time(startCollision,500);\n    }\n}\n\nfunction startCollision()\n{\n haveLost = false;\n}\n\nfunction draw()\n{\n draw_asset(bckGround);\n\n draw_asset(cloud1);\n  draw_asset(cloud2);\n\n    for(local i = 0;i < paths.len();i++)\n {\n       paths[i].DrawPlatforms();\n    }\n\n  if(drawPlayer)\n   {\n       player.Draw();\n   }\n draw_asset(HUDbackground);\n\n  draw_asset(scoreImg);\n    if(unit != -1)\n   {\n       draw_asset(numbers[unit]);\n   }\n    if(dece != -1)\n   {\n       draw_asset(decenas[dece]);\n   }\n    if(cent != -1)\n   {\n       draw_asset(centenas[cent]);\n  }\n    if(mill != -1)\n   {\n       draw_asset(millares[mill]);\n  }\n    if(deMi != -1)\n   {\n       draw_asset(decenasMillares[deMi]);\n   }\n\n  draw_asset(livesImg);\n    draw_asset(livesCounter);\n\n  if(showLevelText)\n    {\n       draw_text_center2(width*0.5,height*0.5,2,\"Pasaste al nivel \" + (level+1),hud_color);\n   }\n    if(showLoseText)\n {\n       draw_text_center2(width*0.5,height*0.5,2,\"Perdiste\",hud_color);\n    }\n    if(showWinText)\n  {\n       draw_text_center2(width*0.5,height*0.5,2,\"Ganaste!\",hud_color);\n    }\n}\n\nfunction turnOffText()\n{\n    showLevelText = false;\n   showLoseText = false;\n    showWinText = false;\n}\n\nfunction get_arrow_keys(key, state) \n{\n   if(haveLost)\n {\n       return;\n  }\n\n  local tempPath;\n  local tempPltfm;\n\n   if(state == 1 && key == 2)\n   {\n       tempPath = player.getPathIndex(-1);\n     if(paths[tempPath].Ycenter >= (asset_get_height(HUDbackground)) && \n         paths[tempPath].Ycenter < player.position.y)\n    {\n          player.plPlatform = player.getNearestPlatform(paths[tempPath]);\n        player.changePathOrPlatform(paths[tempPath],player.plPlatform,true);\n        currentUpdate = updatesPerCheck;\n    }\n    }\n    if(state == 1 && key == 3)\n   {\n       tempPath = player.getPathIndex(1);\n      if(paths[tempPath].Ycenter <= (height-(asset_get_height(player.asset)*0.5)) && \n        paths[tempPath].Ycenter > player.position.y)\n    {\n          player.plPlatform = player.getNearestPlatform(paths[tempPath]);\n        player.changePathOrPlatform(paths[tempPath],player.plPlatform,true);\n        currentUpdate = updatesPerCheck;\n    }\n    }\n\n  if(state == 1 && key == 0)\n   {\n       if(player.plPath != null)\n       {\n          tempPath = player.plPath;\n       }\n       else\n    {\n          tempPath = player.getNearestPath();\n     }\n\n     tempPltfm = tempPath.getNearestLeftPlatformOf(player.position.x);\n       if(tempPltfm != null)\n       {\n          if(tempPltfm.position.x >= (asset_get_width(player.asset)*0.5) && \n            tempPltfm.position.x < player.position.x)\n          {\n             player.changePathOrPlatform(player.plPath,tempPltfm,true);\n          }\n       }\n    }\n    if(state == 1 && key == 1)\n   {\n       if(player.plPath != null)\n       {\n          tempPath = player.plPath;\n       }\n       else\n    {\n          tempPath = player.getNearestPath();\n     }\n\n     tempPltfm = tempPath.getNearestRightPlatformOf(player.position.x);\n      if(tempPltfm != null)\n       {           \n       if(tempPltfm.position.x <= (width-(asset_get_width(player.asset)*0.5)) && \n            tempPltfm.position.x > player.position.x)\n          {\n             player.changePathOrPlatform(player.plPath,tempPltfm,true);\n          }\n       }\n    }\n}\n\nfunction touch_start(pos_x,pos_y)\n{\n touchInit.x = pos_x;\n touchInit.y = pos_y;\n}\n\nfunction touch_end(pos_x,pos_y)\n{\n    if(haveLost)\n {\n       return;\n  }\n    if(!player.gameStarted)\n  {\n       return;\n  }\n\n  local tempPath;\n  local tempPltfm;\n\n   if(pos_y <= (touchInit.y-80))\n    {\n       tempPath = player.getPathIndex(-1);\n     if(paths[tempPath].Ycenter >= (asset_get_height(HUDbackground)) && \n         paths[tempPath].Ycenter < player.position.y)\n    {\n          player.plPlatform = player.getNearestPlatform(paths[tempPath]);\n        player.changePathOrPlatform(paths[tempPath],player.plPlatform,true);\n        currentUpdate = updatesPerCheck;\n    }\n    }\n    else if(pos_y >= (touchInit.y+80))\n   {\n       tempPath = player.getPathIndex(1);\n      if(paths[tempPath].Ycenter <= (height-(asset_get_height(player.asset)*0.5)) && \n        paths[tempPath].Ycenter > player.position.y)\n    {\n          player.plPlatform = player.getNearestPlatform(paths[tempPath]);\n        player.changePathOrPlatform(paths[tempPath],player.plPlatform,true);\n        currentUpdate = updatesPerCheck;\n    }\n    }\n\n  if(pos_x <= (touchInit.x-40))\n    {\n       if(player.plPath != null)\n       {\n          tempPath = player.plPath;\n       }\n       else\n    {\n          tempPath = player.getNearestPath();\n     }\n\n     tempPltfm = tempPath.getNearestLeftPlatformOf(player.position.x);\n       if(tempPltfm != null)\n       {\n          if(tempPltfm.position.x >= (asset_get_width(player.asset)*0.5) && \n            tempPltfm.position.x < player.position.x)\n          {\n             player.changePathOrPlatform(player.plPath,tempPltfm,true);\n          }\n       }\n    }\n    else if(pos_x >= (touchInit.x+40))\n   {\n       if(player.plPath != null)\n       {\n          tempPath = player.plPath;\n       }\n       else\n    {\n          tempPath = player.getNearestPath();\n     }\n\n     tempPltfm = tempPath.getNearestRightPlatformOf(player.position.x);\n      if(tempPltfm != null)\n       {           \n       if(tempPltfm.position.x <= (width-(asset_get_width(player.asset)*0.5)) && \n            tempPltfm.position.x > player.position.x)\n          {\n             player.changePathOrPlatform(player.plPath,tempPltfm,true);\n          }\n       }\n    }\n}\n\nfunction gameOver()\n{\n   lives = 3;\n   level = 0;\n   score = 0;\n   speed = 0;\n   haveLost = true;\n drawPlayer = false;\n  for(local i = 0;i < paths.len();i++)\n {\n       paths[i].despawnAll();\n   }\n  goto_menu_after_ms(\"gameOver\",100);\n}"
  }, {
    "name": "Tetris",
    "projectID": 1310,
    "gameID": 1310,
    "script": "local bGround;\nlocal header;\nlocal nextP;\nlocal iScore;\n\nlocal width = 720;\nlocal height = 1280;\n\nlocal pieceSize = 0;\nlocal nextID = 0;\nlocal score = 0;\nlocal velocity = 500;\nlocal previousVel = 500;\nlocal velAux = 0;\nlocal contf=0;\nlocal flgvel = false;\nlocal enterCol = false;\nlocal oneTouch = false;\nlocal mainFig = null;\nlocal secondFig = null;\nlocal touchTime;\nlocal tapTime = 400;\nlocal swipeTime = 700;\nlocal initialTouch = vector_2();\nlocal allPieces = [];\nlocal gridPos = [];\nlocal gridFlags = [];\nlocal littleImg = [];\nlocal shapeDown;\nlocal shapeLeft;\nlocal shapeRigh;\nlocal playerShp;\n\nlocal pause = false;\n\nclass Piece\n{\n    constructor ()\n   {\n    }\n\n\n    ID = null;\n   img = null;\n  pPos = null;\n pieceIndex = null;\n\n function create(id,ndx)\n  {\n       ID = id;\n    pPos = vector_2();\n      img = load_asset(ID,false);\n     pieceIndex = ndx;\n       \n }\n\n  function movePieceTo(_x,_y,ndx)\n  {\n       pPos.x = _x;\n    pPos.y = _y;\n     move_asset(img,_x,_y);\n       pieceIndex = ndx;\n    }\n\n  function moveStepDown()\n  {\n       movePieceTo(pPos.x,pPos.y + pieceSize,pieceIndex);\n      pieceIndex -= 10;\n    }\n\n  function moveStepUp()\n    {\n       movePieceTo(pPos.x,pPos.y - pieceSize,pieceIndex);\n      pieceIndex += 10;\n    }\n\n  function moveStepSide(isRight)\n   {\n       if(isRight)\n     {\n          movePieceTo(pPos.x + pieceSize,pPos.y,pieceIndex);\n         pieceIndex++;\n       }\n       else\n    {\n          movePieceTo(pPos.x - pieceSize,pPos.y,pieceIndex);\n         pieceIndex--;\n       }\n    }\n\n  function destroyPiece()\n  {     \n    if(img != null)\n     {\n          move_asset(img,width*2,height*2);\n          img = null;\n     }\n    }\n}\n\nclass Figure\n{\n  constructor (id,num)\n  {\n    ID = id;\n    pieces = [];\n    curRotation = 0;\n    finalMove = false;\n    createFromID();\n    initialP = num;\n    previousP = num;\n\n    canMove = true;\n    currColumn = floor(num/pieceSize);\n\n    local j = 0;\n    local index = 0;\n\n    for(local i = 0; i < 4;i++,j+=2)\n    {\n      pieces.push(Piece());\n      index = initialP + positions[j] + (positions[j+1]*10);\n      pieces[i].create(ID,index);\n      pieces[i].movePieceTo((gridPos[index].x),(gridPos[index].y),index);\n    }\n  }\n\n  pieces = null;\n  ID = null;\n  positions = null;\n  curRotation = null;\n  initialP = null;\n  previousP = null;\n  canMove = true;\n  flag = false;\n  finalMove = null;\n  currColumn = null;\n\n  function createFromID()\n  {\n    positions = [];\n    switch(ID)\n      {\n          case(10):\n          {\n             positions = [0,0,0,1,0,-1,1,-1,  0,0,1,1,1,0,-1,0,  0,0,0,1,-1,1,0,-1,  0,0,1,0,-1,0,-1,-1];\n          }\n          break;\n         case(11):\n          {\n             positions = [0,0,0,1,0,-1,-1,-1,0,0,-1,0,1,0,1,-1,0,0,1,1,0,1,0,-1,0,0,1,0,-1,0,-1,1];\n         }\n          break;\n         case(12):\n          {\n             positions = [0,0,1,0,0,1,-1,1,0,0,1,0,1,1,0,-1,0,0,1,0,0,1,-1,1,0,0,1,0,1,1,0,-1];\n         }\n          break;\n         case(13):\n          {\n             positions = [0,0,0,1,1,1,-1,0,0,0,-1,0,0,-1,-1,1,0,0,0,1,1,1,-1,0,0,0,-1,0,0,-1,-1,1];\n         }\n          break;\n         case(14):\n          {\n             positions = [0,0,-1,0,-1,1,0,1,0,0,-1,0,-1,1,0,1,0,0,-1,0,-1,1,0,1,0,0,-1,0,-1,1,0,1];\n         }\n          break;\n         case(15):\n          {\n             positions = [0,0,0,1,0,2,0,-1,   0,0,-1,0,1,0,2,0,  0,0,0,1,0,2,0,-1,  0,0,2,0,-1,0,1,0];\n          }\n          break;\n         case(16):\n          {\n             positions = [0,0,-1,0,1,0,0,1,0,0,0,1,0,-1,-1,0,0,0,-1,0,1,0,0,-1,0,0,0,1,0,-1,1,0];\n       }\n          break;\n      }\n    }\n\n  function rotateFigure()\n  {\n       local prevRot = curRotation;\n    local tempArr = [];\n\n       for(local i = 0;i < 4;i++)\n      {\n          tempArr.push(pieces[i].pieceIndex);\n     }\n\n     switch(ID)\n      {\n          case(10):\n          case(11):\n          case(12):\n          case(13):\n          case(15):\n          case(16):\n          {\n             if(curRotation < 3)\n           {\n                curRotation++;\n            }\n             else\n          {\n                curRotation = 0;\n          }\n\n           local j = curRotation * 8;\n\n          for(local i = 0;i < 4;i++,j+=2)\n           {\n                tempArr[i] = tempArr[0] + positions[j] + (positions[j+1]*10);\n             }\n\n           local res = verifyOut(tempArr);\n           if(res != 0)\n          {\n                for(local i = 0;i < 4;i++)\n               {\n                   tempArr[i] = tempArr[i] + res;\n               }\n                if(ID == 15)\n             {\n                   res = verifyOut(tempArr);\n                   if(res != 0)\n                {\n                      for(local i = 0;i < 4;i++)\n                     {\n                         tempArr[i] = tempArr[i] + res;\n                     }\n                   }\n                }\n             }\n\n           local tempFlag = true;\n            for(local i = 0;i < 4;i++)\n            {\n                if(tempArr[i] < 0)\n               {\n                   tempFlag = false;\n                   break;\n               }\n                if(gridFlags[tempArr[i]] == true)\n                {\n                   tempFlag = false;\n                   break;\n               }\n             }\n\n           if(tempFlag)\n          {\n                for(local i = 0;i < 4;i++)\n               {\n                   pieces[i].movePieceTo(gridPos[tempArr[i]].x,gridPos[tempArr[i]].y,tempArr[i]);\n               }\n             }\n             else\n          {\n                curRotation = prevRot;\n            }\n          }\n          break;\n         case(14):\n          {\n             return;\n        }\n          break;\n      }\n       \n }\n\n  function verifyOut(tArr)\n {\n       if(gridPos[tArr[0]].x < (width*0.5))\n    {\n          for(local i = 0;i < 4;i++)\n         {\n             if((tArr[i]%10) == 9)\n             {\n                return 1;\n             }\n          }\n       }\n       else\n    {\n          for(local i = 0;i < 4;i++)\n         {\n             if((tArr[i]%10) == 0)\n             {\n                return -1;\n            }\n          }\n       }\n       return 0 ;\n   }\n\n  function verifyRotation()\n    {\n       local fNeedMod = false;\n     local index = 0;\n    local j = curRotation * 8;\n\n    if((initialP%10) <= 4)\n      {\n          for(local i = 0;i < 4;i++,j++)\n         {\n             index = initialP + positions[j] + (positions[j+1]*10);\n            if((index%10) == 0)\n           {\n                fNeedMod = true;\n          }\n             if((index%10) == 1)\n           {\n                initialP++;\n           }\n          }\n          if(fNeedMod)\n       {\n             initialP++;\n           for(local i = 0,j=curRotation * 8; i < 4;i++,j+=2)\n            {\n                index = initialP + positions[j] + (positions[j+1]*10);\n               pieces[i].movePieceTo((gridPos[index].x),(gridPos[index].y),0);\n           }\n          }\n       }\n       else if((initialP%10) >= 6)\n     {\n          for(local i = 0;i < 4;i++,j++)\n         {\n             index = initialP + positions[j] + (positions[j+1]*10);\n            if((index%10) == 9)\n           {\n                fNeedMod = true;\n          }\n             if((index%10) == 8)\n           {\n                initialP--;\n           }\n          }\n          if(fNeedMod)\n       {\n             initialP--;\n           for(local i = 0,j=curRotation * 8; i < 4;i++,j+=2)\n            {\n                index = initialP + positions[j] + (positions[j+1]*10);\n               pieces[i].movePieceTo((gridPos[index].x),(gridPos[index].y),0);\n           }\n          }\n       }\n       if(ID == 15)\n    {\n          verify15();\n     }\n       verifyInitial();\n }\n\n  function verify15()\n  {\n       local wrong = -1;\n       local index = 0;\n    local j = curRotation * 8;\n\n    if (curRotation == 1 || curRotation == 3) \n      {\n          for(local i = 0;i < pieces.len();i++)\n          {\n             if(pieces[i].pPos.y != pieces[0].pPos.y)\n          {\n                wrong = i;\n            }\n          }\n\n        if(wrong > 0)\n          {\n             if(pieces[wrong].pPos.x  < width*0.5)\n             {\n                previousP = initialP;\n                initialP--;\n           }\n             else\n          {\n                previousP = initialP;\n                initialP++;\n           }\n             for(local i = 0; i < 4;i++,j+=2)\n          {\n                index = initialP + positions[j] + (positions[j+1]*10);\n               pieces[i].movePieceTo((gridPos[index].x),(gridPos[index].y),0);\n           }\n          }\n       }\n    }\n\n  function verifyInitial()\n {\n       for(local k = 0;k < 200;k++)\n    {\n          if(gridPos[k].x == pieces[0].pPos.x && gridPos[k].y == pieces[0].pPos.y)\n       {\n             initialP = k;\n             break;\n         }\n       }\n    }\n\n    function moveToXposition(posX)\n    {\n      local newColumn = floor(posX/pieceSize);\n      if(newColumn < currColumn)\n      {\n        moveFigSide(false);\n        currColumn = newColumn;\n      }\n      else if(newColumn > currColumn)\n      {\n        moveFigSide(true);\n        currColumn = newColumn;\n      }\n    }\n\n  function moveFigSide(isRight)\n    {\n       local index = 0;\n    local j = curRotation * 8;\n      local dir = 0;\n\n    if(isRight)\n     {\n          canMoveRight();\n        if(flag)\n       {\n             if(canMoveToPos(1,curRotation))\n           {\n                dir = 1;\n          }\n             else\n          {\n                return;\n           }\n          }\n          else\n       {\n             return;\n        }\n       }\n       else\n    {\n          canMoveLeft();\n         if(flag)\n       {\n             if(canMoveToPos(-1,curRotation))\n          {\n                dir = -1;\n             }\n             else\n          {\n                return;\n           }\n          }\n          else\n       {\n             return;\n        }\n       }\n       for(local i = 0; i < 4;i++,j+=2)\n    {\n          \n       pieces[i].moveStepSide(isRight);\n    }\n       \n }\n\n  function canMoveLeft()\n   {\n       local index = 0;\n    local j = curRotation * 8;\n\n    for(local i = 0; i < 4;i++,j+=2)\n    {\n          index = pieces[i].pieceIndex;\n          if(gridPos[index].x > (width * 0.5))\n       {\n             flag = true;\n          return;\n        }\n          if(gridPos[index-1].x > (width * 0.5) && gridPos[index+1].x < (width * 0.5))\n       {\n             flag = false;\n             return;\n        }\n       }\n       flag = true;\n }\n\n  function canMoveRight()\n  {\n       local index = 0;\n    local j =  curRotation * 8;\n\n       for(local i = 0; i < 4;i++,j+=2)\n    {\n          index = pieces[i].pieceIndex;\n          if(gridPos[index].x < (width * 0.5))\n       {\n             flag = true;\n          return;\n        }\n          if(gridPos[index+1].x < (width * 0.5) && gridPos[index-1].x > (width * 0.5))\n       {\n             flag = false;\n             return;\n        }\n       }\n       flag = true;\n }\n\n  function moveFigDown()\n   {\n       if(canMove)\n     {\n          if(finalMove)\n          {\n             if(!canMoveToPos(-10,0))\n          {\n                return false;\n             }\n\n            try \n           {\n                 down();\n            } \n             catch(exception) \n              {\n                 print(\"ha ocurrido un error\"+exception);    \n           }\n          }\n          if(canMoveToPos(-10,0))\n        {\n             for(local i = 0;i < 4;i++)\n            {\n                pieces[i].moveStepDown();\n             }\n          } \n         else\n       {\n             finalMove = true;\n          }\n           call_function_after_time(moveMainDown,velocity);\n        return true;\n     }\n    }\n\n  function moveFigUp()\n {\n       for(local i = 0;i < 4;i++)\n      {\n          pieces[i].moveStepUp();\n     }\n       initialP += 10;\n  }\n\n  function canMoveToPos(nPos,nRot)\n {\n       local index = 0;\n    \n    local y = []; \n      for(local i = 0; i < 4;i++)\n     {\n          index = pieces[i].pieceIndex + nPos;\n       if(index < 0)\n          {\n             return false;\n          }\n\n        if(gridFlags[index] == true)\n       {\n             return false;\n          }\n       }\n       return true;\n }\n}\n\nfunction down() \n{\n  for(local i=0; i<4; i++)\n {\n       pieces[i].moveStepDown();\n    }\n}\n\n\nfunction init()\n{\n velAux = 0;\n  bGround = load_asset(1,false);\n    move_asset(bGround,width*0.5,height*0.5);\n\n  header = load_asset(2,false);\n    move_asset(header,width*0.5,height*0.07);\n\n   iScore = load_asset(3,false);\n    move_asset(iScore,width*0.2,height*0.07);\n\n   nextP = load_asset(4,false);\n    move_asset(nextP,width*0.79,height*0.06);\n\n    local tempP = load_asset(10,false);\n    pieceSize = asset_get_height(tempP);\n    \n   for(local i = 0;i < 7;i++)\n   {\n       littleImg.push(load_asset(20+i,false));\n     move_asset(littleImg[i],width*0.79,height*0.11);\n }\n\n    initializeGrids();\n    velAux = velocity;\n}\n\nfunction start_level(level_num)\n{\n clearGrid();\n nextID = random_int(10,16);\n  nextID = 15;\n    mainFig = Figure(random_int(10,16),165);\n   score = 0;\n   velocity = 500;\n  pause = false;\n    enterCol = false;\n    call_function_after_time(moveMainDown,500);\n}\n\nfunction update()\n{\n}\n\nfunction draw()\n{\n    draw_asset(bGround);\n    if(mainFig != null)\n    {\n     for(local i = 0; i < 4;i++)\n      {\n           draw_asset(mainFig.pieces[i].img);\n       }\n    }\n    foreach (val in allPieces) \n    {\n     if(val.img != null)\n      {\n           draw_asset(val.img);\n     }\n    }\n    draw_asset(header);\n    draw_asset(iScore);\n    draw_asset(nextP);\n   draw_text(width*0.2,height*0.101 ,2,score);\n    draw_asset(littleImg[nextID-10]);\n}\n\nfunction get_arrow_keys(key, state) \n{\n if(!mainFig.canMove || oneTouch)\n {\n       oneTouch = false;\n       return;\n  }\n\n  if(state == 1 && key == 2)\n   {\n       mainFig.rotateFigure();\n  }\n    if(state == 1 && key == 1)\n   {\n       mainFig.moveFigSide(true);\n   }\n    if(state == 1 && key == 0)\n   {\n       mainFig.moveFigSide(false);\n  }\n    if(state == 1 && key == 3)\n   {\n       previousVel = velocity;\n     velocity = 50;\n      return;\n  }\n}\nfunction touch_start(pos_x, pos_y)\n{    \n initialTouch.x  = pos_x;\n initialTouch.y  = pos_y;   \n touchTime = get_time();\n}\n\nfunction touch_move(pos_x,pos_y)\n{\n  if(!mainFig.canMove)\n  {\n    return;\n  }\n  local previousPosX = mainFig.pieces[0].pPos.x;\n  mainFig.moveToXposition(pos_x);\n  if(previousPosX != mainFig.pieces[0].pPos.x)\n  {\n    play_effect(2);\n  }\n}\n\nfunction touch_end(pos_x,pos_y)\n{\n  if(!mainFig.canMove)\n  {\n    return;\n  }\n  local deltaY = abs(initialTouch.y - pos_y);\n  if(deltaY > 50)\n  {\n    if(get_time() < (touchTime+swipeTime))\n    {\n        previousVel = velocity;\n        velocity = 50;\n    }\n  }\n  else if(get_time() < (touchTime+tapTime))\n  {\n      play_effect(1);\n    mainFig.rotateFigure();\n  }\n}\n\nfunction moveMainDown()\n{\n   local tempFl = mainFig.moveFigDown();\n\n  if(!tempFl)\n  {\n       setPiecesOnGrid();\n      call_function_after_time(checkLines,500);\n       call_function_after_time(createNfig,1000);\n   }\n}\n\nfunction initializeGrids()\n{\n    local initX = 20;\n    local initY = 1279;\n  local count = 1;\n local shps = [];\n\n   for(local i = 0;i < 200;i++,count++)\n {\n       allPieces.push(Piece());\n    gridPos.push(vector_2());\n       gridFlags.push(false);\n\n    gridPos[i].x = initX + (pieceSize*0.5);\n     initX += pieceSize;\n     gridPos[i].y = initY - (pieceSize*0.5);\n     if(count == 10)\n     {\n          initX = 20;\n        initY -= pieceSize;\n        count = 0;\n      }\n    }\n}\n\n\nfunction haveLost()\n{\n for (local i = 0;i  < 10;i++) \n   {\n       if(gridFlags[160+i] == true)\n    {\n          pause = true;\n          save_highscore_gameover(score);\n        restart();\n      }\n    }\n}\n\nfunction checkLines()\n{\n if(pause)\n    {\n       return;\n  }\n    mainFig = Figure(nextID,175);\n    oneTouch = false;\n    velocity = velAux;\n  if(searchForALine())\n {\n       PushDown();\n  }\n    haveLost();\n}\n\nfunction createNfig()\n{\n   if(pause)\n    {\n       return;\n  }\n    nextID = random_int(10,16);\n\n    if(flgvel) \n  {\n       velAux -= 50;\n       flgvel = false;\n  } \n   else \n    {\n       velocity = velAux;\n   }\n    enterCol = false;\n    call_function_after_time(moveMainDown,1000);\n}\n\nfunction setPiecesOnGrid()\n{\n   local j = mainFig.curRotation * 8;\n   local index = 0;\n\n   mainFig.canMove = false;\n\n   for(local i = 0; i < 4;i++,j+=2)\n {\n       index = mainFig.pieces[i].pieceIndex;\n       allPieces[index] = mainFig.pieces[i];\n       gridFlags[index] = true;\n }\n}\n\nfunction searchForALine()\n{\n local count = 1;\n local inARow = 0;\n    local fnFlag = false;\n\n  for(local i = 0;i < 200;i++,count++)\n {\n       if(gridFlags[i] == true)\n    {\n          inARow++;\n       }\n       if(count == 10)\n     {\n          count = 0;\n         if(inARow == 10)\n       {\n             destroyLine(i-9);\n             score += 10;\n          play_effect(3);\n          if(score%50 == 0 && score != 0)\n           {\n\n              previousVel = velocity;\n              flgvel = true;\n            }\n             fnFlag = true;\n         }\n          inARow = 0;\n     }\n    }\n    return fnFlag;\n}\n\nfunction destroyLine(index)\n{\n  for (local i = index;i < index+10;i++) \n  {\n       if(gridFlags[i] == true)\n    {\n          allPieces[i].destroyPiece();\n       allPieces[i] = null;\n       allPieces[i] = Piece();\n        gridFlags[i] = false;\n       }\n    }\n}\n\nfunction PushDown()\n{\n   local count = 1;\n local inARow = 0;\n    local pushCount = 0;\n\n   for(local i = 0;i < 200;i++,count++)\n {\n       if(gridFlags[i] == false)\n       {\n          inARow++;\n       }\n       if(count == 10)\n     {\n          count = 0;\n         if(inARow == 10)\n       {\n             pushCount++;\n       }\n          else if(pushCount > 0)\n         {\n             removeAndDestroy(i-9,pushCount);\n       }\n          inARow = 0;\n     }\n    }\n}\n\nfunction removeAndDestroy(index,rows)\n{\n local i = index-(10*rows);\n   local j = index;\n\n   for (;j < index+10;j++,i++) \n {\n       if(gridFlags[j] == true)\n    {\n          gridFlags[i] = gridFlags[j];\n       allPieces[i].create(allPieces[j].ID,i);\n        allPieces[i].movePieceTo(gridPos[i].x,gridPos[i].y,i);\n      }\n    }\n    destroyLine(index);\n}\n\nfunction restart()\n{    \n      play_effect(4);\n goto_menu_after_ms(\"gameOver\",1000);\n}\n\nfunction clearGrid()\n{\n for(local i = 0;i < 200;i++)\n {\n       allPieces[i].destroyPiece();\n    gridFlags[i] = false;\n    }  \n}"
  }, {
    "name": "Planet",
    "projectID": 1313,
    "gameID": 1313,
    "script": "local width = 720;\nlocal height = 1280;\n\nlocal backGround;\nlocal population;\nlocal heart = [];\nlocal eHeart = [];\n\nlocal populationRadius = 0;\nlocal minSpawn = 2;\nlocal maxSpawn = 5;\nlocal populationVel = 2;\nlocal score = 0;\nlocal lifes = 6;\nlocal laserFlag = false;\nlocal animStart = false;\nlocal startShape;\nlocal finishShape;\nlocal killShape;\n\nlocal characters = [];\nlocal objToProtect;\n\nlocal HUDScore;\nlocal HUDBackground;\n\nlocal maxLevel = 3;\nlocal level = 0;\nlocal levelScore = [500,1000,2000];\n\nlocal showLevelText = false;\nlocal showLoseText = false;\nlocal showWinText = false;\nlocal hud_color = make_rgba(0, 0, 0, 255);\n\nlocal isAnimating = false;\nlocal isGoingDown = false;\nlocal animScale = 1;\n\nlocal glint;\n\nlocal player;\n\nlocal loseImg;\nlocal wonImg;\nlocal levelImg;\n\nlocal currSpawn = 0;\n\nclass Matrix3X3\n{\n    constructor()\n    {\n       elements = [0,0,0,0,0,0,0,0,0];\n  }\n\n  elements = null;\n\n   function identity()\n  {\n       local result = Matrix3X3();\n     result.elements[0] = 1;result.elements[1] = 0;result.elements[3] = 0;\n       result.elements[3] = 0;result.elements[4] = 1;result.elements[5] = 0;\n       result.elements[6] = 0;result.elements[7] = 0;result.elements[8] = 1;\n       return result;\n   }\n\n  function inverse()\n   {\n       local det = (elements[0]*((elements[4]*elements[8])-(elements[7]*elements[5]))) - (elements[1]*((elements[3]*elements[8])-(elements[6]*elements[5]))) + (elements[2]*((elements[3]*elements[7])-(elements[6]*elements[4])));\n    local trans = Matrix3X3();\n      local result = Matrix3X3();\n\n       trans = transpuesta();\n      result.elements[0] = (trans.elements[4]*trans.elements[8])-(trans.elements[7]*trans.elements[5]);\n       result.elements[1] = (trans.elements[3]*trans.elements[8])-(trans.elements[6]*trans.elements[5]);\n       result.elements[2] = (trans.elements[3]*trans.elements[7])-(trans.elements[6]*trans.elements[4]);\n       result.elements[3] = (trans.elements[2]*trans.elements[8])-(trans.elements[7]*trans.elements[2]);\n       result.elements[4] = (trans.elements[0]*trans.elements[8])-(trans.elements[6]*trans.elements[2]);\n       result.elements[5] = (trans.elements[0]*trans.elements[7])-(trans.elements[6]*trans.elements[1]);\n       result.elements[6] = (trans.elements[1]*trans.elements[5])-(trans.elements[4]*trans.elements[2]);\n       result.elements[7] = (trans.elements[0]*trans.elements[5])-(trans.elements[3]*trans.elements[2]);\n       result.elements[8] = (trans.elements[0]*trans.elements[4])-(trans.elements[3]*trans.elements[1]);\n\n     result.elements[0] *= 1;\n    result.elements[1] *= -1;\n       result.elements[2] *= 1;\n    result.elements[3] *= -1;\n       result.elements[4] *= 1;\n    result.elements[5] *= -1;\n       result.elements[6] *= 1;\n    result.elements[7] *= -1;\n       result.elements[8] *= 1;\n\n      result.scalarDivition(det);\n     return result;\n   }\n\n  function transpuesta()\n   {\n       local result = Matrix3X3();\n     result.elements[0] = elements[0];\n       result.elements[1] = elements[3];\n       result.elements[2] = elements[6];\n       result.elements[3] = elements[1];\n       result.elements[4] = elements[4];\n       result.elements[5] = elements[7];\n       result.elements[6] = elements[2];\n       result.elements[7] = elements[5];\n       result.elements[8] = elements[8];\n       return result;\n   }\n\n  function scalarMultiply(scalar)\n  {\n       for(local i = 0;i < elements.len();i++)\n     {\n          elements[i] *= scalar;\n      }\n    }\n\n  function scalarDivition(scalar)\n  {\n       for(local i = 0;i < elements.len();i++)\n     {\n          elements[i] /= scalar;\n      }\n    }\n\n  function matrix1x3Multiply(matrix)\n   {\n       local result = Matrix3x1();\n     result.elemnt1 = (matrix.elemnt1*elements[0]) + (matrix.elemnt2*elements[3]) + (matrix.elemnt3*elements[6]);\n    result.elemnt2 = (matrix.elemnt1*elements[1]) + (matrix.elemnt2*elements[4]) + (matrix.elemnt3*elements[7]);\n    result.elemnt3 = (matrix.elemnt1*elements[2]) + (matrix.elemnt2*elements[5]) + (matrix.elemnt3*elements[8]);\n    return result;\n   }     \n\n   function matrix3x3Multiply(matrix)\n   {\n       local result = Matrix3X3();\n     result.elements[0] = (elements[0]*matrix.elements[0]) + (elements[1]*matrix.elements[3]) + (elements[2]*matrix.elements[6]);\n    result.elements[1] = (elements[0]*matrix.elements[1]) + (elements[1]*matrix.elements[4]) + (elements[2]*matrix.elements[7]);\n    result.elements[2] = (elements[0]*matrix.elements[2]) + (elements[1]*matrix.elements[5]) + (elements[2]*matrix.elements[8]);\n    result.elements[3] = (elements[3]*matrix.elements[0]) + (elements[4]*matrix.elements[3]) + (elements[5]*matrix.elements[6]);\n    result.elements[4] = (elements[3]*matrix.elements[1]) + (elements[4]*matrix.elements[4]) + (elements[5]*matrix.elements[7]);\n    result.elements[5] = (elements[3]*matrix.elements[2]) + (elements[4]*matrix.elements[5]) + (elements[5]*matrix.elements[8]);\n    result.elements[6] = (elements[6]*matrix.elements[0]) + (elements[7]*matrix.elements[3]) + (elements[8]*matrix.elements[6]);\n    result.elements[7] = (elements[6]*matrix.elements[1]) + (elements[7]*matrix.elements[4]) + (elements[8]*matrix.elements[7]);\n    result.elements[8] = (elements[6]*matrix.elements[2]) + (elements[7]*matrix.elements[5]) + (elements[8]*matrix.elements[8]);\n    return result;\n   }\n\n  function MatrixTranslation(rVec2)\n    {\n       local result = Matrix3X3();\n     result.elements[0] = 1;result.elements[1] = 0;result.elements[3] = 0;\n       result.elements[3] = 0;result.elements[4] = 1;result.elements[5] = 0;\n       result.elements[6] = rVec2.x;result.elements[7] = rVec2.y;result.elements[8] = 1;\n       return result;    \n }\n\n  function MatrixRotation(angle)\n   {\n       local result = Matrix3X3();\n     result.elements[0] = cos(angle);result.elements[1] = sin(angle);result.elements[3] = 0;\n     result.elements[3] = -sin(angle);result.elements[4] = cos(angle);result.elements[5] = 0;\n    result.elements[6] = 0;result.elements[7] = 0;result.elements[8] = 1;\n       return result;    \n }\n}\n\nclass Matrix3x1\n{\n   constructor()\n    {\n       elemnt1 = 0;elemnt2 = 0;elemnt3 = 0;\n }\n\n  elemnt1 = null;\n  elemnt2 = null;\n  elemnt3 = null;\n\n    function fromVector2(vec2)\n   {\n       elemnt1 = vec2.x;\n       elemnt2 = vec2.y;\n       elemnt3 = 1;\n }\n\n  function toVector2()\n {\n       local nVec2 = vector_2();\n       nVec2.x = elemnt1;\n      nVec2.y = elemnt2;\n      return nVec2;\n    }  \n}\n\nclass Transform\n{\n    constructor()\n    {\n       children = [];\n      localPos = vector_2();\n      localRot = 0.0;\n  }\n\n  parent = null;\n   children = null;\n localPos = null;\n localRot = null;\n\n   function getTransformMatrix()\n    {\n       local MatTransXPos = Matrix3X3();\n       local MatRot = Matrix3X3();\n     local result = Matrix3X3();\n\n       MatTransXPos = MatTransXPos.MatrixTranslation(localPos);\n    MatRot = MatRot.MatrixRotation(localRot);\n\n     return MatRot.matrix3x3Multiply(MatTransXPos);\n   }\n\n  function getWorldMatrix()\n    {\n       local result = Matrix3X3();\n     result = getTransformMatrix();\n      if(parent != null)\n      {\n          result = result.matrix3x3Multiply(parent.getWorldMatrix());\n     }\n       return result;\n   }\n\n  function setLocalPos(nVec2)\n  {\n       localPos.x = nVec2.x;\n       localPos.y = nVec2.y;\n    }\n\n  function getPosOnWorld()\n {\n       local resVec2 = vector_2();\n     local tempMat = Matrix3X3();\n    tempMat = getWorldMatrix();\n     resVec2.x = tempMat.elements[6];\n    resVec2.y = tempMat.elements[7];\n    return resVec2;\n  }\n\n  function getLocalPos()\n   {\n       return localPos;\n }\n\n  function setLocalRot(nRot)\n   {\n       localRot = nRot;\n }\n\n  function getLocalRot()\n   {\n       return localRot;\n }\n\n  function getLocalRotOnWorld()\n    {  \n    local rotFloat = 0.0;\n       local tempMat = Matrix3X3();\n    tempMat = getWorldMatrix();\n     rotFloat = atan2(tempMat.elements[0],tempMat.elements[3]);\n      return rotFloat;\n }\n\n  function moveTransformTo(nPos)\n   {\n       setLocalPos(nPos);\n   }\n\n  function rotateTransformTo(nAng)\n {\n       setLocalRot(nAng);\n   }\n\n  function getUpVector()\n   {\n       local nVec2 = vector_2();\n       local rot = getLocalRotOnWorld();\n\n     nVec2.x = cos(rot);\n     nVec2.y = sin(rot);\n     return nVec2;\n    }\n\n  function getRightVector()\n    {\n       local nVec2 = vector_2();\n       local rot = getLocalRotOnWorld();\n       rot += (90*180)/PI;\n\n       nVec2.x = cos(rot);\n     nVec2.y = sin(rot);\n     return nVec2;\n    }\n}\n\nclass gameTransform extends Transform\n{\n constructor()\n    {\n       base.constructor();\n  }\n\n  asset = null;\n    shape = null;\n    hasAsset = null;\n hasShape = null;\n\n   function moveTo(nPos)\n    {\n       moveTransformTo(nPos);\n      move();\n  }\n\n  function move()\n  {\n       local nVec2;\n    nVec2 = getLocalPos();\n      nVec2 = getPosOnWorld();\n    if(hasAsset)\n    {\n          move_asset(asset,nVec2.x,nVec2.y);\n      }\n       if(hasShape)\n    {\n          phy_move_shape(shape,nVec2.x,nVec2.y);\n      }\n       for(local i = 0;i < children.len();i++)\n     {\n          children[i].move();\n     }\n    }\n\n  function rotateTo(nAng)\n  {\n       local angle = ((nAng*PI)/180);\n      rotateTransformTo(angle);\n       rotate();\n    }\n\n  function rotate()\n    {\n       local angle = getLocalRotOnWorld();\n     angle = ((angle*180)/PI)-90;\n    if(hasAsset)\n    {\n          rotate_asset(asset,angle);\n      }\n       if(hasShape)\n    {\n          phy_shape_set_angle(shape,angle);\n       }\n       for(local i = 0;i < children.len();i++)\n     {\n          children[i].rotate();\n          children[i].move();\n     }\n\n  }\n\n  function setAsset(nAsset)\n    {\n       asset = nAsset;\n     move_asset(asset,-width,-height);\n       hasAsset = true;\n }\n\n  function setShape(nShape)\n    {\n       shape = nShape;\n     hasShape = true;\n }\n}\n\nclass Population extends gameTransform\n{\n    constructor()\n    {\n       base.constructor();\n     populationAngle = 0;\n }\n\n  populationAngle = null;\n\n    function rotatePopulation()\n  {\n       population.rotateTo(populationAngle);\n       populationAngle += populationVel;\n       if(populationAngle == 360)\n      {\n          populationAngle = 0;\n    }\n    }\n}\n\nclass Character extends gameTransform\n{\n constructor()\n    {\n       base.constructor();\n\n       isAvailable = true;\n     isSpawned = false;\n      runAnim = false;\n      wasDestroyed = false;\n    dist = 0;\n       assets = [];\n    charID = 0;\n\n       rotateTo(180);\n   }\n\n  isAvailable = null;\n  isSpawned = null;\n    runAnim = null;\n  dist = null;\n assets = null;\n   charID = null;\n   wasDestroyed = null;\n\n function goDown(dist = 2)\n    {\n       local nVec2 = getLocalPos();\n    nVec2.y -= dist;\n    moveTo(nVec2);\n   }\n\n  function goUP(dist = 2)\n  {\n       local nVec2 = getLocalPos();\n    nVec2.y += dist;\n    moveTo(nVec2);\n    wasDestroyed = false;\n   }\n\n  function spawn()\n {\n       if(dist < 90)\n       {\n          goUP(31);\n          dist += 31;\n     }\n       else\n    {\n          runAnim = false;\n    }\n    }\n\n  function destroy()\n   {\n       if(dist > 0)\n    {\n          goDown(31);\n        dist -= 31;\n\n       }\n       else\n    {\n          runAnim = false;\n    }\n    }\n\n  function changeID(nID)\n   {\n       charID = nID;\n       setAsset(assets[charID]);\n    }\n\n  function drawAsset()\n {\n       return assets[charID];\n   }\n}\n\nclass ToProtect extends gameTransform\n{\n constructor()\n    {\n       base.constructor();\n\n       assets.push(load_asset(11,false));\n      assets.push(load_asset(12,false));\n      assets.push(load_asset(13,false));\n      assets.push(load_asset(14,false));\n\n    local nVec2 = vector_2();\n       nVec2.x = width*0.293;\n      nVec2.y = height*(-0.12);\n       moveTo(nVec2);\n\n    changeID(0);\n\n      parent = gameTransform();\n       parent.setAsset(load_asset(2,false));\n       parent.children.push(this);\n     nVec2.x = width*0.5;\n    nVec2.y = height*0.5;\n       parent.moveTo(nVec2);\n\n     startShape = gameTransform();\n       parent.children.push(startShape);\n       startShape.parent = parent;\n     startShape.setShape(phy_create_rect_shape(0,0,10,10,false));\n    phy_shape_set_collision_type(startShape.shape,3);\n       phy_set_sensor(startShape.shape,true);\n      nVec2.x = width*0.15;\n       nVec2.y = height*(-0.11);\n       startShape.moveTo(nVec2);\n\n     finishShape = gameTransform();\n      parent.children.push(finishShape);\n      finishShape.parent = parent;\n    finishShape.setShape(phy_create_rect_shape(0,0,10,10,false));\n       phy_shape_set_collision_type(finishShape.shape,3);\n      phy_set_sensor(finishShape.shape,true);\n     nVec2.x = width*0.28;\n       nVec2.y = height*(-0.01);\n       finishShape.moveTo(nVec2);\n\n    killShape = gameTransform();\n    parent.children.push(killShape);\n    killShape.parent = parent;\n      killShape.setShape(phy_create_rect_shape(0,0,10,10,false));\n     phy_shape_set_collision_type(killShape.shape,4);\n    phy_set_sensor(killShape.shape,true);\n       nVec2.x = width*0.32;\n       nVec2.y = height*(-0.12);\n       killShape.moveTo(nVec2);\n }\n\n  assets = [];\n charID = 0;\n  rotationSteps = 1;\n   currentRot = 0;\n\n    function livesChanged()\n  {\n       switch(lifes)\n       {\n          case(6):\n          objToProtect.changeID(0);\n          break;\n         case(5):\n          objToProtect.changeID(1);\n          break;\n         case(3):\n          objToProtect.changeID(2);\n          break;\n         case(1):\n          objToProtect.changeID(3);\n          break;\n      }\n    }\n\n  function changeID(nID)\n   {\n       charID = nID;\n       setAsset(assets[charID]);\n       moveTo(getLocalPos());\n      rotateTo(60);\n    }\n\n  function drawAsset()\n {\n       return assets[charID];\n   }\n\n  function resetGame()\n {\n       livesChanged();\n\n       parent.rotateTo(0);\n\n       currentRot = 0;\n  }\n\n  function  rotationOfPlanet()\n {\n       currentRot += rotationSteps;\n    parent.rotateTo(currentRot);\n\n      if(currentRot == 360)\n       {\n          currentRot = 0;\n     }\n    }\n}\n\nclass Player extends gameTransform\n{\n    constructor()\n    {\n       base.constructor();\n\n       local nVec2 = vector_2();\n       nVec2.x = width*0.5;\n    nVec2.y = height*0.5;\n       moveTo(nVec2);\n\n    spaceShip = gameTransform();\n    shipLaser = gameTransform();\n    shipLaserShooted = gameTransform();\n\n       children.push(spaceShip);\n       spaceShip.parent = this;\n    spaceShip.setAsset(load_asset(4,false));\n    nVec2.x = 0;\n    nVec2.y = height*(-0.27);\n       spaceShip.moveTo(nVec2);\n\n      children.push(shipLaser);\n       shipLaser.parent = this;\n    shipLaser.setAsset(load_asset(5,false));\n    shipLaser.setShape(phy_create_shape_for_asset(shipLaser.asset,false));\n      phy_shape_set_collision_type(shipLaser.shape,4);\n    phy_set_sensor(shipLaser.shape,true);\n       nVec2.x = -1000;\n    nVec2.y = -1000;\n    shipLaser.moveTo(nVec2);\n\n      children.push(shipLaserShooted);\n    shipLaserShooted.parent = this;\n     nVec2.x = 0;\n    nVec2.y = height*(-0.22);\n       shipLaserShooted.moveTo(nVec2);\n  }\n\n  spaceShip = null;\n    shipLaser = null;\n    shipLaserShooted = null;\n rotationSteps = 7;\n   currentRot = 0;\n\n    function  rotateRight()\n  {\n       currentRot += rotationSteps;\n    rotateTo(currentRot);\n\n     if(currentRot == 360)\n       {\n          currentRot = 0;\n     }\n    }\n\n  function  rotateLeft()\n   {\n       currentRot -= rotationSteps;\n    rotateTo(currentRot);\n\n     if(currentRot == 360)\n       {\n          currentRot = 0;\n     }\n    }\n\n  function reset()\n {\n       rotateTo(0);\n\n      currentRot = 0;\n  }\n}\n\nfunction init()\n{\n   local nVec2 = vector_2();\n\n  backGround = load_asset(1,false);\n    move_asset(backGround,width*0.5,height*0.5);\n\n   HUDScore = load_asset(9,false);\n move_asset(HUDScore,width*0.79,height*0.04);\n\n   HUDBackground = load_asset(17,false);\n move_asset(HUDBackground,width*0.5,asset_get_height(HUDBackground)*0.5);\n\n   loseImg = load_asset(15,false);\n  move_asset(loseImg,width*0.5,height*0.5);\n\n  wonImg = load_asset(15,false);\n   move_asset(wonImg,width*0.5,height*0.5);\n\n   glint = load_asset(21,false);\n\n  local posX = 0;\n\n    for(local i = 0;i < lifes;i++)\n   {\n      heart.push(load_asset(3,false));\n      move_asset(heart[i],(width*0.06)+posX,height*0.04);\n      eHeart.push(load_asset(6,false));\n      move_asset(eHeart[i],(width*0.06)+posX,height*0.04);\n      posX += asset_get_width(heart[i]) + 3;\n   }\n\n  population = Population();\n   population.setAsset(load_asset(2,false));\n    nVec2.x = width * 0.5;nVec2.y = height * 0.5;\n    population.moveTo(nVec2);\n    populationRadius = asset_get_height(population.asset) * 0.5;\n\n   player = Player();\n\n phy_create_collision_handler_begin(1,3,changeAvailable);\n phy_create_collision_handler_begin(2,3,changeAvailable);\n phy_create_collision_handler_begin(1,4,destroyCharacter);\n    phy_create_collision_handler_begin(2,4,destroyCharacter);\n\n  objToProtect = ToProtect();\n}\n\nfunction start_level(level_num)\n{   \n   for(local i = 0;i < 24;i++)\n  {\n    population.children.push(gameTransform());\n    population.children[i].parent = population;\n    characters.push(Character());\n    population.children[i].children.push(characters[i]);\n    population.children[i].children[0].parent = population.children[i];\n    characters[i].assets.push(load_asset(20,false));\n    characters[i].assets.push(load_asset(10,false));\n    characters[i].assets.push(load_asset(7,false));\n    characters[i].assets.push(load_asset(8,false));\n    characters[i].setShape(phy_create_shape_for_asset(characters[i].assets[0],true));\n    phy_shape_set_collision_type(characters[i].shape,1);\n    move_asset(characters[i].assets[0],-width,-height);\n  }\n  showLevelText = true;\n  showLoseText = false;\n  showWinText = false;\n  call_function_after_time(turnOffText,1000);\n\n  setCharacters();\n  call_function_after_time(myStart,3000);\n\n  objToProtect.resetGame();\n\n  player.reset();\n  local tempVec = player.spaceShip.getPosOnWorld();\n  move_asset(glint,tempVec.x,tempVec.y);\n  setLevel();\n  waveTimer();\n\n  lifes = 6;\n  score = 0;\n  ToProtect.livesChanged();\n}\n\nfunction waveTimer()\n{\n   generateWave();\n  call_function_after_time(waveTimer,2500);\n}\n\nfunction glintAnimation()\n{\n  if(isGoingDown)\n  {\n    animScale -= 0.1;\n    if(animScale < 0.5)\n    {\n      isGoingDown = false;\n      isAnimating = false;\n      return;\n    }\n  }\n  else\n  {\n    animScale += 0.1;\n    if(animScale > 2)\n    {\n      isGoingDown = true;\n    }\n  }\n  local tempVec = player.spaceShip.getPosOnWorld();\n  move_asset(glint,tempVec.x,tempVec.y);\n  asset_set_scale(glint,animScale,animScale);\n  call_function_after_time(glintAnimation,50);\n}\n\nlocal framNum = 0;\n\nfunction update()\n{\n  if(animStart)\n  {\n    animAdmin();\n    framNum++;\n  local tempVec = player.spaceShip.getPosOnWorld();\n    move_asset(glint,tempVec.x,tempVec.y);\n  }\n}\n\nfunction animAdmin()\n{\nif(animStart)\n{\n  switch(framNum)\n  {\n  case(1):\n    population.rotatePopulation();\n  break;\n  case(2):\n    objToProtect.rotationOfPlanet();\n  break;\n  case(3):\n    for(local i = 0;i < characters.len();i++)\n    {\n      if(characters[i].runAnim)\n      {\n        if(characters[i].isSpawned)\n        {\n          characters[i].spawn();\n        }\n        else\n        {\n          characters[i].destroy();\n        }\n      }\n    }\n  break;\n  default:\n    framNum = 0;\n  break;\n  }\n}\n}\n\nfunction draw()\n{\n   draw_asset(backGround);\n   draw_asset(HUDBackground);\n  for(local i = 0;i < characters.len();i++)\n    {\n       draw_asset(characters[i].drawAsset());\n   }\n    draw_asset(objToProtect.parent.asset);\n   for(local k = 0;k < eHeart.len();k++)\n    {\n       draw_asset(eHeart[k]);\n   }\n    for(local j = 0;j < lifes;j++)\n   {\n       draw_asset(heart[j]);\n    }\n    if(laserFlag)\n    {\n       draw_asset(player.shipLaser.asset);\n  }\n    if(isAnimating)\n  {\n       draw_asset(glint);\n   }\n    draw_asset(player.spaceShip.asset);\n  draw_asset(objToProtect.drawAsset());\n    draw_asset(HUDScore);\n   if(score.tostring().len() < 4)\n   {\n       draw_text(width * 0.64,height*0.024,2,\"Score   \"+score);\n   }\n    else\n {\n       local tempScore = score.tostring().slice(0,score.tostring().len()-3);\n       tempScore += \",\"\n      tempScore += score.tostring().slice(score.tostring().len()-3);\n      draw_text(width * 0.64,height*0.024,2,\"Score   \"+tempScore);\n   }\n\n  if(showLevelText)\n    {\n       draw_asset(levelImg);\n    }\n    if(showLoseText)\n {\n       draw_asset(loseImg);\n }\n    if(showWinText)\n  {\n       draw_asset(wonImg);\n  }\n}\n\nfunction  setLevel()\n{\n  switch(level)\n    {\n       case(0):\n       levelImg = load_asset(22,false);\n    break;\n      case(1):\n       levelImg = load_asset(23,false);\n    break;\n      case(2):\n       levelImg = load_asset(24,false);\n    break;\n      case(3):\n       levelImg = load_asset(25,false);\n    break\n       case(4):\n       levelImg = load_asset(26,false);\n    break;\n   }\n\n  move_asset(levelImg,width*0.5,height*0.5);\n}\n\nfunction turnOffText()\n{\n   showLevelText = false;\n   showLoseText = false;\n    showWinText = false;\n}\n\nfunction myStart()\n{\n animStart = true;\n    currSpawn = 0;\n}\n\nfunction touch_start(pos_x,pos_y) \n{\n  laserFlag = true;\n  player.shipLaser.moveTo(player.shipLaserShooted.getLocalPos());\n  play_effect(1);\n  call_function_after_time(removeLaser,100);\n}\n\nfunction get_arrow_keys(key, state) \n{\n if(state == 1 && key == 1)\n   {\n       player.rotateRight();\n    }\n    if(state == 1 && key == 0)\n   {\n       player.rotateLeft();\n }\n}\n\nfunction on_accelerometer_update(x,y,z) \n{\n  if(animStart)\n    {\n       if(x > 0.3)\n       {\n          player.rotateRight();\n       }\n       if(x < -0.3)\n      {\n          player.rotateLeft();\n    }\n    }\n}\n\nfunction removeLaser()\n{\n    laserFlag = false;\n   local nVec2 = vector_2();\n    nVec2.x = -1000;\n nVec2.y = -1000;\n player.shipLaser.moveTo(nVec2);\n}\n\nfunction setCharacters()\n{\n    local angle = 90;\n    local radANg = 0.0;\n  local nVec2 = vector_2();\n    local mySize = asset_get_height(characters[0].assets[0]);\n    local nHipo = (populationRadius+(mySize*0.5));\n\n for(local i = 0;i < characters.len();i++)\n    {\n       radANg = (angle*PI)/180;\n    nVec2.x = cos(radANg) * nHipo;\n      nVec2.y = sin(radANg) * nHipo;\n      population.children[i].rotateTo(angle-90);\n      population.children[i].moveTo(nVec2);\n       characters[i].goDown(100);\n      angle += 15;\n }\n}\n\nfunction changeAvailable(shape_1,shape_2)\n{\n local i = 0;\n for(i = 0;i < characters.len();i++)\n  {\n       if(compare_shapes(shape_1,characters[i].shape))\n     {\n          if(compare_shapes(shape_2,startShape.shape))\n       {\n             characters[i].isAvailable = false;\n            break;\n         }\n          else\n       {\n             characters[i].isAvailable = true;\n             break;\n         }\n       }\n    }\n}\n\nfunction generateWave()\n{\n   local possibilities = [];\n    local rdm = 0;\n   local rdm2 = 0;\n\n    for(local i = 0;i < characters.len();i++)\n    {\n       if(characters[i].isAvailable)\n       {\n          possibilities.push(i);\n      }\n    }\n\n  rdm = random_int(0,possibilities.len()-1);\n   spanCharacter(possibilities[rdm]);\n   for(local j = 1;j < minSpawn;j++)\n    {\n       rdm2 = random_int(1,4);\n     rdm += rdm2;\n    if(rdm < possibilities.len())\n       {\n          spanCharacter(possibilities[rdm]);\n      }\n    }\n    for(local k = 0;k < possibilities.len();k++)\n {\n       if(currSpawn == maxSpawn)\n       {\n          break;\n      }\n       rdm2 = random_int(0,100);\n       if(rdm2 > 70)\n       {\n          spanCharacter(possibilities[k]);\n    }\n    }\n}\n\nfunction spanCharacter(index)\n{\n if(currSpawn == maxSpawn) return;\n    local rdm = random_int(1,100);\n   if(rdm < 55)\n {\n       if(characters[index].isSpawned == false)\n    {\n          characters[index].isSpawned = true;\n        characters[index].runAnim = true;\n          if(rdm < 25)\n       {\n             characters[index].changeID(2); \n       }\n          else\n       {\n             characters[index].changeID(0);\n         }\n          currSpawn++;\n    }\n    }\n    else\n {\n       if(characters[index].isSpawned == false)\n    {\n          characters[index].isSpawned = true;\n        characters[index].runAnim = true;\n          if(rdm < 60)\n       {\n             characters[index].changeID(3);\n         }\n          else\n       {\n             characters[index].changeID(1);\n         }\n          currSpawn++;\n    }\n    }\n}\n\nfunction destroyCharacter(shape_1,shape_2)\n{\n    currSpawn--;\n if(compare_shapes(shape_2,player.shipLaser.shape))\n   {\n       for(local i = 0;i < characters.len();i++)\n       {\n          if(compare_shapes(characters[i].shape,shape_1) && characters[i].isSpawned)\n         {\n              if(!characters[i].wasDestroyed)\n              {\n                characters[i].wasDestroyed = true;\n                characters[i].isSpawned = false;\n                characters[i].runAnim = true;\n                if(characters[i].charID == 0)\n                {\n                  lifes--;\n                  play_effect(2);\n                }\n                else\n                {\n                  if(characters[i].charID == 2)\n                  {\n                    score += 25;\n                  }\n                  else if(characters[i].charID == 1)\n                  {\n                    score += 10;\n                  }\n                  else if(characters[i].charID == 3)\n                  {\n                    if(lifes < 6)\n                    {\n                     lifes++;\n                    }\n                  }\n                }\n             }\n             break;\n         }\n       }\n    }\n    else\n {\n       for(local i = 0;i < characters.len();i++)\n       {\n          if(compare_shapes(characters[i].shape,shape_1))\n        {\n              if(!characters[i].wasDestroyed)\n              {\n                characters[i].wasDestroyed = true;\n                characters[i].isSpawned = false;\n                characters[i].runAnim = true;\n                if(characters[i].charID == 0)\n                {\n                  score += 1;\n                  play_effect(3);\n                  isAnimating = true;\n                  glintAnimation();\n                }\n                else if(characters[i].charID == 2 || characters[i].charID == 1)\n                {\n                  characters[i].wasDestroyed = true;\n                  lifes--;\n                  play_effect(2);\n                }\n              }\n             break;\n         }\n       }\n    }\n    if(score >= levelScore[level])\n   {\n      populationVel += 0.5;\n      minSpawn += 2;\n      maxSpawn += 2;\n      if(level < 5)\n      {\n        level++;\n        play_effect(4);\n        showLevelText = true;\n        call_function_after_time(turnOffText,1000);\n        setLevel();\n      }\n    }\n    if(lifes == 0 || level >= 3)\n   {\n       showLoseText = true;\n    call_function_after_time(turnOffText,1000);\n     gameOver();\n  }\n    else\n {\n       objToProtect.livesChanged();\n }\n}\n\nfunction gameOver()\n{\n  save_highscore_gameover(score);\n  populationVel = 2;\n  minSpawn = 2;\n  maxSpawn = 5;\n  animStart = false;\n  clear_functions_after_time();\n  play_effect(5);\n  call_function_after_time(removeScene,300);\n}\nfunction removeScene()\n{\n  local nVec2 = vector_2();\n  for(local i = 0;i < characters.len();i++)\n  {\n     phy_remove_shape(characters[i].shape);\n  }\n  characters = [];\n  population.children = [];\n  level = 0;\nremoveLaser();\n  goto_menu_after_ms(\"gameOver\",200);\n}"
  }, {
    "name": "Catch",
    "projectID": 1314,
    "gameID": 1314,
    "script": "local width = 720;\nlocal height = 1280;\n\nlocal backGround;\nlocal player;\nlocal spawner;\n\nlocal dir = 0;\nlocal currBall = 0;\nlocal cols = 9;\nlocal rows = 10;\nlocal lose = 0;\nlocal countScore = 0;\nlocal score = 0;\nlocal level = 1;\nlocal combo = 0;\nlocal step = 0;\nlocal vel = 5;\nlocal spawnVelocity = 500;\nlocal toLose = 50;\nlocal increaseDif = 300;\nlocal bonus = \"\";\nlocal movement = true;\nlocal floorShp;\nlocal rightWall;\nlocal leftWall;\nlocal gameFigures = [];\nlocal gameFigMirror = [];\nlocal balls = [];\nlocal ballShp = [];\nlocal grid = [];\nlocal pieces = [];\nlocal spawnPos = vector_2();\nlocal showPlus = vector_2();\n\nlocal goalImg;\nlocal levelImg;\nlocal loseImg;\nlocal img_levels = [];\nlocal fill_above = [];\nlocal fill_below = [];\nlocal belowCont;\nlocal aboveCont;\n\nlocal theresTouch = false;\nlocal readjusMoving = false;\nlocal leveledUp = false;\nlocal currentUpdate = 3;\nlocal updatesPerCheck = 3;\n\nlocal toLosePerLevel = [50,35,20,10];\nlocal spawnVelocityPerLevel = [700,600,500,400];\n\nlocal showLevelText = false;\nlocal showLoseText = false;\nlocal showWinText = false;\nlocal hud_color = make_rgba(0, 0, 0, 255);\n\nlocal maxBalls = 0;\nlocal spawnedBalls = 0;\n\nclass Matrix3X3\n{\n   constructor()\n    {\n       elements = [0,0,0,0,0,0,0,0,0];\n  }\n\n  elements = null;\n\n   function identity()\n  {\n       local result = Matrix3X3();\n     result.elements[0] = 1;result.elements[1] = 0;result.elements[3] = 0;\n       result.elements[3] = 0;result.elements[4] = 1;result.elements[5] = 0;\n       result.elements[6] = 0;result.elements[7] = 0;result.elements[8] = 1;\n       return result;\n   }\n\n  function inverse()\n   {\n       local det = (elements[0]*((elements[4]*elements[8])-(elements[7]*elements[5]))) - (elements[1]*((elements[3]*elements[8])-(elements[6]*elements[5]))) + (elements[2]*((elements[3]*elements[7])-(elements[6]*elements[4])));\n    local trans = Matrix3X3();\n      local result = Matrix3X3();\n\n       trans = transpuesta();\n      result.elements[0] = (trans.elements[4]*trans.elements[8])-(trans.elements[7]*trans.elements[5]);\n       result.elements[1] = (trans.elements[3]*trans.elements[8])-(trans.elements[6]*trans.elements[5]);\n       result.elements[2] = (trans.elements[3]*trans.elements[7])-(trans.elements[6]*trans.elements[4]);\n       result.elements[3] = (trans.elements[2]*trans.elements[8])-(trans.elements[7]*trans.elements[2]);\n       result.elements[4] = (trans.elements[0]*trans.elements[8])-(trans.elements[6]*trans.elements[2]);\n       result.elements[5] = (trans.elements[0]*trans.elements[7])-(trans.elements[6]*trans.elements[1]);\n       result.elements[6] = (trans.elements[1]*trans.elements[5])-(trans.elements[4]*trans.elements[2]);\n       result.elements[7] = (trans.elements[0]*trans.elements[5])-(trans.elements[3]*trans.elements[2]);\n       result.elements[8] = (trans.elements[0]*trans.elements[4])-(trans.elements[3]*trans.elements[1]);\n\n     result.elements[0] *= 1;\n    result.elements[1] *= -1;\n       result.elements[2] *= 1;\n    result.elements[3] *= -1;\n       result.elements[4] *= 1;\n    result.elements[5] *= -1;\n       result.elements[6] *= 1;\n    result.elements[7] *= -1;\n       result.elements[8] *= 1;\n\n      result.scalarDivition(det);\n     return result;\n   }\n\n  function transpuesta()\n   {\n       local result = Matrix3X3();\n     result.elements[0] = elements[0];\n       result.elements[1] = elements[3];\n       result.elements[2] = elements[6];\n       result.elements[3] = elements[1];\n       result.elements[4] = elements[4];\n       result.elements[5] = elements[7];\n       result.elements[6] = elements[2];\n       result.elements[7] = elements[5];\n       result.elements[8] = elements[8];\n       return result;\n   }\n\n  function scalarMultiply(scalar)\n  {\n       for(local i = 0;i < elements.len();i++)\n     {\n          elements[i] *= scalar;\n      }\n    }\n\n  function scalarDivition(scalar)\n  {\n    print(this + \"Div\");\n      for(local i = 0;i < elements.len();i++)\n     {\n          elements[i] /= scalar;\n      }\n    }\n\n  function matrix1x3Multiply(matrix)\n   {\n       local result = Matrix3x1();\n     result.elemnt1 = (matrix.elemnt1*elements[0]) + (matrix.elemnt2*elements[3]) + (matrix.elemnt3*elements[6]);\n    result.elemnt2 = (matrix.elemnt1*elements[1]) + (matrix.elemnt2*elements[4]) + (matrix.elemnt3*elements[7]);\n    result.elemnt3 = (matrix.elemnt1*elements[2]) + (matrix.elemnt2*elements[5]) + (matrix.elemnt3*elements[8]);\n    return result;\n   }     \n\n   function matrix3x3Multiply(matrix)\n   {\n       local result = Matrix3X3();\n     result.elements[0] = (elements[0]*matrix.elements[0]) + (elements[1]*matrix.elements[3]) + (elements[2]*matrix.elements[6]);\n    result.elements[1] = (elements[0]*matrix.elements[1]) + (elements[1]*matrix.elements[4]) + (elements[2]*matrix.elements[7]);\n    result.elements[2] = (elements[0]*matrix.elements[2]) + (elements[1]*matrix.elements[5]) + (elements[2]*matrix.elements[8]);\n    result.elements[3] = (elements[3]*matrix.elements[0]) + (elements[4]*matrix.elements[3]) + (elements[5]*matrix.elements[6]);\n    result.elements[4] = (elements[3]*matrix.elements[1]) + (elements[4]*matrix.elements[4]) + (elements[5]*matrix.elements[7]);\n    result.elements[5] = (elements[3]*matrix.elements[2]) + (elements[4]*matrix.elements[5]) + (elements[5]*matrix.elements[8]);\n    result.elements[6] = (elements[6]*matrix.elements[0]) + (elements[7]*matrix.elements[3]) + (elements[8]*matrix.elements[6]);\n    result.elements[7] = (elements[6]*matrix.elements[1]) + (elements[7]*matrix.elements[4]) + (elements[8]*matrix.elements[7]);\n    result.elements[8] = (elements[6]*matrix.elements[2]) + (elements[7]*matrix.elements[5]) + (elements[8]*matrix.elements[8]);\n    return result;\n   }\n\n  function MatrixTranslation(rVec2)\n    {\n       local result = Matrix3X3();\n     result.elements[0] = 1;result.elements[1] = 0;result.elements[3] = 0;\n       result.elements[3] = 0;result.elements[4] = 1;result.elements[5] = 0;\n       result.elements[6] = rVec2.x;result.elements[7] = rVec2.y;result.elements[8] = 1;\n       return result;    \n }\n\n  function MatrixRotation(angle)\n   {\n       local result = Matrix3X3();\n     result.elements[0] = cos(angle);result.elements[1] = sin(angle);result.elements[3] = 0;\n     result.elements[3] = -sin(angle);result.elements[4] = cos(angle);result.elements[5] = 0;\n    result.elements[6] = 0;result.elements[7] = 0;result.elements[8] = 1;\n       return result;    \n }\n}\n\nclass Matrix3x1\n{\n   constructor()\n    {\n       elemnt1 = 0;elemnt2 = 0;elemnt3 = 0;\n }\n\n  elemnt1 = null;\n  elemnt2 = null;\n  elemnt3 = null;\n\n    function fromVector2(vec2)\n   {\n       elemnt1 = vec2.x;\n       elemnt2 = vec2.y;\n       elemnt3 = 1;\n }\n\n  function toVector2()\n {\n       local nVec2 = vector_2();\n       nVec2.x = elemnt1;\n      nVec2.y = elemnt2;\n      return nVec2;\n    }  \n}\n\nclass Transform\n{\n    constructor()\n    {\n       children = [];\n      localPos = vector_2();\n      localRot = 0.0;\n  }\n\n  parent = null;\n   children = null;\n localPos = null;\n localRot = null;\n\n   function getTransformMatrix()\n    {\n       local MatTransXPos = Matrix3X3();\n       local MatRot = Matrix3X3();\n     local result = Matrix3X3();\n\n       MatTransXPos = MatTransXPos.MatrixTranslation(localPos);\n    MatRot = MatRot.MatrixRotation(localRot);\n\n     return MatRot.matrix3x3Multiply(MatTransXPos);\n   }\n\n  function getWorldMatrix()\n    {\n       local result = Matrix3X3();\n     result = getTransformMatrix();\n      if(parent != null)\n      {\n          result = result.matrix3x3Multiply(parent.getWorldMatrix());\n     }\n       return result;\n   }\n\n  function setLocalPos(nVec2)\n  {\n       localPos.x = nVec2.x;\n       localPos.y = nVec2.y;\n    }\n\n  function getPosOnWorld()\n {\n       local resVec2 = vector_2();\n     local tempMat = Matrix3X3();\n    tempMat = getWorldMatrix();\n     resVec2.x = tempMat.elements[6];\n    resVec2.y = tempMat.elements[7];\n    return resVec2;\n  }\n\n  function getLocalPos()\n   {\n       return localPos;\n }\n\n  function setLocalRot(nRot)\n   {\n       localRot = nRot;\n }\n\n  function getLocalRot()\n   {\n       return localRot;\n }\n\n  function getLocalRotOnWorld()\n    {  \n    local rotFloat = 0.0;\n       local tempMat = Matrix3X3();\n    tempMat = getWorldMatrix();\n     rotFloat = atan2(tempMat.elements[0],tempMat.elements[3]);\n      return rotFloat;\n }\n\n  function moveTransformTo(nPos)\n   {\n       setLocalPos(nPos);\n   }\n\n  function rotateTransformTo(nAng)\n {\n       setLocalRot(nAng);\n   }\n\n  function getUpVector()\n   {\n       local nVec2 = vector_2();\n       local rot = getLocalRotOnWorld();\n\n     nVec2.x = cos(rot);\n     nVec2.y = sin(rot);\n     return nVec2;\n    }\n\n  function getRightVector()\n    {\n       local nVec2 = vector_2();\n       local rot = getLocalRotOnWorld();\n       rot += (90*180)/PI;\n\n       nVec2.x = cos(rot);\n     nVec2.y = sin(rot);\n     return nVec2;\n    }\n}\n\nclass gameTransform extends Transform\n{\n constructor()\n    {\n       base.constructor();\n  }\n\n  asset = null;\n    shape = null;\n    hasAsset = null;\n hasShape = null;\n\n   function moveTo(nPos)\n    {\n       moveTransformTo(nPos);\n      move();\n  }\n\n  function move()\n  {\n       local nVec2;\n    nVec2 = getLocalPos();\n      nVec2 = getPosOnWorld();\n    if(hasAsset)\n    {\n          move_asset(asset,nVec2.x,nVec2.y);\n      }\n       if(hasShape)\n    {\n          phy_move_shape(shape,nVec2.x,nVec2.y);\n      }\n       for(local i = 0;i < children.len();i++)\n     {\n          children[i].move();\n     }\n    }\n\n  function rotateTo(nAng)\n  {\n       local angle = ((nAng*PI)/180);\n      rotateTransformTo(angle);\n       rotate();\n    }\n\n  function rotate()\n    {\n       local angle = getLocalRotOnWorld();\n     angle = ((angle*180)/PI)-90;\n    if(hasAsset)\n    {\n          rotate_asset(asset,angle);\n      }\n\n     if(children.len() > 3)\n      {\n          return;\n     }\n       if(hasShape)\n    {\n          phy_shape_set_angle(shape,angle);\n       }\n       for(local i = 0;i < children.len();i++)\n     {\n          children[i].rotate();\n          children[i].move();\n     }\n\n  }\n\n  function setAsset(nAsset)\n    {\n       asset = nAsset;\n     move_asset(asset,-width,-height);\n       hasAsset = true;\n }\n\n  function setShape(nShape)\n    {\n       shape = nShape;\n     hasShape = true;\n }\n}\n\nclass Glass extends gameTransform\n{\n constructor()\n    {\n       base.constructor();\n\n       glassStep = 0;\n\n    init();\n  }\n\n  glassStep = null;\n\n  function OnUpdate()\n  {\n       if(glassStep != 0)\n      {\n          local tempPos = localPos;\n          tempPos.x += glassStep;\n\n          moveTo(tempPos);\n    }\n    }\n\n  function moveTo(nPos)\n    {\n       nPos.y = height * 0.9;\n      base.moveTo(nPos);\n   }\n\n  function init()\n  {\n       local nVec2 = vector_2();\n       for(local i = 0;i < 4;i++)\n      {\n          children.push(gameTransform());\n        children[i].parent = this;\n         if(i==0)\n       {\n             nVec2.x = -45;\n            nVec2.y = 6500;\n        }\n          else if(i == 1)\n        {\n             nVec2.x = 45;\n             nVec2.y = 6500;\n        }\n          else if(i == 2)\n        {\n             nVec2.x = 0;\n          nVec2.y = 0;\n          children[i].setShape(phy_create_rect_shape(0,0,70,100,true));\n          }\n          else if(i == 3)\n        {\n             nVec2.x = 0;\n          nVec2.y = -50;\n            children[i].setShape(phy_create_rect_shape(0,0,60,15,true));\n          phy_set_sensor(children[i].shape,true);\n           phy_shape_set_collision_type(children[i].shape,2);\n         }\n          children[i].setLocalPos(nVec2);\n        children[i].moveTo(nVec2);\n         nVec2 = children[i].getPosOnWorld();\n    }\n    }\n}\n\nclass Figure extends gameTransform\n{\n    constructor(nPos)\n    {\n       base.constructor();\n     gridPos = nPos;\n     sizeFig = 0;\n    currAng = 0;\n    if(random_int(0,10) > 5)\n    {\n          rotRight = true;\n    }\n       else\n    {\n          rotRight = false;\n       }\n    }\n\n  onAnim = null;\n   allowsRotated = null;\n    gridPos = null;\n  figType = null;\n  sizeFig = null;\n  currAng = null;\n  rotRight = null;\n\n   function positionateOnGrid(index,size)\n   {\n       local i = 0;\n    local nVec2 = vector_2();\n       sizeFig = size;\n\n       if(size == 3)\n       {\n          grid[index].occupied = true;grid[index+1].occupied = true;grid[index+2].occupied = true;grid[index+3].occupied = true;\n         grid[index+9].occupied = true;grid[index+10].occupied = true;grid[index+11].occupied = true;grid[index+12].occupied = true;\n        grid[index+18].occupied = true;grid[index+19].occupied = true;grid[index+20].occupied = true;grid[index+21].occupied = true;\n       grid[index+27].occupied = true;grid[index+28].occupied = true;grid[index+29].occupied = true;grid[index+30].occupied = true;\n       nVec2.x = grid[index+1].pos.x + 34;\n        nVec2.y = grid[index+10].pos.y + 34;\n       moveTo(nVec2);\n      }\n       else if(size == 2)\n      {\n          grid[index].occupied = true;grid[index+1].occupied = true;grid[index+2].occupied = true;\n       grid[index+9].occupied = true;grid[index+10].occupied = true;grid[index+11].occupied = true;\n       grid[index+18].occupied = true;grid[index+19].occupied = true;grid[index+20].occupied = true;\n          moveTo(grid[index+10].pos);\n     }\n       else if(size == 1)\n      {\n          grid[index].occupied = true;\n         moveTo(grid[index].pos);\n    }\n       else if(size == 0)\n      {\n          grid[index].occupied = true;grid[index+1].occupied = true;\n         nVec2.x = grid[index].pos.x + 34;\n          nVec2.y = grid[index].pos.y;\n       moveTo(nVec2);\n      }\n    }\n\n  function rotateFig()\n {\n       local tempSum = 0;\n      if(rotRight)\n    {\n          tempSum = 5 + ((level-1)*3);\n    }\n       else\n    {\n          tempSum = -(5 + ((level-1)*3));\n     }\n       currAng += tempSum;\n     if(currAng > 350 || currAng < -350)\n     {\n          currAng = 0;\n    }\n       rotateTo(currAng);\n   }\n}\n\nclass bigCross extends Figure\n{\n constructor(nPos)\n    {\n       base.constructor(nPos);\n     figType = 0;\n    onAnim = true;\n\n    setAsset(load_asset(10,false));\n\n       children.push(gameTransform());\n     children[0].parent = this;\n      children[0].setShape(phy_create_rect_shape(0,0,244,28,true));\n\n     children.push(gameTransform());\n     children[1].parent = this;\n      children[1].setShape(phy_create_rect_shape(0,0,28,230,true));\n    }\n}\n\nclass bigLine extends Figure\n{\n  constructor(nPos)\n    {\n       base.constructor(nPos);\n     figType = 1;\n    onAnim = true;\n\n    setAsset(load_asset(11,false));\n\n       children.push(gameTransform());\n     children[0].parent = this;\n      children[0].setShape(phy_create_rect_shape(0,0,28,230,true));\n    }\n}\n\nclass bigTriangle extends Figure\n{\n  constructor(nPos)\n    {\n       base.constructor(nPos);\n     figType = 2;\n    onAnim = true;\n\n    local nVec2 = vector_2();\n       setAsset(load_asset(12,false));\n\n       children.push(gameTransform());\n     children[0].parent = this;\n      children[0].setShape(phy_create_rect_shape(0,0,30,200,true));\n       children[0].rotateTo(30);\n       nVec2.x = -39;\n      nVec2.y = 2;\n    children[0].moveTo(nVec2);\n\n    children.push(gameTransform());\n     children[1].parent = this;\n      children[1].setShape(phy_create_rect_shape(0,0,30,200,true));\n       children[1].rotateTo(-30);\n      nVec2.x = 39;\n       nVec2.y = 2;\n    children[1].moveTo(nVec2);\n\n    children.push(gameTransform());\n     children[2].parent = this;\n      children[2].setShape(phy_create_rect_shape(0,0,210,30,true));\n       nVec2.x = 0;\n    nVec2.y = 87;\n       children[2].moveTo(nVec2);\n   }\n}\n\nclass mediumCross extends Figure\n{\n  constructor(nPos)\n    {\n       base.constructor(nPos);\n     figType = 3;\n    onAnim = true;\n\n    setAsset(load_asset(20,false));\n\n       children.push(gameTransform());\n     children[0].parent = this;\n      children[0].setShape(phy_create_rect_shape(0,0,188,20,true));\n\n     children.push(gameTransform());\n     children[1].parent = this;\n      children[1].setShape(phy_create_rect_shape(0,0,20,168,true));\n    }\n}\n\nclass mediumCircle extends Figure\n{\n constructor(nPos)\n    {\n       base.constructor(nPos);\n     figType = 4;\n    onAnim = true;\n\n    setAsset(load_asset(21,false));\n\n       children.push(gameTransform());\n     children[0].parent = this;\n      children[0].setShape(phy_create_circle_shape_for_asset(this.asset,79));\n\n       local nVec2 = vector_2();\n       children.push(gameTransform());\n     children[1].parent = this;\n      children[1].setShape(phy_create_rect_shape(0,0,20,20,true));\n    children[1].rotateTo(45);\n       nVec2.x = -55;\n      nVec2.y = 72;\n       children[1].moveTo(nVec2);\n\n    local nVec2 = vector_2();\n       children.push(gameTransform());\n     children[2].parent = this;\n      children[2].setShape(phy_create_rect_shape(0,0,20,20,true));\n    children[2].rotateTo(45);\n       nVec2.x = 55;\n       nVec2.y = 72;\n       children[2].moveTo(nVec2);\n\n    children.push(gameTransform());\n     children[3].parent = this;\n   }\n}\n\nclass mediumTriangle extends Figure\n{\n   constructor(nPos)\n    {\n       base.constructor(nPos);\n     figType = 5;\n    onAnim = true;\n\n    setAsset(load_asset(22,false));\n\n       local nVec2 = vector_2();\n       children.push(gameTransform());\n     children[0].parent = this;\n      children[0].setShape(phy_create_rect_shape(0,0,15,140,true));\n       children[0].rotateTo(30);\n       nVec2.x = -30;\n      nVec2.y = 2;\n    children[0].moveTo(nVec2);\n\n    children.push(gameTransform());\n     children[1].parent = this;\n      children[1].setShape(phy_create_rect_shape(0,0,15,140,true));\n       children[1].rotateTo(-30);\n      nVec2.x = 30;\n       nVec2.y = 2;\n    children[1].moveTo(nVec2);\n\n    children.push(gameTransform());\n     children[2].parent = this;\n      children[2].setShape(phy_create_rect_shape(0,0,124,15,true));\n       nVec2.x = 0;\n    nVec2.y = 55;\n       children[2].moveTo(nVec2);\n   }\n}\n\nclass smallCircle extends Figure\n{\n  constructor(nPos)\n    {\n       base.constructor(nPos);\n     figType = 6;\n    onAnim = true;\n\n    setAsset(load_asset(30,false));\n\n       children.push(gameTransform());\n     children[0].parent = this;\n      children[0].setShape(phy_create_circle_shape_for_asset(this.asset,20));\n\n       local nVec2 = vector_2();\n       children.push(gameTransform());\n     children[1].parent = this;\n      children[1].setShape(phy_create_rect_shape(0,0,2,2,true));\n      children[1].rotateTo(45);\n       nVec2.x = -15;\n      nVec2.y = 12;\n       children[1].moveTo(nVec2);\n\n    local nVec2 = vector_2();\n       children.push(gameTransform());\n     children[2].parent = this;\n      children[2].setShape(phy_create_rect_shape(0,0,2,2,true));\n      children[2].rotateTo(45);\n       nVec2.x = 15;\n       nVec2.y = 12;\n       children[2].moveTo(nVec2);\n\n    children.push(gameTransform());\n     children[3].parent = this;\n   }\n}\n\nclass smallTriangle extends Figure\n{\n    constructor(nPos)\n    {\n       base.constructor(nPos);\n     figType = 7;\n    onAnim = true;\n\n    setAsset(load_asset(31,false));\n\n       local nVec2 = vector_2();\n       children.push(gameTransform());\n     children[0].parent = this;\n      children[0].setShape(phy_create_rect_shape(0,0,10,40,true));\n    children[0].rotateTo(29);\n       nVec2.x = -11;\n      nVec2.y = 0;\n    children[0].moveTo(nVec2);\n\n    children.push(gameTransform());\n     children[1].parent = this;\n      children[1].setShape(phy_create_rect_shape(0,0,10,40,true));\n    children[1].rotateTo(-29);\n      nVec2.x = 11;\n       nVec2.y = 0;\n    children[1].moveTo(nVec2);\n\n    children.push(gameTransform());\n     children[2].parent = this;\n      children[2].setShape(phy_create_rect_shape(0,0,50,10,true));\n    nVec2.x = 0;\n    nVec2.y = 20;\n       children[2].moveTo(nVec2);\n   }\n}\n\nclass smallLine extends Figure\n{\n    constructor(nPos)\n    {\n       base.constructor(nPos);\n     figType = 8;\n    onAnim = true;\n\n    setAsset(load_asset(32,false));\n\n       children.push(gameTransform());\n     children[0].parent = this;\n      children[0].setShape(phy_create_rect_shape(0,0,15,40,true));\n }\n}\n\nclass Tile\n{\n    constructor(nPos)\n    {\n       pos = vector_2();\n       pos.x = nPos.x;\n     pos.y = nPos.y;\n     occupied = false;\n    }\n\n  pos = null;\n  occupied = null;\n}\n\nclass Bar\n{\n  constructor(id, nPos)\n    {\n       ID = id;\n    asset = load_asset(ID,false);\n       bPos = vector_2();\n      bPos.x = nPos.x;\n    bPos.y = nPos.y;\n    move_asset(asset,bPos.x,bPos.y);\n }\n\n  ID = null;\n   bPos = null;\n asset = null;\n\n  function moveBar2Pos()\n   {\n       move_asset(asset,bPos.x,bPos.y);\n }  \n\n   function removeBar()\n {\n       move_asset(asset,-height,-width);\n    }\n}\n\n\nfunction init()\n{\n local nVec2 = vector_2();\n\n  backGround = load_asset(1,false);\n    move_asset(backGround,width*0.5,height*0.5);\n\n   player = Glass();\n    player.setAsset(load_asset(2,false));\n    nVec2.x = width * 0.5;\n   nVec2.y = height * 0.9;\n  player.moveTo(nVec2);\n\n  spawner = load_asset(3,false);\n   spawnPos.x = width * 0.5;\n    spawnPos.y = (height * 0.1) + 50;\n    move_asset(spawner,spawnPos.x,spawnPos.y);\n\n for(local i = 0;i < 30;i++)\n  {\n       balls.push(load_asset(4,false));\n    move_asset(balls[i],-width,-height);\n    ballShp.push(phy_create_circle_shape_for_asset(balls[i],12));\n       phy_move_shape(ballShp[i],-width,-height);\n      phy_shape_set_collision_type(ballShp[i],1);\n  }\n\n  floorShp = phy_create_rect_shape(width*0.5,height+20,width*2,80,true);\n   phy_shape_set_collision_type(floorShp,2);\n    phy_set_gravity(0,350);\n  phy_create_collision_handler_begin(1,2,killBalls);\n\n leftWall = phy_create_rect_shape(-10,height*0.5,20,height,true);\n phy_shape_set_collision_type(leftWall,3);\n    rightWall = phy_create_rect_shape(width+10,height*0.5,20,height,true);\n   phy_shape_set_collision_type(rightWall,3);\n   phy_create_collision_handler_begin(1,3,pushBall);\n\n  goalImg = load_asset(5,false);\n   move_asset(goalImg,width*0.5,height*0.97);\n\n levelImg = load_asset(6,false);\n  move_asset(levelImg,width*0.1,asset_get_height(levelImg)*0.5);\n\n loseImg = load_asset(7,false);\n   move_asset(loseImg,width * 0.6,height*0.033);\n\n  local nVtor = vector_2();\n    local xStep = 0;\n nVtor.x = width * 0.2;\n   nVtor.y = height*0.965;\n  xStep = (asset_get_width(goalImg)*0.87)*0.05;\n    for(local i = 0; i < 20; i++) \n   {\n       fill_below.push(Bar(8, nVtor));\n     nVtor.x += xStep;\n    }\n\n  nVtor.x = width * 0.3;\n   nVtor.y = height*0.03;\n   xStep = (asset_get_width(loseImg)*0.87)*0.05;\n    for(local i = 0; i < 20; i++) \n   {\n       fill_above.push(Bar(9, nVtor));\n     nVtor.x += xStep;\n    }\n\n  initializeGrid();\n\n  for(local i=0; i<5; i++) \n    {\n       img_levels.push(load_asset(40+i, true));\n    move_asset(img_levels[i], 360, 640);\n }\n}\n\nfunction start_level(level_num)\n{\n  score = 0;\n    level = 1;\n   internalStart();\n}\n\nfunction internalStart()\n{\n   for(local i = 0;i < ballShp.len();i++)\n   {\n       move_asset(balls[i],-width,-height);\n    phy_reset_forces(ballShp[i]);\n       phy_shape_set_velocity(ballShp[i],0,0);\n     phy_move_shape(ballShp[i],-width,-height);\n   }\n    removeShow();\n    getPices();\n  setPieces();\n mirrorPieces();\n  animAdmin();\n movement = true;\n countScore = 0;\n  belowCont = 0;\n   aboveCont = fill_above.len()-1;\n  leveledUp = false;\n   for(local i=0; i<fill_below.len();i++) \n  {\n       if(countScore == 0)\n     {\n          fill_below[i].removeBar();\n      }\n       else\n    {\n          fill_below[i].moveBar2Pos();\n    }\n    }\n\n  for(local i=0; i<fill_above.len();i++) \n  {\n       fill_above[i].moveBar2Pos();\n }\n    call_function_after_time(myStart,3000);\n\n    showLevelText = true;\n    call_function_after_time(turnOffText,1000);\n\n    maxBalls = 100 + toLosePerLevel[level-1];\n    spawnedBalls = 0;\n    lose = 0;\n}\n\nfunction update()\n{\n local nVec2 = vector_2();\n    for(local i = 0;i < balls.len();i++)\n {\n       nVec2 = phy_get_shape_position(ballShp[i]);\n     move_asset(balls[i],nVec2.x,nVec2.y);\n    }\n    if(aboveCont <= 0 && !leveledUp)\n {\n       local updateLose = true;\n    for(local i = 0;i < balls.len();i++)\n    {\n          nVec2 = phy_get_shape_position(ballShp[i]);\n        if(nVec2.x > 0)\n        {\n             updateLose = false;\n        }\n       }\n       if(updateLose)\n      {\n          didLose();\n      }\n    }\n}\n\nfunction draw()\n{\n   draw_asset(backGround);\n\n    draw_asset(player.asset);\n    draw_asset(spawner);\n\n   for(local i = 0;i < balls.len();i++)\n {\n       draw_asset(balls[i]);\n    }\n    for(local j = 0;j < gameFigures.len();j++)\n   {\n       draw_asset(gameFigures[j].asset);\n    }\n    for(local k = 0;k < gameFigMirror.len();k++)\n {\n       draw_asset(gameFigMirror[k].asset);\n  }  \n\n   for(local i = fill_above.len()-1;i >= 0;i--)\n {\n       draw_asset(fill_above[i].asset);\n }\n\n  for(local i = fill_below.len()-1;i >= 0;i--)\n {\n       draw_asset(fill_below[i].asset);\n }\n\n  draw_asset(loseImg);\n draw_asset(goalImg);\n draw_asset(levelImg);\n    \n draw_text(width * 0.6,height*0.949,2,score);\n draw_text(width * 0.08,height*0.04,2.5,level);\n   draw_text(width * 0.56,height*0.015,2,maxBalls-spawnedBalls);\n    draw_text(showPlus.x,showPlus.y,1.5,\"+1\");\n draw_text(showPlus.x+50,showPlus.y-50,2,bonus);\n\n    if(showLevelText)\n    {\n       levels();\n    }\n}\n\nfunction levels() \n{\n    switch(level) \n   {\n       case 1: \n       draw_asset(img_levels[0]);\n         break;\n      case 2: \n       draw_asset(img_levels[1]);\n         break;\n      case 3: \n       draw_asset(img_levels[2]);\n         break;\n      case 4: \n       draw_asset(img_levels[3]);\n         break;\n      default: \n          draw_asset(img_levels[4]);\n         break;\n   }\n}\n\nfunction turnOffText()\n{\n    showLevelText = false;\n   showLoseText = false;\n    showWinText = false;\n}\n\nfunction touch_move(pos_x,pos_y) \n{\n  local nVec2 = player.getPosOnWorld();\n\n  if(pos_x >= (asset_get_width(player.asset) * 0.4) && pos_x <= (width - (asset_get_width(player.asset) * 0.4)))\n   {\n       nVec2.x = pos_x;\n    player.moveTo(nVec2);\n    }\n\n}\n\nfunction myStart() \n{\n spawnerMvnt();\n   spawnBall();\n}\n\nfunction spawnerMvnt()\n{\n if(step > 20)\n    {\n       step = 0;\n    }\n\n  if(dir == 1)\n {\n       if(spawnPos.x > (width * 0.9))\n      {\n          dir = 0;\n    }\n       spawnPos.x += vel;\n   }\n    else\n {\n       if(spawnPos.x < (width * 0.1))\n      {\n          dir = 1;\n    }\n       spawnPos.x -= vel;\n   }\n    step ++;\n move_asset(spawner,spawnPos.x,spawnPos.y);\n   if(movement)\n {\n       call_function_after_time(spawnerMvnt,100);\n   }\n}\n\nfunction spawnBall()\n{\n  if(spawnedBalls < maxBalls)\n  {\n       move_asset(balls[currBall],spawnPos.x,spawnPos.y)\n       phy_move_shape(ballShp[currBall],spawnPos.x,spawnPos.y);\n       phy_reset_forces(ballShp[currBall]);\n       phy_shape_set_velocity(ballShp[currBall],0,0);\n    currBall++;\n     spawnedBalls++;\n     if(currBall == ballShp.len())\n       {\n          currBall = 0;\n       }\n       if(movement)\n    {\n          call_function_after_time(spawnBall,spawnVelocityPerLevel[level-1]);\n     }\n\n     if(spawnedBalls%(maxBalls*0.05) < 1) \n       {\n          if(aboveCont > 0)\n          {\n             fill_above[aboveCont].removeBar();\n            aboveCont--;\n            if(aboveCont == 0)\n            {\n             fill_above[aboveCont].removeBar();\n            }\n       }\n       }\n    }\n}\n\nfunction killBalls(shape_1,shape_2)\n{\n   for(local i = 0;i < ballShp.len();i++)\n   {\n       if(compare_shapes(shape_1,ballShp[i]))\n      {\n          move_asset(balls[i],-width,-height);\n       phy_reset_forces(ballShp[i]);\n       phy_shape_set_velocity(ballShp[i],0,0);\n        phy_move_shape(ballShp[i],-width,-height);\n         lose++;\n        if(compare_shapes(shape_2,floorShp))\n       {\n             combo = 0;\n         }\n          else\n       {\n          score++;\n          play_effect(1);\n          countScore++;\n             if(countScore%5 == 0 && countScore > 0) \n          {\n                if(belowCont < fill_below.len())\n             {\n                   fill_below[belowCont].moveBar2Pos();\n                belowCont++;\n             }\n             }\n             combo++;\n          showPlus = phy_get_shape_position(shape_1);\n           call_function_after_time(removeShow,300);\n             if(score >= (level*100))\n          {\n              movement = false;\n                gameOver();\n           }\n          }\n          if(lose == maxBalls)\n       {\n             movement = false;\n             gameOver();\n        }\n          break;\n      }\n    }\n}\n\nfunction removeShow()\n{\n showPlus.x = -width;\n showPlus.y = -height;\n    bonus = \"\";\n}\n\nfunction pushBall(shape_1,shape_2)\n{\n    if(compare_shapes(shape_2,rightWall))\n    {\n       phy_shape_add_impulse(shape_1,-10,0);\n    }\n    else\n {\n       phy_shape_add_impulse(shape_1,10,0);\n }\n}\n\nfunction initializeGrid()\n{\n local nVec2 = vector_2();\n    nVec2.x = 84;\n    nVec2.y = 297;\n   for(local i = 0;i < rows;i++)\n    {\n       for(local j = 0;j < cols;j++)\n       {\n          grid.push(Tile(nVec2));\n        nVec2.x += 68;\n      }\n       nVec2.y += 68;\n      nVec2.x = 84;\n    }\n}\n\nfunction getPices()\n{\n   local probability = 60;\n  local modifier = 0;\n  local i = 0;\n local rdm = 0;\n   local currWeight = 0;\n\n  for(i = 0;i < 2;i++)\n {\n       rdm = random_int(0,100);\n    if(rdm > (probability+modifier))\n    {\n          pieces.push(3);\n        modifier += 20;\n        currWeight += 16;\n       }\n    }\n    if(currWeight == 32)\n {\n       return;\n  }\n    if(modifier == 0)\n    {\n       modifier = -40;\n  }\n    else\n {\n       modifier = -20;\n  }\n    for(i = 0;i < 4;i++)\n {\n       rdm = random_int(0,100);\n    if(rdm > (probability+modifier))\n    {\n          pieces.push(2);\n        modifier += 35;\n        currWeight += 9;\n    }\n       else\n    {\n          modifier -= 10;\n     }\n       if(currWeight >= 32)\n    {\n          break;\n      }\n    }\n    if(currWeight >= 32)\n {\n       return;\n  }\n    for(i = 0; i < (32-currWeight);i++)\n  {\n       rdm = random_int(0,100);\n    if(rdm > 40)\n    {\n          pieces.push(1);\n        currWeight += 1;\n    }\n    }\n}\n\n\nfunction setPieces()\n{\n    local i = 0;\n local j = 0;\n local k = 0;\n local probability = 30;\n  local rdm = 0;\n   local count1 = 0;\n    local options = [];\n\n    for(i = 0;i < pieces.len();i++)\n  {\n       if(pieces[i] == 3)\n      {\n          if(pieces[1] == 3)\n         {\n             rdm = random_int(0,100);\n          if(rdm > 50)\n          {\n                createPiece(3,0);\n             }\n             else\n          {\n                createPiece(3,9);\n             }\n             rdm = random_int(0,100);\n          if(rdm > 50)\n          {\n                createPiece(3,45);\n            }\n             else\n          {\n                createPiece(3,54);\n            }\n             i++;\n       }\n          else\n       {\n             for(j = 0;j < 7;j++)\n          {\n                rdm = random_int(0,100)\n              if(rdm < probability)\n                {\n                   createPiece(3,j*9)\n                  break;\n               }\n                else\n             {\n                   probability += 10;\n               }\n             }\n          }\n       }\n       else if(pieces[i] == 2)\n     {\n          for(j = 0,k=0;j < 86;j++,k++)\n          {\n             if(j%9 != 2)\n          {\n                if(verify3x3(j))\n             {\n                   options.push(j);\n             }\n             }\n             if(k == 3)\n            {\n                j += 5;\n              k = -1;\n              if(j >= 86)\n              {\n                   break;\n               }\n             }\n          }\n          if(options.len() > 0)\n          {\n             rdm = random_int(0,options.len()-1);\n          createPiece(2,options[rdm]);\n          options = [];\n          }\n       }\n       else if(pieces[i] == 1)\n     {\n          count1++;\n       }\n    }\n    if(count1 == 0)\n  {\n       return;\n  }\n    options = [];\n    for(j = 0,k=0;j < 86;j++,k++)\n    {\n       if(verify2x2(j))\n    {\n          options.push(j);\n    }\n       if(k == 4)\n      {\n          j += 4;\n        k = -1;\n     }\n    }\n    if((count1%3) == 0 || (count1%5) == 0)\n   {\n       probability = 50;\n       for(i = 0;i < options.len();i++)\n    {\n          if(options[i]%9 < 3)\n       {\n             rdm = random_int(0,100);\n          if(rdm < probability)\n             {\n                createPiece(0,options[i]);\n               createPiece(1,options[i]+9);\n             createPiece(1,options[i]+10);\n                count1 -= 3;\n             break;\n            }\n             else\n          { probability += 10; }\n         }\n       }\n    }\n    probability = 10;\n    for(i = 0;i < count1;i++)\n    {\n       for(j = 0,k = 0;j < 86;j++,k++)\n     {\n          if(!grid[j].occupied)\n          {\n             rdm = random_int(0,100);\n          if(rdm < probability)\n             {\n                createPiece(1,j);\n                probability = 10;\n                break;\n            }\n             else\n          {\n                probability += 5;\n             }\n          }\n          if(k == 4)\n         {\n             j += 4;\n           k = -1;\n        }\n       }\n    }\n} \n\nfunction verify3x3(ndx)\n{\n  if(ndx+18 >= grid.len() || ndx+9 >= grid.len())\n  {\n       return false;\n    }\n    if(!grid[ndx].occupied && !grid[ndx+1].occupied && !grid[ndx+2].occupied &&\n     !grid[ndx+9].occupied && !grid[ndx+10].occupied && !grid[ndx+11].occupied &&\n    !grid[ndx+18].occupied && !grid[ndx+19].occupied && !grid[ndx+20].occupied)\n  {\n       return true;\n }\n    return false;\n}\n\nfunction verify2x2(ndx)\n{\n   if(ndx+9 >= grid.len())\n  {\n       return false;\n    }\n    if(!grid[ndx].occupied && !grid[ndx+1].occupied &&\n      !grid[ndx+9].occupied && !grid[ndx+10].occupied)\n {\n       return true;\n }\n    return false;\n}\n\nfunction createPiece(size,index)\n{\n  print(\"Creando \" + index);\n if(grid[index].occupied && size < 2)\n {\n       return;\n  }\n    switch(size)\n {\n       case(0):\n    {\n          gameFigures.push(getRandomFromSize(size,index));\n       gameFigures[gameFigures.len()-1].positionateOnGrid(index,size);\n     }\n       break;\n      case(1):\n    {\n\n        gameFigures.push(getRandomFromSize(size,index));\n       gameFigures[gameFigures.len()-1].positionateOnGrid(index,size);\n     }\n       break;\n      case(2):\n    {\n          gameFigures.push(getRandomFromSize(size,index));\n       gameFigures[gameFigures.len()-1].positionateOnGrid(index,size);\n     }\n       break;\n      case(3):\n    {\n          gameFigures.push(getRandomFromSize(size,index));\n       gameFigures[gameFigures.len()-1].positionateOnGrid(index,size);\n     }\n       break;\n   }\n}\n\nfunction mirrorPieces()\n{\n   local index = 0;\n local rdm = 0;\n\n for(local i = 0;i < gameFigures.len();i++)\n   {\n       if(gameFigures[i].sizeFig == 0)\n     {\n          if((gameFigures[i].gridPos%9) < 4)\n         {\n             index = gameFigures[i].gridPos + getMirrorOf(gameFigures[i].gridPos%9);\n           index--;\n          gameFigMirror.push(getFigFromType(gameFigures[i].figType,index));\n             gameFigMirror[gameFigMirror.len()-1].positionateOnGrid(index,0);         \n       }\n       }\n       else if(gameFigures[i].sizeFig == 1)\n    {\n          index = gameFigures[i].gridPos + getMirrorOf(gameFigures[i].gridPos%9);\n        if(grid[index].occupied == false)\n          {\n             gameFigMirror.push(getFigFromType(gameFigures[i].figType,index));\n             gameFigMirror[gameFigMirror.len()-1].positionateOnGrid(index,1);\n       }\n       }\n       else if(gameFigures[i].sizeFig == 2)\n    {\n          switch(gameFigures[i].gridPos%9)\n       {\n          case(0):\n       {\n             index = gameFigures[i].gridPos + 6;\n           gameFigMirror.push(getFigFromType(gameFigures[i].figType,index));\n             gameFigMirror[gameFigMirror.len()-1].positionateOnGrid(index,2);\n          rdm = random_int(50,100);\n             if(rdm < 50 && verify3x3(index-3))\n            {\n                index = gameFigures[i].gridPos + 3;\n              gameFigMirror.push(getFigFromType(gameFigures[i].figType,index));\n                gameFigMirror[gameFigMirror.len()-1].positionateOnGrid(index,2);\n          }\n          }\n          break;\n         case(1):\n       {\n             index = gameFigures[i].gridPos + 4;\n           if(verify3x3(index))\n          {\n                gameFigMirror.push(getFigFromType(gameFigures[i].figType,index));\n                gameFigMirror[gameFigMirror.len()-1].positionateOnGrid(index,2);\n          }\n          }\n          break;\n         case(3):\n       {\n             rdm = random_int(0,100);\n          index = gameFigures[i].gridPos;\n           if(rdm < 50 && verify3x3(index-3) && verify3x3(index+3))\n          {\n                index = gameFigures[i].gridPos + 3;\n              gameFigMirror.push(getFigFromType(gameFigures[i].figType,index));\n                gameFigMirror[gameFigMirror.len()-1].positionateOnGrid(index,2);\n             index = gameFigures[i].gridPos - 3;\n              gameFigMirror.push(getFigFromType(gameFigures[i].figType,index));\n                gameFigMirror[gameFigMirror.len()-1].positionateOnGrid(index,2);\n          }\n          }\n          break;\n         }\n       }\n       else\n    {\n          index = gameFigures[i].gridPos + 5;\n        if(!grid[index].occupied)\n          {\n             gameFigMirror.push(getFigFromType(gameFigures[i].figType,index));\n             gameFigMirror[gameFigMirror.len()-1].positionateOnGrid(index,3);\n       }\n       }\n    }\n}\n\nfunction getMirrorOf(num)\n{\n switch(num)\n  {\n    case(0):\n {\n       return 8;\n    }\n    break;\n   case(1):\n {\n       return 6;\n    }\n    break;\n   case(2):\n {\n       return 4;\n    }\n    break;\n   case(3):\n {\n       return 2;\n    }\n    break;\n   case(4):\n case(5):\n {\n       return 0;\n    }\n    break;\n   }\n}\n\nfunction getRandomFromSize(size,index)\n{\n    local rdm = random_int(0,100);\n\n switch(size)\n {\n    case(0):\n case(1):\n {\n       if(rdm < 33)\n    {\n          return smallCircle(index);\n      }\n       else if(rdm < 66)\n       {\n          return smallTriangle(index);\n    }\n       else\n    {\n          return smallLine(index);\n    }\n    }\n    break\n    case(2):\n {\n       if(rdm < 33)\n    {\n          return mediumCircle(index);\n     }\n       else if(rdm < 66)\n       {\n          return mediumTriangle(index);\n       }\n       else\n    {\n          return mediumCross(index);\n      }\n    }\n    break\n    case(3):\n {\n       if(rdm < 33)\n    {\n          return bigCross(index);\n     }\n       else if(rdm < 66)\n       {\n          return bigLine(index);\n      }\n       else\n    {\n          return bigTriangle(index);\n      }\n    }\n    break\n    }\n}\n\nfunction getFigFromType(type,index)\n{\n   switch(type)\n {\n    case(0):\n { return bigCross(index);}\n   break;\n   case(1):\n { return bigLine(index);}\n    break;\n   case(2):\n { return bigTriangle(index);}\n    break;\n   case(3):\n { return mediumCross(index);}\n    break;\n   case(4):\n { return mediumCircle(index);}\n   break;\n   case(5):\n { return mediumTriangle(index);}\n break;\n   case(6):\n { return smallCircle(index);}\n    break;\n   case(7):\n { return smallTriangle(index);}\n  break;\n   case(8):\n { return smallLine(index);}\n  break;\n   }\n}\n\nfunction animAdmin()\n{\n  local needToAnim = false;\n    local i = 0;\n for(i = 0;i < gameFigures.len();i++)\n {\n       if(gameFigures[i].onAnim)\n       {\n          needToAnim = true;\n         gameFigures[i].rotateFig();\n     }\n    }\n    for(i = 0;i < gameFigMirror.len();i++)\n   {\n       if(gameFigMirror[i].onAnim)\n     {\n          needToAnim = true;\n         gameFigMirror[i].rotateFig();\n       }\n    }\n    if(needToAnim)\n   {\n       call_function_after_time(animAdmin,100);\n }\n}\n\nfunction gameOver()\n{\n   for(local i = 0;i < gameFigures.len();i++)\n   {\n       for(local j = 0;j < gameFigures[i].children.len();j++)\n      {\n          if(gameFigures[i].children[j].shape != null)\n       {\n             phy_remove_shape(gameFigures[i].children[j].shape);\n        }\n       }\n    }\n    for(local i = 0;i < gameFigMirror.len();i++)\n {\n       for(local j = 0;j < gameFigMirror[i].children.len();j++)\n    {\n          if(gameFigMirror[i].children[j].shape != null)\n         {\n             phy_remove_shape(gameFigMirror[i].children[j].shape);\n          }\n       }\n    }\n    for(local i = 0;i < grid.len();i++)\n  {\n       grid[i].occupied = false;\n    }\n    for(local i = 0;i < ballShp.len();i++)\n   {\n       move_asset(balls[i],-width,-height);\n    phy_reset_forces(ballShp[i]);\n       phy_shape_set_velocity(ballShp[i],0,0);\n     phy_move_shape(ballShp[i],-width,-height);\n   }\n    gameFigures = [];\n    gameFigMirror = [];\n  pieces = [];\n currBall = 0;\n    leveledUp = true;\n    countScore = 0;\n  showLevelText = true;\n    call_function_after_time(turnOffText,1000);\n  if(((spawnedBalls == maxBalls) || !ballsOnScene()) && score < (level*100))\n    {\n       didLose();\n       print(\"Perdiendo 1\");\n      return;\n  }\n    lose = 0;\n    if(level == 5)\n   {\n       didLose();\n       print(\"Perdiendo 2\");\n       return;\n   }\n    else if(score >= (level*100))\n {\n      level ++;\n      play_effect(2);\n      clear_functions_after_time();\n      call_function_after_time(internalStart,3000);\n    }\n}\n\nfunction didLose()\n{\n    showWinText = true;\n  showLevelText = false;\n   call_function_after_time(turnOffText,1000);\n  goToGameOver();\n}\n\nfunction ballsOnScene()\n{   \n local nVec2 = vector_2();\n    for(local i = 0;i < balls.len();i++)\n {\n       nVec2 = phy_get_shape_position(ballShp[i]);\n     if(nVec2.y < height)\n    {\n          return true;\n    }\n    }\n    return false;\n}\n\nfunction goToGameOver()\n{\n  save_highscore_gameover(score);\n  lose = 0;\n  play_effect(3);\n  goto_menu_after_ms(\"gameOver\",2000);\n}"
  }, {
    "name": "Alien",
    "projectID": 1317,
    "gameID": 1317,
    "script": "local WINDOW_WIDTH = 720;\nlocal WINDOW_HEIGHT = 1280;\n\n\nlocal assetFondo;\nlocal assetUI;\nlocal assetPersonaje;\nlocal img_level;\nlocal explosionPlayer;\nlocal explosionEnemy;\n\nlocal pj;\n\nlocal enemigos = [];\nlocal balas = [];\n\nlocal posYInicialEnemigo;\nlocal enemyVelocity = 1;\n\nlocal tiempoDisparaEnemigos;\nlocal tiempoEsperaDisparaEnemigos;\nlocal tiempoDisparaPersonaje;\nlocal tiempoEsperaDisparaPersonaje;\n\nlocal score;\nlocal esGameOver;\n\nlocal vidas;\nlocal enemigoscaidos;\nlocal level=1;\nlocal numAliens =0;\nlocal flag;\nlocal flagCaller;\nlocal flagb;\nlocal flagbCaller;\nlocal auxResistencia = 0;\n\nlocal deltaTime = 0;\nlocal previousTime = 0;\nlocal globalFactor = -1;\nlocal globalAnimHalfWidth = 0;\n\n\nclass Personaje\n{\n    x = 0;\n    y = 0;\n    vel = 0;\n    ancho = 0;\n    alto = 0;\n    shape = null;\n    mueve = -1;\n    constructor(_x, _y)\n    {\n        this.x = _x;                    \n        this.y = _y;                    \n        this.vel = 16;                  \n        this.ancho = asset_get_width(assetPersonaje)*0.5;       \n        this.alto = asset_get_height(assetPersonaje)*0.5;       \n\n        this.shape = phy_create_shape_for_asset(assetPersonaje, false);         \n        phy_move_shape(this.shape, this.x, this.y);             \n        phy_shape_set_collision_type(this.shape, 1);    \n    }\n    function step()\n    {\n        if (this.shape != null)\n        {\n            if (mueve == 0)\n                    this.x -= this.vel;\n            else if (mueve == 1)\n                    this.x += this.vel;\n\n            if (this.x <= 0 + this.ancho)\n                    this.x += this.vel;\n            else if (this.x >= WINDOW_WIDTH - this.ancho)\n                    this.x -= this.vel;\n        }\n    }\n    function dibuja()\n    {\n        if (this.shape != null)\n        {\n            phy_move_shape(this.shape, this.x, this.y);\n            move_asset(assetPersonaje, this.x, this.y);\n            draw_asset(assetPersonaje);\n        }\n    }\n    function destroy()\n    {\n        phy_remove_shape(this.shape);\n        this.shape = null;\n    }\n}\n\nclass GameObject\n{\n    constructor()\n    {\n        position = vector_2();\n    }\n\n    asset = null;\n    shape = null;\n    position = null;\n\n    function initGameObject(id,withShape)\n    {\n        asset = load_asset(id,false);\n\n        if(withShape)\n        {\n            shape = phy_create_shape_for_asset(asset,false);\n        }\n    }\n\n    function moveObject(posX,posY)\n    {\n        if(asset != null)\n        {\n            move_asset(asset,posX,posY);\n        }\n        if(shape != null)\n        {\n            phy_move_shape(shape,posX,posY);\n        }\n        position.x = posX;\n        position.y = posY;\n    }\n\n    function readjustToPosition()\n    {\n        moveObject(position.x,position.y);\n    }\n\n    function Draw()\n    {\n        if(asset != null)\n        {\n            draw_asset(asset);\n        }\n    }\n}\nenum animType\n{\n    X_MOVEMENT,\n    Y_MOVEMENT,\n    X_Y_MOVEMENT\n};\nclass FrameRateFreeAnimator extends GameObject\n{\n    constructor()\n    {\n        base.constructor();\n        progress = 2;\n        isRuning = false;\n    }\n\n    duration = null;\n    factor = null;\n    initPoint = null;\n    progress = null;\n    aType = null;\n    onCompleteCalled = null;\n    callBack = null;\n    isRuning = null;\n\n    function advanceAnimation()\n    {\n        progress += deltaTime * duration;\n\n        if(progress < 1)\n        {\n            runAnim();\n        }\n        else if(!onCompleteCalled)\n        {\n            onCompleteCalled = true;\n            onComplete();\n        }\n    }\n\n    function runAnim()\n    {\n        switch(aType)\n        {\n        case(animType.X_MOVEMENT):\n            position.x += factor * (deltaTime * duration);\n        break;\n        case(animType.Y_MOVEMENT):\n            position.y += factor * (deltaTime * duration);\n        break;\n        case(animType.X_Y_MOVEMENT):\n            position.x += factor.x * (deltaTime * duration);\n            position.y += factor.y * (deltaTime * duration);\n        break;\n        }\n        moveObject(position.x,position.y);\n    }\n\n    function setUp(anmType,nFactor,cllBack)\n    {\n        callBack = cllBack;\n        aType = anmType;\n        if(anmType == animType.X_Y_MOVEMENT)\n        {\n            factor = vector_2();\n            factor.x = nFactor.x;\n            factor.y = nFactor.y;\n        }\n        else\n        {\n            factor = nFactor;\n        }\n    }\n\n    function startAnim(nDuration)\n    {\n        if(!isRuning)\n        {\n            isRuning = true;\n            setInit();\n            if(nDuration > 0)\n            {\n                duration = 1.0/nDuration;\n            }\n            progress = 0;\n            onCompleteCalled = false;\n        }\n    }\n\n    function setInit()\n    {\n        switch(aType)\n        {\n        case(animType.X_MOVEMENT):\n            initPoint = position.x;\n        break;\n        case(animType.Y_MOVEMENT):\n            initPoint = position.y;\n        break;\n        case(animType.X_Y_MOVEMENT):\n            initPoint = position;\n        break;\n        }\n    }\n\n    function onComplete()\n    {\n        adjustToAbsolute();\n        isRuning = false;\n        if(callBack != null)\n        {\n            callBack();\n        }\n    }\n\n    function adjustToAbsolute()\n    {\n        switch(aType)\n        {\n        case(animType.X_MOVEMENT):\n            position.x = initPoint + factor;\n        break;\n        case(animType.Y_MOVEMENT):\n            position.y = initPoint + factor;\n        break;\n        case(animType.X_Y_MOVEMENT):\n            position.x = initPoint.x + factor.x;\n            position.y = initPoint.y + factor.y;\n        break;\n        }\n        moveObject(position.x,position.y);\n    }\n}\n\nclass Enemigo extends FrameRateFreeAnimator\n{\n    tipo = 0;\n    ancho = 0;\n    alto = 0;\n    resistencia = 0;\n    constructor(_x, _y, _tipo, resist)\n    {\n        base.constructor();\n\n        position.x = _x;\n        position.y = _y;\n        this.tipo = _tipo;\n        this.resistencia = 1 + resist;       \n\n        if (tipo == 1)\n        {\n            initGameObject(10,true);\n        }\n        else if (tipo == 2)\n        {\n            initGameObject(11,true);\n        }\n        else if (tipo == 3)\n        {\n            initGameObject(12,true);\n        }\n        else if (tipo == 4)\n        {\n            initGameObject(13,true);\n        }\n        else if (tipo == 5)\n        {\n            initGameObject(14,true);\n        }\n        ancho = asset_get_width(asset)*0.5;\n        alto = asset_get_height(asset)*0.5;\n\n        phy_move_shape(shape, position.x, position.y);             \n        phy_shape_set_collision_type(shape, 2);\n\n        if(globalFactor == -1)\n        {\n            globalAnimHalfWidth = (asset_get_width(asset)*0.5);\n            globalFactor = _x - globalAnimHalfWidth;\n        }\n\n        setUp(animType.X_MOVEMENT,globalFactor,flipAnimation);\n    }\n\n    function step()\n    {\n        advanceAnimation();\n        if (this.shape != null)\n        {\n            if (position.x <= 0 + this.ancho)\n            {\n                return true;\n            }\n            else if (position.x >= WINDOW_WIDTH - this.ancho)\n            {\n                return true;\n            }\n\n            if (position.y >= WINDOW_HEIGHT * 0.90)\n            {\n                esGameOver = true;\n                eliminaTodo();\n                finJuego();\n            }\n            return false;\n        }\n    }\n\n    function dibuja()\n    {\n        draw_asset(asset);\n    }\n\n    function destroy()\n    {\n        phy_remove_shape(this.shape);\n        this.shape = null;\n    }\n\n    function bajaEnemigos()\n    {\n        position.y += 20;\n    }\n\n    function flipAnimation()\n    {\n        if(factor == globalFactor)\n        {\n            factor *= 2;\n            duration *= 0.5;\n        }\n        factor *= -1;\n        startAnim(-1);\n    }\n}\n\nclass Bala extends FrameRateFreeAnimator\n{\n    ancho = 0;\n    alto = 0;\n    vel = 0;\n    tipo = 0;\n    constructor(_x, _y, _vel, _tipo)\n    {\n        base.constructor();\n\n        position.x = _x;                            \n        position.y = _y;                            \n        this.vel = _vel;                        \n        this.tipo = _tipo;                      \n\n        if(this.tipo == 1)\n        {\n            initGameObject(6,true);\n            setUp(animType.Y_MOVEMENT,-WINDOW_HEIGHT,null);\n        }\n        else\n        {\n            initGameObject(4,true);\n            setUp(animType.Y_MOVEMENT,WINDOW_HEIGHT,null);\n        }\n        ancho = asset_get_width(asset)*0.5;    \n        alto = asset_get_height(asset)*0.5;   \n        scale_asset(asset, 2.5, 1); \n\n        phy_shape_set_collision_type(shape, 3);\n        phy_set_sensor(shape, true);                               \n        phy_move_shape(shape, position.x, position.y);             \n        \n        startAnim(1.5);\n    }\n\n    function step()\n    {   \n        advanceAnimation();\n\n        if (position.y < 0 + this.alto || position.y > WINDOW_HEIGHT * 0.91)\n        {\n            destroy();\n            return true;\n        }\n        return false;\n    }\n    function dibuja()\n    {\n        draw_asset(asset);\n    }\n    function destroy()\n    {\n        phy_remove_shape(shape);\n        shape = null;\n    }\n}\n\nfunction init()\n{\n    assetFondo                      = load_asset(1, true);          \n    assetUI                         = load_asset(2, true);         \n    assetPersonaje                  = load_asset(3, true);          \n    explosionPlayer                 = load_asset(5, true);          \n    explosionEnemy                  = load_asset(7, true);          \n    img_level                       = load_asset(8, true);       \n\n    move_asset(img_level, 360, 640);\n\n    phy_create_collision_handler_begin(1, 2, colPersonajeEnemigo);          \n    phy_create_collision_handler_begin(1, 3, colPersonajeBala);                     \n    phy_create_collision_handler_begin(2, 3, colEnemigoBala);                       \n}\n\nfunction start_level(numLevel)\n{\n    posYInicialEnemigo = 400;\n    vidas = 3;\n    enemigoscaidos = 0;\n    level = 1;\nenemyVelocity = 1;\n    numAliens = 16;\n    flag = true;\n    flagCaller = false;\n    flagb = false;\n    flagbCaller = false;\n    auxResistencia = 0;    \n\n    tiempoDisparaEnemigos = get_time()-1000;\n    tiempoEsperaDisparaEnemigos = 1500;\n    tiempoDisparaPersonaje = 0;\n    tiempoEsperaDisparaPersonaje = 250;\n    score = 0;\n    esGameOver = false;\n\n    enemigos.clear();               \n    balas.clear();                  \n\n    pj = Personaje(WINDOW_WIDTH * 0.5, WINDOW_HEIGHT * 0.90);\n    while(posYInicialEnemigo >= 100)\n    {\n        creaFila(posYInicialEnemigo, -1, -1);\n        posYInicialEnemigo -= 100;\n    }\n\n    previousTime = get_time();\n    startAnimators();\n}\n\nfunction startAnimators()\n{\n    foreach(id, val in enemigos)    \n    {\n        foreach(id2, val2 in val)\n        {\n            val2.startAnim(0.6*enemyVelocity);\n        }\n    }\n}\n\nfunction update()\n{\n    deltaTime = (get_time() - previousTime) * 0.001;\n    pj.step();\n    getXPlayer();\n    local chocoEnemigoPared_i = -1;\n    local chocoEnemigoPared_j = -1;\n\nif(!flag)\n{\n    foreach(id, val in enemigos)    \n    {\n        foreach(id2, val2 in val)\n        {\n            try\n            {\n                assert(val2 != null);\n                if (val2.step())        \n                {\n                    chocoEnemigoPared_i = id;\n                    chocoEnemigoPared_j = id2;\n                }\n            }\n            catch(exception)\n            {\n                continue;\n            }\n        }\n    }\n\n    if (chocoEnemigoPared_i != -1)  \n    {\n        avanzaEnemigos();\n        readjustAnimators();\n    }\n    creaEnemigos(chocoEnemigoPared_i, chocoEnemigoPared_j);\n    disparaEnemigo();\n    foreach(id, val in balas)               \n    {\n        try\n        {\n            if (val.step())\n            {\n                balas.remove(id);\n                id--;\n            }\n        }\n        catch(exception)\n        {\n            continue;\n        }\n    }\n}\n    previousTime = get_time();\n}\n\nfunction draw()\n{\n    move_asset(assetFondo, WINDOW_WIDTH * 0.5, WINDOW_HEIGHT * 0.5);\n    draw_asset(assetFondo);\n    foreach(id, val in balas)\n    {\n        val.dibuja();\n    }\n    pj.dibuja();\n    foreach(id, val in enemigos)\n {\n       foreach(id2, val2 in val)\n       {\n          val2.dibuja();\n      }\n    }\n    move_asset(assetUI, WINDOW_WIDTH * 0.5, (asset_get_height(assetUI)/2));\n    draw_asset(assetUI);\n    draw_text(80, 15, 3, score);\n    draw_text(340, 13, 3, vidas);\n    draw_text(610, 15, 3, level);\n    bang();\n    mensaje();\n}\n\nfunction bang() \n{\n    if(flagb)\n    {\n        draw_asset(explosionEnemy);\n        if(!flagbCaller)\n        {\n          call_function_after_time(quitarbang, 300);\n           flagbCaller = true;\n        }\n    }\n}\n\nfunction quitarbang() \n{\n   flagb = false;\n   flagbCaller = false;\n}\n\nfunction mensaje()\n{\n    if(flag) \n    {\n        draw_asset(img_level);\n        draw_text2(WINDOW_WIDTH*0.47, WINDOW_HEIGHT*0.53, 3, level,make_rgba(0,0,0,255));\n        if(!flagCaller)\n        {\n           call_function_after_time(borrarmensaje, 800);\n            flagCaller = true;\n       }\n    }\n}\n\nfunction borrarmensaje() \n{\n    flag = false;\n    flagCaller = false;\n}\n\nfunction colPersonajeEnemigo(shape_1, shape_2)\n{\n    if (esGameOver == false)\n    {\n        eliminaTodo();\n        finJuego();\n        esGameOver = true;\n    }\n}\n\nfunction colPersonajeBala(shape_1, shape_2)\n{\n    for(local i  = 0;i < balas.len();i++)\n    {\n        if (compare_shapes(balas[i].shape, shape_2))\n        {\n            if (balas[i].tipo == 2)\n            {\n                vidas--;\n                play_effect(2);\n                flagb = true;\n                if(vidas <= 0) \n                {\n                    eliminaTodo();\n                    finJuego();\n                    esGameOver = true;\n                }\n            }\n        }            \n    }   \n}\n\nfunction colEnemigoBala(shape_1, shape_2)\n{\n    for(local i  = balas.len()-1;i >= 0;i--)\n    {\n        if (compare_shapes(balas[i].shape, shape_2) && balas[i].tipo == 1)\n        {\n            play_effect(3);\n            score++;\n            enemigoscaidos++;\n            if(score%10 == 0) \n            {\n                vidas++;\n            }\n            if (tiempoEsperaDisparaEnemigos > 500)\n            {\n                tiempoEsperaDisparaEnemigos -= 50;\n            }\n            for(local j = enemigos.len()-1;j >= 0;j--)\n            {\n                for(local k = enemigos[j].len()-1;k >= 0;k--)\n                {\n                    if (compare_shapes(enemigos[j][k].shape, shape_1))\n                    {   \n                        enemigos[j][k].resistencia--;\n                        if(enemigos[j][k].resistencia == 0) \n                        {\n                            enemigos[j][k].destroy();\n                            enemigos[j].remove(k);\n                        }\n                    }\n                    if (enemigos[j].len() == 0)\n                    {\n                       enemigos.remove(j);\n                    }\n                }\n            }\n            balas[i].destroy();\n            balas.remove(i);\n        }\n    }\n}\n\nfunction finJuego()\n{\n    play_effect(5);\n    save_highscore_gameover(score);\n    goto_menu_after_ms(\"gameover\", 50);    \n}\n\nfunction eliminaEnemigos()\n{\n    for (local i = 0; i < balas.len(); i++)\n    {\n        if (balas[i] != null)\n        {\n            balas[i].destroy();\n            balas.remove(i);\n            i--;\n        }\n    }\n    balas.clear();  \n    for (local i = 0; i < enemigos.len(); i++)\n    {\n        for (local j = 0; j < enemigos[i].len(); j++)\n        {\n            if (enemigos[i][j] != null)\n            {\n                enemigos[i][j].destroy();\n                enemigos[i].remove(j);\n                j--;\n            }\n        }\n        enemigos[i].clear();\n    }\n    enemigos.clear();  \n}\n\nfunction eliminaTodo()\n{\n    flag  = false;\n    flagb = false;\n    pj.destroy();\neliminaEnemigos();\n}\n\nfunction creaFila(posY, chocoEneP_i, chocoEneP_j)\n{\n    local fila = [];\n    local tipoEnemigo = random_int(1, 5);\n    local numEnemigos = 4;\n    local separacion = WINDOW_WIDTH / (numEnemigos+1);\n    local getXE = getXEnemigo(numEnemigos, chocoEneP_i, chocoEneP_j);\n    local res = 0;\n\n    for (local i = 0; i < numEnemigos; i++)\n    {\n        fila.push(Enemigo(getXE + separacion * i, posY, tipoEnemigo, auxResistencia));\n    }\n    enemigos.push(fila);\n}\nfunction creaEnemigos(chocoEnePared_i, chocoEnePared_j)\n{\n    if (enemigos.len() <= 0 && esGameOver == false)\n    {\n        eliminaEnemigos();\n        play_effect(4);\n        level++;\n        call_function_after_time(newLevelReward, 500);\n        (level%3 == 0) ? auxResistencia++ : 0;\n        if(level%2 == 0)\n        {\n            enemyVelocity -= 0.1;\n        }\n        posYInicialEnemigo = 400;\n        while(posYInicialEnemigo >= 100)\n        {\n            creaFila(posYInicialEnemigo, -1, -1);\n            posYInicialEnemigo -= 100;\n        }\n        flag = true;\n    }\n    startAnimators();\n}\nfunction newLevelReward()\n{\n        score += 5;\n        vidas++;\n}\nfunction avanzaEnemigos()\n{\n    foreach(id, val in enemigos)\n    {\n        foreach(id2, val2 in val)\n        {\n            try\n            {\n                val2.bajaEnemigos();    \n            }\n            catch(exception)\n            {\n                continue;\n            }\n        }\n    }\n}\nfunction getXEnemigo(numEnemigos, EnemigoPared_i, EnemigoPared_j)\n{\n    local separa = WINDOW_WIDTH / (numEnemigos+1);\n    if (enemigos.len() > 0 && EnemigoPared_i >= 0 && EnemigoPared_j >= 0)\n    {\n        local pos = enemigos[EnemigoPared_i][EnemigoPared_j].x;\n        local cantidadEnemigosLinea = enemigos[EnemigoPared_i].len();\n        if (pos > WINDOW_WIDTH * 0.5 )\n        {\n            pos = pos - (separa * (numEnemigos-1));\n        }\n        return pos;\n    }\n    return separa;\n}\nfunction disparaEnemigo()\n{\n    if (tiempoDisparaEnemigos < get_time() - tiempoEsperaDisparaEnemigos)\n    {\n        local rand = random_int(0,4);\n        local rand2 = 0;\n\n        foreach(id, val in enemigos)\n        {\n            foreach(id2, val2 in val)\n            {\n                rand2 = random_int(0,4);\n                if(rand == rand2)\n                {\n                    balas.push(Bala(val2.position.x, val2.position.y, 18, 2));\n                    break;\n                }\n            }\n        }\n        tiempoDisparaEnemigos = get_time();\n    }\n}\n\nfunction getXPlayer() \n{\n    local w = pj.x;\n    move_asset(explosionEnemy, w, WINDOW_HEIGHT*0.89);\n}\n\nfunction touch_start(pos_x,pos_y)\n{\n    if (tiempoDisparaPersonaje < get_time() - tiempoEsperaDisparaPersonaje && !flag)\n    {\n        play_effect(1);\n        balas.push(Bala(pj.x, pj.y, 30, 1));\n        tiempoDisparaPersonaje = get_time();\n    }\n}\n\nfunction on_accelerometer_update(x,y,z)\n{\n  local xFactor = 10;\n    if (x < -0.1 && pj.x > 60)            \n    {\n      pj.x -= xFactor;\n    }\n    else if (x > 0.1 && pj.x < 660)            \n    {\n      pj.x += xFactor;\n    }\n    else\n    {\n      pj.mueve = -1;\n    }\n}\n\nfunction get_arrow_keys(key, state)\n{\n    if (key == 0 && state == 1)                                     \n            pj.mueve = 0;\n    else if (key == 1 && state == 1)                                        \n            pj.mueve = 1;\n    else if (key == 1 && state == 1)                                        \n            pj.mueve = -1;\n\n\n    if (key == 2 && state == 1)\n    {\n        if (tiempoDisparaPersonaje < get_time() - tiempoEsperaDisparaPersonaje)\n        {\n            play_effect(1);\n            balas.push(Bala(pj.x, pj.y, 30, 1));\n            tiempoDisparaPersonaje = get_time();\n        }\n    }\n}\n\nfunction getEnemiesLeftDist()\n{\n    local leftPos = WINDOW_WIDTH;\n    for(local i = 0;i < enemigos.len();i++)\n    {\n        for(local j = 0;j < enemigos[i].len();j++)\n        {\n            if(enemigos[i][j].position.x < leftPos)\n            {\n                leftPos = enemigos[i][j].position.x;\n            }\n        }\n    }\n    return leftPos;\n}\n\nfunction getEnemiesRightDist()\n{\n    local rightPos = 0;\n    for(local i = 0;i < enemigos.len();i++)\n    {\n        for(local j = 0;j < enemigos[i].len();j++)\n        {\n            if(enemigos[i][j].position.x > rightPos)\n            {\n                rightPos = enemigos[i][j].position.x;\n            }\n        }\n    }\n    return (WINDOW_WIDTH - rightPos);\n}\n\nfunction readjustAnimators()\n{\n    local goingLeft = enemigos[0][0].factor > 0 ? false : true;\n    local newDistance;\n    local percent;\n    local divider;\n\n    if(goingLeft)\n    {\n        newDistance = getEnemiesLeftDist() - globalAnimHalfWidth;\n    }\n    else\n    {\n        newDistance = getEnemiesRightDist() - globalAnimHalfWidth;\n    }\n    if(abs(newDistance) > abs(enemigos[0][0].factor))\n    {\n        percent = (abs(newDistance)*1.0) / abs(enemigos[0][0].factor);\n        divider = 1.0 / percent;\n        for(local i = 0;i < enemigos.len();i++)\n        {\n            for(local j = 0;j < enemigos[i].len();j++)\n            {\n                enemigos[i][j].factor *= percent;\n                enemigos[i][j].duration *= divider;\n            }\n        }\n    }\n}"
  }]
}